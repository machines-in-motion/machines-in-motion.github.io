<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dynamic_graph_manager: dynamic_graph::DynamicGraphManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dynamic_graph_manager
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdynamic__graph_1_1DynamicGraphManager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classdynamic__graph_1_1DynamicGraphManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dynamic_graph::DynamicGraphManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class has for purpose to manage the different processes during run time.  
 <a href="classdynamic__graph_1_1DynamicGraphManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dynamic__graph__manager_8hh_source.html">dynamic_graph_manager.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dynamic_graph::DynamicGraphManager:</div>
<div class="dyncontent">
<div class="center"><img src="classdynamic__graph_1_1DynamicGraphManager__inherit__graph.png" border="0" usemap="#dynamic__graph_1_1DynamicGraphManager_inherit__map" alt="Inheritance graph"/></div>
<map name="dynamic__graph_1_1DynamicGraphManager_inherit__map" id="dynamic__graph_1_1DynamicGraphManager_inherit__map">
<area shape="rect" id="node2" href="classdynamic__graph__manager_1_1SimpleDGM.html" title="This class is a simple dynamic graph manager with a fake hardware interface used for unittesting..." alt="" coords="25,95,191,136"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd98424082e5a1f878e6c7cb08a62c4a"><td class="memItemLeft" align="right" valign="top"><a id="afd98424082e5a1f878e6c7cb08a62c4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#afd98424082e5a1f878e6c7cb08a62c4a">DynamicGraphManager</a> ()</td></tr>
<tr class="memdesc:afd98424082e5a1f878e6c7cb08a62c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html" title="This class has for purpose to manage the different processes during run time. ">DynamicGraphManager</a>, constructor of the class. <br /></td></tr>
<tr class="separator:afd98424082e5a1f878e6c7cb08a62c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcf93d16574035ee654289274d0a790"><td class="memItemLeft" align="right" valign="top"><a id="a6bcf93d16574035ee654289274d0a790"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a6bcf93d16574035ee654289274d0a790">~DynamicGraphManager</a> ()</td></tr>
<tr class="memdesc:a6bcf93d16574035ee654289274d0a790"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html" title="This class has for purpose to manage the different processes during run time. ">DynamicGraphManager</a>, destructor of the class. <br /></td></tr>
<tr class="separator:a6bcf93d16574035ee654289274d0a790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6859456bbdd4307cb880dc5e54131dd"><td class="memItemLeft" align="right" valign="top"><a id="ac6859456bbdd4307cb880dc5e54131dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ac6859456bbdd4307cb880dc5e54131dd">initialize</a> (YAML::Node param)</td></tr>
<tr class="memdesc:ac6859456bbdd4307cb880dc5e54131dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the basic variables <br /></td></tr>
<tr class="separator:ac6859456bbdd4307cb880dc5e54131dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93272fcbb3793dfc92422186022ecf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a93272fcbb3793dfc92422186022ecf72">run</a> ()</td></tr>
<tr class="memdesc:a93272fcbb3793dfc92422186022ecf72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a93272fcbb3793dfc92422186022ecf72" title="run() splits the process in the dynamic_graph process and the hadware_communication process...">run()</a> splits the process in the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> process and the hadware_communication process.  <a href="#a93272fcbb3793dfc92422186022ecf72">More...</a><br /></td></tr>
<tr class="separator:a93272fcbb3793dfc92422186022ecf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dab9ca9c8901779a944386f2b8898c"><td class="memItemLeft" align="right" valign="top"><a id="a18dab9ca9c8901779a944386f2b8898c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a18dab9ca9c8901779a944386f2b8898c">wait_start_dynamic_graph</a> ()</td></tr>
<tr class="memdesc:a18dab9ca9c8901779a944386f2b8898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait_start_dynamic_graph put the current thread to sleep until the user start the dynamic graph <br /></td></tr>
<tr class="separator:a18dab9ca9c8901779a944386f2b8898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab827a776b4ac31ea91ace9a2bfc1e99d"><td class="memItemLeft" align="right" valign="top"><a id="ab827a776b4ac31ea91ace9a2bfc1e99d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ab827a776b4ac31ea91ace9a2bfc1e99d">wait_stop_dynamic_graph</a> ()</td></tr>
<tr class="memdesc:ab827a776b4ac31ea91ace9a2bfc1e99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait_stop_dynamic_graph put the current thread to sleep until the user stop the dynamic graph <br /></td></tr>
<tr class="separator:ab827a776b4ac31ea91ace9a2bfc1e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a98e169cd587d101bba69bb799e408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a83a98e169cd587d101bba69bb799e408">wait_stop_hardware_communication</a> ()</td></tr>
<tr class="memdesc:a83a98e169cd587d101bba69bb799e408"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait_stop_hardware_communication put the current thread to sleep until the user stop the hardware communication.  <a href="#a83a98e169cd587d101bba69bb799e408">More...</a><br /></td></tr>
<tr class="separator:a83a98e169cd587d101bba69bb799e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81926d5d33573d667bc6511bbb2d8f52"><td class="memItemLeft" align="right" valign="top"><a id="a81926d5d33573d667bc6511bbb2d8f52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a81926d5d33573d667bc6511bbb2d8f52">initialize_dynamic_graph_process</a> ()</td></tr>
<tr class="memdesc:a81926d5d33573d667bc6511bbb2d8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize_dynamic_graph_process instanciates all variables related to the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> and user interface. <br /></td></tr>
<tr class="separator:a81926d5d33573d667bc6511bbb2d8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56acce72235fe0786830ec19a3439309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a56acce72235fe0786830ec19a3439309">run_python_command</a> (std::ostream &amp;file, const std::string &amp;command)</td></tr>
<tr class="memdesc:a56acce72235fe0786830ec19a3439309"><td class="mdescLeft">&#160;</td><td class="mdescRight">run_python_command  <a href="#a56acce72235fe0786830ec19a3439309">More...</a><br /></td></tr>
<tr class="separator:a56acce72235fe0786830ec19a3439309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cc3b7fefc7fe146dc112a7e6d55f3d"><td class="memItemLeft" align="right" valign="top"><a id="a11cc3b7fefc7fe146dc112a7e6d55f3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a11cc3b7fefc7fe146dc112a7e6d55f3d">python_prologue</a> ()</td></tr>
<tr class="memdesc:a11cc3b7fefc7fe146dc112a7e6d55f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">python_prologue get the pointer of the device in the the python interpretor. <br /></td></tr>
<tr class="separator:a11cc3b7fefc7fe146dc112a7e6d55f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e23eb4ce0acaef397bf84a770b9f015"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a8e23eb4ce0acaef397bf84a770b9f015">run_dynamic_graph_process</a> ()</td></tr>
<tr class="memdesc:a8e23eb4ce0acaef397bf84a770b9f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">run_dynamic_graph_process spawns the real time thread and becomes a ros spinner (thread in charge of the ros::service callbacks).  <a href="#a8e23eb4ce0acaef397bf84a770b9f015">More...</a><br /></td></tr>
<tr class="separator:a8e23eb4ce0acaef397bf84a770b9f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e7cb10262383030c10156730d39ce8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a81e7cb10262383030c10156730d39ce8">run_hardware_communication_process</a> ()</td></tr>
<tr class="memdesc:a81e7cb10262383030c10156730d39ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">run_hardware_communication_process spawns the real time thread.  <a href="#a81e7cb10262383030c10156730d39ce8">More...</a><br /></td></tr>
<tr class="separator:a81e7cb10262383030c10156730d39ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f5aef302173293a0c162c28505ef8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ad13f5aef302173293a0c162c28505ef8">run_single_process</a> ()</td></tr>
<tr class="memdesc:ad13f5aef302173293a0c162c28505ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">run_single_process spawns the real time thread.  <a href="#ad13f5aef302173293a0c162c28505ef8">More...</a><br /></td></tr>
<tr class="separator:ad13f5aef302173293a0c162c28505ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3927887762c52c7bf50ab5a565c3077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ae3927887762c52c7bf50ab5a565c3077">initialize_hardware_communication_process</a> ()</td></tr>
<tr class="memdesc:ae3927887762c52c7bf50ab5a565c3077"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize_hardware_communication_process instanciate all variables related to the hardware communication.  <a href="#ae3927887762c52c7bf50ab5a565c3077">More...</a><br /></td></tr>
<tr class="separator:ae3927887762c52c7bf50ab5a565c3077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bddce83d5185433041ad27610b85b3a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a7bddce83d5185433041ad27610b85b3a">get_sensors_to_map</a> (<a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> &amp;)</td></tr>
<tr class="memdesc:a7bddce83d5185433041ad27610b85b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_sensors_to_map is the fonction that get the motor command from a map and that uses the drivers to send these command to the robot.  <a href="#a7bddce83d5185433041ad27610b85b3a">More...</a><br /></td></tr>
<tr class="separator:a7bddce83d5185433041ad27610b85b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506e6f37ac7205efaf0efe4202cde897"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a506e6f37ac7205efaf0efe4202cde897">set_motor_controls_from_map</a> (const <a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> &amp;)</td></tr>
<tr class="memdesc:a506e6f37ac7205efaf0efe4202cde897"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_motor_controls_from_map is the fonction that get the motor command from a map and that uses the drivers to send these command to the robot.  <a href="#a506e6f37ac7205efaf0efe4202cde897">More...</a><br /></td></tr>
<tr class="separator:a506e6f37ac7205efaf0efe4202cde897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb31040121d6041b4dd6556f5c7eac"><td class="memItemLeft" align="right" valign="top"><a id="a60bb31040121d6041b4dd6556f5c7eac"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a60bb31040121d6041b4dd6556f5c7eac">compute_safety_controls</a> ()</td></tr>
<tr class="memdesc:a60bb31040121d6041b4dd6556f5c7eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute_safety_controls computes safety controls very fast in case the dynamic graph is taking to much computation time or has crashed. <br /></td></tr>
<tr class="separator:a60bb31040121d6041b4dd6556f5c7eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c7c528ef283fbfb803377c8c631b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ad3c7c528ef283fbfb803377c8c631b4c">stop_dynamic_graph</a> ()</td></tr>
<tr class="memdesc:ad3c7c528ef283fbfb803377c8c631b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop_dynamic_graph stop the DynamicGraph.  <a href="#ad3c7c528ef283fbfb803377c8c631b4c">More...</a><br /></td></tr>
<tr class="separator:ad3c7c528ef283fbfb803377c8c631b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd2b965dde19d12d63f5928a4f670c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a1bfd2b965dde19d12d63f5928a4f670c">start_dynamic_graph</a> ()</td></tr>
<tr class="memdesc:a1bfd2b965dde19d12d63f5928a4f670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">start_dynamic_graph start the DynamicGraph.  <a href="#a1bfd2b965dde19d12d63f5928a4f670c">More...</a><br /></td></tr>
<tr class="separator:a1bfd2b965dde19d12d63f5928a4f670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab929d21277e5d2fba726b8ae422c27a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ab929d21277e5d2fba726b8ae422c27a8">is_dynamic_graph_stopped</a> ()</td></tr>
<tr class="memdesc:ab929d21277e5d2fba726b8ae422c27a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the status of the dynamic graph (is running or not)  <a href="#ab929d21277e5d2fba726b8ae422c27a8">More...</a><br /></td></tr>
<tr class="separator:ab929d21277e5d2fba726b8ae422c27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf11778fb69e5203d38c8093de60bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aabf11778fb69e5203d38c8093de60bab">stop_hardware_communication</a> ()</td></tr>
<tr class="memdesc:aabf11778fb69e5203d38c8093de60bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop_hardware_communication stops the hardware communication.  <a href="#aabf11778fb69e5203d38c8093de60bab">More...</a><br /></td></tr>
<tr class="separator:aabf11778fb69e5203d38c8093de60bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234bef10fea6e3f9beb1580491127660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a234bef10fea6e3f9beb1580491127660">start_hardware_communication</a> ()</td></tr>
<tr class="memdesc:a234bef10fea6e3f9beb1580491127660"><td class="mdescLeft">&#160;</td><td class="mdescRight">start_hardware_communication starts the hardware communication.  <a href="#a234bef10fea6e3f9beb1580491127660">More...</a><br /></td></tr>
<tr class="separator:a234bef10fea6e3f9beb1580491127660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc53ebec6e5f2057c23a05894715125"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#afcc53ebec6e5f2057c23a05894715125">is_hardware_communication_stopped</a> ()</td></tr>
<tr class="memdesc:afcc53ebec6e5f2057c23a05894715125"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the status of the hardware communication (is running or not).  <a href="#afcc53ebec6e5f2057c23a05894715125">More...</a><br /></td></tr>
<tr class="separator:afcc53ebec6e5f2057c23a05894715125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c11927e0b76e91fabc4b34ea7fb85bc"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a9c11927e0b76e91fabc4b34ea7fb85bc">pid_dynamic_graph_process</a> ()</td></tr>
<tr class="memdesc:a9c11927e0b76e91fabc4b34ea7fb85bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">pid_dynamic_graph_process is an accessor on the pid of the process  <a href="#a9c11927e0b76e91fabc4b34ea7fb85bc">More...</a><br /></td></tr>
<tr class="separator:a9c11927e0b76e91fabc4b34ea7fb85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1abb11591e037e203329e900c89f4f5"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ac1abb11591e037e203329e900c89f4f5">pid_hardware_communication_process</a> ()</td></tr>
<tr class="memdesc:ac1abb11591e037e203329e900c89f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">pid_hardware_communication_process is an accessor on the pid of the process  <a href="#ac1abb11591e037e203329e900c89f4f5">More...</a><br /></td></tr>
<tr class="separator:ac1abb11591e037e203329e900c89f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bb14375da3d2aaaeafb356b6ca54f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamic__graph_1_1Device.html">Device</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a90bb14375da3d2aaaeafb356b6ca54f7">device</a> ()</td></tr>
<tr class="memdesc:a90bb14375da3d2aaaeafb356b6ca54f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">device is a getter method on the <a class="el" href="classdynamic__graph_1_1Device.html">Device</a> internal pointer.  <a href="#a90bb14375da3d2aaaeafb356b6ca54f7">More...</a><br /></td></tr>
<tr class="separator:a90bb14375da3d2aaaeafb356b6ca54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab980a2384c817ab5f59e712a54b2261a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ab980a2384c817ab5f59e712a54b2261a">has_dynamic_graph_process_died</a> ()</td></tr>
<tr class="memdesc:ab980a2384c817ab5f59e712a54b2261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">has_dynamic_graph_process_died check if the process of the DynamicGraph has died or not.  <a href="#ab980a2384c817ab5f59e712a54b2261a">More...</a><br /></td></tr>
<tr class="separator:ab980a2384c817ab5f59e712a54b2261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea29e8dc351e0a50a8d2803d854d238d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aea29e8dc351e0a50a8d2803d854d238d">is_in_safety_mode</a> ()</td></tr>
<tr class="memdesc:aea29e8dc351e0a50a8d2803d854d238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_in_safety_mode check if the dynamic graph is still alive and sending commands at a descent frequency.  <a href="#aea29e8dc351e0a50a8d2803d854d238d">More...</a><br /></td></tr>
<tr class="separator:aea29e8dc351e0a50a8d2803d854d238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a391d7a3f7c3df820d31f2c1d0ff7fc51"><td class="memItemLeft" align="right" valign="top"><a id="a391d7a3f7c3df820d31f2c1d0ff7fc51"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a391d7a3f7c3df820d31f2c1d0ff7fc51">dg_ros_node_name_</a> = &quot;dynamic_graph&quot;</td></tr>
<tr class="memdesc:a391d7a3f7c3df820d31f2c1d0ff7fc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_ros_node_name_ this is the ros node name of the dynamic graph process <br /></td></tr>
<tr class="separator:a391d7a3f7c3df820d31f2c1d0ff7fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415f24927dbe9dfd0ee4a6462428bd48"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a415f24927dbe9dfd0ee4a6462428bd48">hw_com_ros_node_name_</a></td></tr>
<tr class="memdesc:a415f24927dbe9dfd0ee4a6462428bd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_com_ros_node_name_ this is the ros node name of the harware communication process  <a href="#a415f24927dbe9dfd0ee4a6462428bd48">More...</a><br /></td></tr>
<tr class="separator:a415f24927dbe9dfd0ee4a6462428bd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fa7b0a31efa6192c3dcc44fbe63886"><td class="memItemLeft" align="right" valign="top"><a id="a97fa7b0a31efa6192c3dcc44fbe63886"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a97fa7b0a31efa6192c3dcc44fbe63886">shared_memory_name_</a> = &quot;DGM_ShM&quot;</td></tr>
<tr class="memdesc:a97fa7b0a31efa6192c3dcc44fbe63886"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared_memory_name is the name of the shared memory segment to be used <br /></td></tr>
<tr class="separator:a97fa7b0a31efa6192c3dcc44fbe63886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e4f618fbdacfda8c2cdece08e401b"><td class="memItemLeft" align="right" valign="top"><a id="abd4e4f618fbdacfda8c2cdece08e401b"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#abd4e4f618fbdacfda8c2cdece08e401b">sensors_map_name_</a> = &quot;sensors_map&quot;</td></tr>
<tr class="memdesc:abd4e4f618fbdacfda8c2cdece08e401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sensors_map_name is the name of the sensor map inside the shared memory segment <br /></td></tr>
<tr class="separator:abd4e4f618fbdacfda8c2cdece08e401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056de4d7a49496b2b0812d96d93370d9"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a056de4d7a49496b2b0812d96d93370d9">motor_controls_map_name_</a></td></tr>
<tr class="memdesc:a056de4d7a49496b2b0812d96d93370d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">motor_controls_map_name is the name of the motor controls map inside the shared memory segment  <a href="#a056de4d7a49496b2b0812d96d93370d9">More...</a><br /></td></tr>
<tr class="separator:a056de4d7a49496b2b0812d96d93370d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b8d2d024a2a11473fa2d94a18002e"><td class="memItemLeft" align="right" valign="top"><a id="a909b8d2d024a2a11473fa2d94a18002e"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a909b8d2d024a2a11473fa2d94a18002e">cond_var_name_</a> = &quot;cond_var&quot;</td></tr>
<tr class="memdesc:a909b8d2d024a2a11473fa2d94a18002e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond_var_sensors_name_ is the name of the condition variable in the shared memory <br /></td></tr>
<tr class="separator:a909b8d2d024a2a11473fa2d94a18002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a72146c4ddd173869a512e9f174ad48df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a72146c4ddd173869a512e9f174ad48df">add_user_command</a> (std::function&lt; void(void)&gt; func)</td></tr>
<tr class="memdesc:a72146c4ddd173869a512e9f174ad48df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method inherited.  <a href="#a72146c4ddd173869a512e9f174ad48df">More...</a><br /></td></tr>
<tr class="separator:a72146c4ddd173869a512e9f174ad48df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adb99ba3a7a5e677b30531a69bcc922ec"><td class="memItemLeft" align="right" valign="top">ros::ServiceServer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#adb99ba3a7a5e677b30531a69bcc922ec">ros_service_start_dg_</a></td></tr>
<tr class="memdesc:adb99ba3a7a5e677b30531a69bcc922ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">ros_service_start_dg_ allows to start the dynamic graph on call.  <a href="#adb99ba3a7a5e677b30531a69bcc922ec">More...</a><br /></td></tr>
<tr class="separator:adb99ba3a7a5e677b30531a69bcc922ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf973b6da4e4fe14cae262ba94ebb191"><td class="memItemLeft" align="right" valign="top">ros::ServiceServer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#adf973b6da4e4fe14cae262ba94ebb191">ros_service_stop_dg_</a></td></tr>
<tr class="memdesc:adf973b6da4e4fe14cae262ba94ebb191"><td class="mdescLeft">&#160;</td><td class="mdescRight">ros_service_stop_dg_ allows to stop the dynamic graph on call.  <a href="#adf973b6da4e4fe14cae262ba94ebb191">More...</a><br /></td></tr>
<tr class="separator:adf973b6da4e4fe14cae262ba94ebb191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87baafbaadf396a7663da653dc5da106"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a87baafbaadf396a7663da653dc5da106">is_dynamic_graph_stopped_</a></td></tr>
<tr class="memdesc:a87baafbaadf396a7663da653dc5da106"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_dynamic_graph_stopped_ is the flag reflecting the state of the dynamic graph.  <a href="#a87baafbaadf396a7663da653dc5da106">More...</a><br /></td></tr>
<tr class="separator:a87baafbaadf396a7663da653dc5da106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a2bc0a8f04126638056f430297097e"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ab1a2bc0a8f04126638056f430297097e">is_hardware_communication_stopped_</a></td></tr>
<tr class="memdesc:ab1a2bc0a8f04126638056f430297097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_hardware_communication_stopped_ is the flag reflecting the state of the hardware communication thread.  <a href="#ab1a2bc0a8f04126638056f430297097e">More...</a><br /></td></tr>
<tr class="separator:ab1a2bc0a8f04126638056f430297097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40458dd801d1ee7e2051f8b8fab5366b"><td class="memItemLeft" align="right" valign="top"><a id="a40458dd801d1ee7e2051f8b8fab5366b"></a>
std::unique_ptr&lt; <a class="el" href="classdynamic__graph_1_1RosPythonInterpreter.html">dynamic_graph::RosPythonInterpreter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a40458dd801d1ee7e2051f8b8fab5366b">ros_python_interpreter_</a></td></tr>
<tr class="memdesc:a40458dd801d1ee7e2051f8b8fab5366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ros_python_interpreter_ptr_ is a ROS wrapper around a python interpreter. <br /></td></tr>
<tr class="separator:a40458dd801d1ee7e2051f8b8fab5366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d35de31cdb05958c1b4f539c290ae"><td class="memItemLeft" align="right" valign="top"><a id="aee7d35de31cdb05958c1b4f539c290ae"></a>
std::unique_ptr&lt; real_time_tools::RealTimeThread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aee7d35de31cdb05958c1b4f539c290ae">thread_dynamic_graph_</a></td></tr>
<tr class="memdesc:aee7d35de31cdb05958c1b4f539c290ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread_dynamic_graph_ is the real time thread that runs the dynamic graph. <br /></td></tr>
<tr class="separator:aee7d35de31cdb05958c1b4f539c290ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e1a3c59fa7d0282529e1a544e83b4d"><td class="memItemLeft" align="right" valign="top"><a id="ae0e1a3c59fa7d0282529e1a544e83b4d"></a>
std::unique_ptr&lt; real_time_tools::RealTimeThread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ae0e1a3c59fa7d0282529e1a544e83b4d">thread_hardware_communication_</a></td></tr>
<tr class="memdesc:ae0e1a3c59fa7d0282529e1a544e83b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread_hardware_communication_ is the real thread that communicate with the hardware. <br /></td></tr>
<tr class="separator:ae0e1a3c59fa7d0282529e1a544e83b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8aa645099e7e9cce426381e38b5027d"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aa8aa645099e7e9cce426381e38b5027d">pid_dynamic_graph_process_</a></td></tr>
<tr class="memdesc:aa8aa645099e7e9cce426381e38b5027d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pid_dynamic_graph_process_ is the pid of the DynamicGraph process.  <a href="#aa8aa645099e7e9cce426381e38b5027d">More...</a><br /></td></tr>
<tr class="separator:aa8aa645099e7e9cce426381e38b5027d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02232cdc5cabca34d07dada6ced38532"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a02232cdc5cabca34d07dada6ced38532">pid_hardware_communication_process_</a></td></tr>
<tr class="memdesc:a02232cdc5cabca34d07dada6ced38532"><td class="mdescLeft">&#160;</td><td class="mdescRight">pid_hardware_communication_process_ is the pid of the hardware communication process.  <a href="#a02232cdc5cabca34d07dada6ced38532">More...</a><br /></td></tr>
<tr class="separator:a02232cdc5cabca34d07dada6ced38532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416ca1c33660df4f7f74eb29df4c5a58"><td class="memItemLeft" align="right" valign="top"><a id="a416ca1c33660df4f7f74eb29df4c5a58"></a>
std::unique_ptr&lt; <a class="el" href="classdynamic__graph_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a416ca1c33660df4f7f74eb29df4c5a58">device_</a></td></tr>
<tr class="memdesc:a416ca1c33660df4f7f74eb29df4c5a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">device_ is the DynamicGraph device that manages the computation of the graph. <br /></td></tr>
<tr class="separator:a416ca1c33660df4f7f74eb29df4c5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896bf6cb22d2d88a5a6a307a2e44608e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a896bf6cb22d2d88a5a6a307a2e44608e">sensors_map_</a></td></tr>
<tr class="memdesc:a896bf6cb22d2d88a5a6a307a2e44608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sensors_map_ is a map of dynamicgraph::Vector.  <a href="#a896bf6cb22d2d88a5a6a307a2e44608e">More...</a><br /></td></tr>
<tr class="separator:a896bf6cb22d2d88a5a6a307a2e44608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eabd2f08990a1dcc1caa652b701020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a03eabd2f08990a1dcc1caa652b701020">motor_controls_map_</a></td></tr>
<tr class="memdesc:a03eabd2f08990a1dcc1caa652b701020"><td class="mdescLeft">&#160;</td><td class="mdescRight">motor_controls_map_ is a map of dynamicgraph::Vector.  <a href="#a03eabd2f08990a1dcc1caa652b701020">More...</a><br /></td></tr>
<tr class="separator:a03eabd2f08990a1dcc1caa652b701020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d8598839c07a7d81c1afed0ea0b01"><td class="memItemLeft" align="right" valign="top"><a id="a003d8598839c07a7d81c1afed0ea0b01"></a>
std::unique_ptr&lt; shared_memory::LockedConditionVariable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a003d8598839c07a7d81c1afed0ea0b01">cond_var_</a></td></tr>
<tr class="memdesc:a003d8598839c07a7d81c1afed0ea0b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond_var_sensors_ this condition variable allow the computation of the dynamic graph just after the acquisition of the sensors <br /></td></tr>
<tr class="separator:a003d8598839c07a7d81c1afed0ea0b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6cc5e58f1accce947f929d233a67fd"><td class="memItemLeft" align="right" valign="top"><a id="a7e6cc5e58f1accce947f929d233a67fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a7e6cc5e58f1accce947f929d233a67fd">has_been_waken_by_dg_</a></td></tr>
<tr class="memdesc:a7e6cc5e58f1accce947f929d233a67fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">has_been_waken_by_dg_ is a flag that indicates if the hardware communication process has been awaken by the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> process or not. <br /></td></tr>
<tr class="separator:a7e6cc5e58f1accce947f929d233a67fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafc3cf4d8f7dc938f98b7eb07b7af9a"><td class="memItemLeft" align="right" valign="top"><a id="abafc3cf4d8f7dc938f98b7eb07b7af9a"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#abafc3cf4d8f7dc938f98b7eb07b7af9a">missed_control_count_</a></td></tr>
<tr class="memdesc:abafc3cf4d8f7dc938f98b7eb07b7af9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">missed_control_count_ is counting the number of iteration when the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> failed to provide data. <br /></td></tr>
<tr class="separator:abafc3cf4d8f7dc938f98b7eb07b7af9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10922e790e039f78b0fabbb5ef944488"><td class="memItemLeft" align="right" valign="top"><a id="a10922e790e039f78b0fabbb5ef944488"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a10922e790e039f78b0fabbb5ef944488">max_missed_control_</a></td></tr>
<tr class="memdesc:a10922e790e039f78b0fabbb5ef944488"><td class="mdescLeft">&#160;</td><td class="mdescRight">max_missed_control_ if the missed_control_count_ reach the value of max_missed_control_ then we switch to safety mode. <br /></td></tr>
<tr class="separator:a10922e790e039f78b0fabbb5ef944488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1006cdb2d7e30e291d3d568923ebbc03"><td class="memItemLeft" align="right" valign="top"><a id="a1006cdb2d7e30e291d3d568923ebbc03"></a>
clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a1006cdb2d7e30e291d3d568923ebbc03">control_period_</a></td></tr>
<tr class="memdesc:a1006cdb2d7e30e291d3d568923ebbc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">control_period_ this is the control period in nanoseconds. <br /></td></tr>
<tr class="separator:a1006cdb2d7e30e291d3d568923ebbc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26167d2936575dfdbe31be4717b70cc5"><td class="memItemLeft" align="right" valign="top"><a id="a26167d2936575dfdbe31be4717b70cc5"></a>
clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a26167d2936575dfdbe31be4717b70cc5">hw_time_loop_before_sleep_</a></td></tr>
<tr class="memdesc:a26167d2936575dfdbe31be4717b70cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_time_loop_before_sleep_ is the time measurement just before the hardware communication loop goes to sleep. <br /></td></tr>
<tr class="separator:a26167d2936575dfdbe31be4717b70cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641066efdd3424bb2bd745f6ba8d315"><td class="memItemLeft" align="right" valign="top"><a id="a3641066efdd3424bb2bd745f6ba8d315"></a>
clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a3641066efdd3424bb2bd745f6ba8d315">hw_time_loop_after_sleep_</a></td></tr>
<tr class="memdesc:a3641066efdd3424bb2bd745f6ba8d315"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_time_loop_after_sleep_ is the time measurement just after the hardware communication loop goes to sleep. <br /></td></tr>
<tr class="separator:a3641066efdd3424bb2bd745f6ba8d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2f9b39e5c529d525999c3e91e06213"><td class="memItemLeft" align="right" valign="top"><a id="afb2f9b39e5c529d525999c3e91e06213"></a>
clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#afb2f9b39e5c529d525999c3e91e06213">hw_meas_sleep_time_</a></td></tr>
<tr class="memdesc:afb2f9b39e5c529d525999c3e91e06213"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_measured_sleep_time_ is the time during which the hardware communication process actually slept. <br /></td></tr>
<tr class="separator:afb2f9b39e5c529d525999c3e91e06213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f848a27f201aed320e2c6a441dc02"><td class="memItemLeft" align="right" valign="top"><a id="aa89f848a27f201aed320e2c6a441dc02"></a>
clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aa89f848a27f201aed320e2c6a441dc02">hw_ref_sleep_time_</a></td></tr>
<tr class="memdesc:aa89f848a27f201aed320e2c6a441dc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_ref_sleep_time_ is the time during which the hardware communication process is supposed to sleep. <br /></td></tr>
<tr class="separator:aa89f848a27f201aed320e2c6a441dc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9ca6b9c161ac578b6726eaa7b7826"><td class="memItemLeft" align="right" valign="top"><a id="af4c9ca6b9c161ac578b6726eaa7b7826"></a>
clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#af4c9ca6b9c161ac578b6726eaa7b7826">hw_meas_active_time_</a></td></tr>
<tr class="memdesc:af4c9ca6b9c161ac578b6726eaa7b7826"><td class="mdescLeft">&#160;</td><td class="mdescRight">hw_meas_active_time_ is the time during which the hardware communication process is supposed to sleep. <br /></td></tr>
<tr class="separator:af4c9ca6b9c161ac578b6726eaa7b7826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81617144faf55e4ed2bf60165060b0f5"><td class="memItemLeft" align="right" valign="top"><a id="a81617144faf55e4ed2bf60165060b0f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a81617144faf55e4ed2bf60165060b0f5">is_real_robot_</a></td></tr>
<tr class="memdesc:a81617144faf55e4ed2bf60165060b0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_real_robot this boolean is a parameter to indicate if yes or no we are in simulation or in a real robot mode. <br /></td></tr>
<tr class="separator:a81617144faf55e4ed2bf60165060b0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c2cc959dceef659ab1f567e06254f7"><td class="memItemLeft" align="right" valign="top"><a id="a18c2cc959dceef659ab1f567e06254f7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a18c2cc959dceef659ab1f567e06254f7">dg_active_timer_file_</a></td></tr>
<tr class="memdesc:a18c2cc959dceef659ab1f567e06254f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_active_timer_file_ this is the path to the file that will contain the computation time of each of the dynamic graph complete execution. <br /></td></tr>
<tr class="separator:a18c2cc959dceef659ab1f567e06254f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02dbc7fb67674937208abe4cd75d652"><td class="memItemLeft" align="right" valign="top"><a id="af02dbc7fb67674937208abe4cd75d652"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#af02dbc7fb67674937208abe4cd75d652">dg_sleep_timer_file_</a></td></tr>
<tr class="memdesc:af02dbc7fb67674937208abe4cd75d652"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_sleep_timer_file_ this is the path to the file that will contain the sleep duration of the dynamic graph thread. <br /></td></tr>
<tr class="separator:af02dbc7fb67674937208abe4cd75d652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a43bcf9c74648466d1e561203a39d87"><td class="memItemLeft" align="right" valign="top"><a id="a1a43bcf9c74648466d1e561203a39d87"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a1a43bcf9c74648466d1e561203a39d87">dg_timer_file_</a></td></tr>
<tr class="memdesc:a1a43bcf9c74648466d1e561203a39d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_timer_file_ this is the path to the file that will contain the time of the dynamic graph loop. <br /></td></tr>
<tr class="separator:a1a43bcf9c74648466d1e561203a39d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd29dbd358b8c02805f4df970e75936"><td class="memItemLeft" align="right" valign="top"><a id="a2bd29dbd358b8c02805f4df970e75936"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a2bd29dbd358b8c02805f4df970e75936">hwc_active_timer_file_</a></td></tr>
<tr class="memdesc:a2bd29dbd358b8c02805f4df970e75936"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_active_timer_file_ this is the path to the file that will contain the computation time of each active period of the hardware communication loop. <br /></td></tr>
<tr class="separator:a2bd29dbd358b8c02805f4df970e75936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db6275d202963665a35c5eb2e68088d"><td class="memItemLeft" align="right" valign="top"><a id="a5db6275d202963665a35c5eb2e68088d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a5db6275d202963665a35c5eb2e68088d">hwc_sleep_timer_file_</a></td></tr>
<tr class="memdesc:a5db6275d202963665a35c5eb2e68088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_sleep_timer_file_ this is the path to the file that will contain the sleeping time of the hardware communication loop. <br /></td></tr>
<tr class="separator:a5db6275d202963665a35c5eb2e68088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f97c9eebbecee1af314e74fe22d8ed"><td class="memItemLeft" align="right" valign="top"><a id="a84f97c9eebbecee1af314e74fe22d8ed"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a84f97c9eebbecee1af314e74fe22d8ed">hwc_timer_file_</a></td></tr>
<tr class="memdesc:a84f97c9eebbecee1af314e74fe22d8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_timer_file_ this is the path to the file that will contain the computation time of each of the hardware communication complete execution. <br /></td></tr>
<tr class="separator:a84f97c9eebbecee1af314e74fe22d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace11054bf618c29e4fda9a77905e8ff0"><td class="memItemLeft" align="right" valign="top"><a id="ace11054bf618c29e4fda9a77905e8ff0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ace11054bf618c29e4fda9a77905e8ff0">log_dir_</a></td></tr>
<tr class="memdesc:ace11054bf618c29e4fda9a77905e8ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">log_folder_ is the folder where all the data of the current experiment will be saved. <br /></td></tr>
<tr class="separator:ace11054bf618c29e4fda9a77905e8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3be4a8d0596390bc5dd055321a7df55"><td class="memItemLeft" align="right" valign="top"><a id="ac3be4a8d0596390bc5dd055321a7df55"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ac3be4a8d0596390bc5dd055321a7df55">python_log_file_</a></td></tr>
<tr class="memdesc:ac3be4a8d0596390bc5dd055321a7df55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file will contain the python interpreter output. <br /></td></tr>
<tr class="separator:ac3be4a8d0596390bc5dd055321a7df55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f413dd58d270daf3c03f08d4a2c51cb"><td class="memItemLeft" align="right" valign="top"><a id="a1f413dd58d270daf3c03f08d4a2c51cb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a1f413dd58d270daf3c03f08d4a2c51cb">app_dir_</a></td></tr>
<tr class="memdesc:a1f413dd58d270daf3c03f08d4a2c51cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the application directory in the home directory. <br /></td></tr>
<tr class="separator:a1f413dd58d270daf3c03f08d4a2c51cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f206d87817177e389df0c27f1954f51"><td class="memItemLeft" align="right" valign="top"><a id="a8f206d87817177e389df0c27f1954f51"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a8f206d87817177e389df0c27f1954f51">dg_active_timer_</a></td></tr>
<tr class="memdesc:a8f206d87817177e389df0c27f1954f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_active_timer_ is the timer measuring the computation time of the dynamic graph loop. <br /></td></tr>
<tr class="separator:a8f206d87817177e389df0c27f1954f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0eb495ce07011796c58f54cef16ef5"><td class="memItemLeft" align="right" valign="top"><a id="a8e0eb495ce07011796c58f54cef16ef5"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a8e0eb495ce07011796c58f54cef16ef5">dg_sleep_timer_</a></td></tr>
<tr class="memdesc:a8e0eb495ce07011796c58f54cef16ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_sleep_timer_ is the timer measuring the time during which the dynamic graph loop sleeps. <br /></td></tr>
<tr class="separator:a8e0eb495ce07011796c58f54cef16ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73984087ad28fe492905eda861783bd"><td class="memItemLeft" align="right" valign="top"><a id="ae73984087ad28fe492905eda861783bd"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ae73984087ad28fe492905eda861783bd">dg_timer_</a></td></tr>
<tr class="memdesc:ae73984087ad28fe492905eda861783bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">dg_timer_ is the timer measuring the duration time of the dynamic graph loop. <br /></td></tr>
<tr class="separator:ae73984087ad28fe492905eda861783bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c823bac22d756fc649f911fc1c29b"><td class="memItemLeft" align="right" valign="top"><a id="afe6c823bac22d756fc649f911fc1c29b"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#afe6c823bac22d756fc649f911fc1c29b">hwc_active_timer_</a></td></tr>
<tr class="memdesc:afe6c823bac22d756fc649f911fc1c29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_active_timer is measuring the active time of the hardware communication loop <br /></td></tr>
<tr class="separator:afe6c823bac22d756fc649f911fc1c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb402f9e2eaa8dfad090f6c9845f6c"><td class="memItemLeft" align="right" valign="top"><a id="a89eb402f9e2eaa8dfad090f6c9845f6c"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a89eb402f9e2eaa8dfad090f6c9845f6c">hwc_sleep_timer_</a></td></tr>
<tr class="memdesc:a89eb402f9e2eaa8dfad090f6c9845f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_sleep_timer is measuring the sleeping time of the hardware communication loop <br /></td></tr>
<tr class="separator:a89eb402f9e2eaa8dfad090f6c9845f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ef83c411e5439204fa05b28f8e2794"><td class="memItemLeft" align="right" valign="top"><a id="a08ef83c411e5439204fa05b28f8e2794"></a>
real_time_tools::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a08ef83c411e5439204fa05b28f8e2794">hwc_timer_</a></td></tr>
<tr class="memdesc:a08ef83c411e5439204fa05b28f8e2794"><td class="mdescLeft">&#160;</td><td class="mdescRight">hwc_timer is measuring the time of the hardware communication loop <br /></td></tr>
<tr class="separator:a08ef83c411e5439204fa05b28f8e2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844d4f6c15668884b37111003c8a25a0"><td class="memItemLeft" align="right" valign="top"><a id="a844d4f6c15668884b37111003c8a25a0"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a844d4f6c15668884b37111003c8a25a0">memory_buffer_timers_</a></td></tr>
<tr class="memdesc:a844d4f6c15668884b37111003c8a25a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory_buffer_timers_ is the size of the memory buffers for the real_time_tools timers. <br /></td></tr>
<tr class="separator:a844d4f6c15668884b37111003c8a25a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4716c8ec6194816235e6199863f46f9"><td class="memItemLeft" align="right" valign="top"><a id="ab4716c8ec6194816235e6199863f46f9"></a>
real_time_tools::Spinner&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ab4716c8ec6194816235e6199863f46f9">hwc_spinner_</a></td></tr>
<tr class="memdesc:ab4716c8ec6194816235e6199863f46f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to time the real time thread for the hardware communication. <br /></td></tr>
<tr class="separator:ab4716c8ec6194816235e6199863f46f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa11023c1dd272d7bbabdcccc511b6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#af5aa11023c1dd272d7bbabdcccc511b6">hwc_predicted_sleeping_time_</a></td></tr>
<tr class="memdesc:af5aa11023c1dd272d7bbabdcccc511b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This corresponds to the predicted sleeping time for the hardware communication process.  <a href="#af5aa11023c1dd272d7bbabdcccc511b6">More...</a><br /></td></tr>
<tr class="separator:af5aa11023c1dd272d7bbabdcccc511b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb979a3e9235ef71a61579a6a6ad1200"><td class="memItemLeft" align="right" valign="top"><a id="abb979a3e9235ef71a61579a6a6ad1200"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#abb979a3e9235ef71a61579a6a6ad1200">maximum_time_for_user_cmd_</a></td></tr>
<tr class="memdesc:abb979a3e9235ef71a61579a6a6ad1200"><td class="mdescLeft">&#160;</td><td class="mdescRight">This the duration during which a user command can be executed. <br /></td></tr>
<tr class="separator:abb979a3e9235ef71a61579a6a6ad1200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a07b4003cc1a0021e675847cc57ef5c"><td class="memItemLeft" align="right" valign="top"><a id="a1a07b4003cc1a0021e675847cc57ef5c"></a>
std::deque&lt; std::function&lt; void(void)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a1a07b4003cc1a0021e675847cc57ef5c">user_commands_</a></td></tr>
<tr class="memdesc:a1a07b4003cc1a0021e675847cc57ef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the list of the user commands. <br /></td></tr>
<tr class="separator:a1a07b4003cc1a0021e675847cc57ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb35bc44f331db3570c09b75b49cd15"><td class="memItemLeft" align="right" valign="top">std::deque&lt; ros::ServiceServer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a0fb35bc44f331db3570c09b75b49cd15">ros_user_commands_</a></td></tr>
<tr class="memdesc:a0fb35bc44f331db3570c09b75b49cd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute shared with the daughter class.  <a href="#a0fb35bc44f331db3570c09b75b49cd15">More...</a><br /></td></tr>
<tr class="separator:a0fb35bc44f331db3570c09b75b49cd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0f1323534e9e1b17f3b1cc23f0c7f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a2c0f1323534e9e1b17f3b1cc23f0c7f1">control_period_sec_</a></td></tr>
<tr class="memdesc:a2c0f1323534e9e1b17f3b1cc23f0c7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">control_period_sec_ this is the control period in Seconds (S.I.  <a href="#a2c0f1323534e9e1b17f3b1cc23f0c7f1">More...</a><br /></td></tr>
<tr class="separator:a2c0f1323534e9e1b17f3b1cc23f0c7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3773835c294117a500af96d272921ea"><td class="memItemLeft" align="right" valign="top"><a id="ad3773835c294117a500af96d272921ea"></a>
YAML::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#ad3773835c294117a500af96d272921ea">params_</a></td></tr>
<tr class="memdesc:ad3773835c294117a500af96d272921ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">params_ is the pool of parameters in a yaml tree <br /></td></tr>
<tr class="separator:ad3773835c294117a500af96d272921ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d9df75790d22b3258e1bd42fd537d"><td class="memItemLeft" align="right" valign="top"><a id="a1b7d9df75790d22b3258e1bd42fd537d"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>hwc_mutex_</b></td></tr>
<tr class="separator:a1b7d9df75790d22b3258e1bd42fd537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a664c7a3810c13a33057ae060281966b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a664c7a3810c13a33057ae060281966b1">start_dynamic_graph</a> (std_srvs::Empty::Request &amp;, std_srvs::Empty::Response &amp;)</td></tr>
<tr class="memdesc:a664c7a3810c13a33057ae060281966b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method NOT inherited.  <a href="#a664c7a3810c13a33057ae060281966b1">More...</a><br /></td></tr>
<tr class="separator:a664c7a3810c13a33057ae060281966b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06740416640f3464edbbb57ee759b8fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a06740416640f3464edbbb57ee759b8fb">stop_dynamic_graph</a> (std_srvs::Empty::Request &amp;, std_srvs::Empty::Response &amp;)</td></tr>
<tr class="memdesc:a06740416640f3464edbbb57ee759b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop_dg is the callback method of the ROS service stop dynamic graph  <a href="#a06740416640f3464edbbb57ee759b8fb">More...</a><br /></td></tr>
<tr class="separator:a06740416640f3464edbbb57ee759b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa396c4c91c076a103e2d5cb6c5606a7d"><td class="memItemLeft" align="right" valign="top"><a id="aa396c4c91c076a103e2d5cb6c5606a7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#aa396c4c91c076a103e2d5cb6c5606a7d">start_ros_service</a> (ros::NodeHandle &amp;ros_node_handle)</td></tr>
<tr class="memdesc:aa396c4c91c076a103e2d5cb6c5606a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">start_ros_service is the method that advertise the different ros services. <br /></td></tr>
<tr class="separator:aa396c4c91c076a103e2d5cb6c5606a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f9e755719ec8fde8f145a67b518333"><td class="memItemLeft" align="right" valign="top"><a id="a72f9e755719ec8fde8f145a67b518333"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a72f9e755719ec8fde8f145a67b518333">dynamic_graph_real_time_loop</a> ()</td></tr>
<tr class="memdesc:a72f9e755719ec8fde8f145a67b518333"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic_graph_real_time_loop is the method used to execute the dynamic graph. <br /></td></tr>
<tr class="separator:a72f9e755719ec8fde8f145a67b518333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea4183f1a4bd2d450ffb4a0a22b4242"><td class="memItemLeft" align="right" valign="top"><a id="a4ea4183f1a4bd2d450ffb4a0a22b4242"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a4ea4183f1a4bd2d450ffb4a0a22b4242">hardware_communication_real_time_loop</a> ()</td></tr>
<tr class="memdesc:a4ea4183f1a4bd2d450ffb4a0a22b4242"><td class="mdescLeft">&#160;</td><td class="mdescRight">hardware_communication_real_time_loop is the method that communicate with the hardware and send the commands (torque, position, current, ...) <br /></td></tr>
<tr class="separator:a4ea4183f1a4bd2d450ffb4a0a22b4242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3adb88c5913b21b51c1f7bfab6d0f3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#adf3adb88c5913b21b51c1f7bfab6d0f3">single_process_real_time_loop</a> ()</td></tr>
<tr class="memdesc:adf3adb88c5913b21b51c1f7bfab6d0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_process_real_time_loop is the method that performs the control but in one single process.  <a href="#adf3adb88c5913b21b51c1f7bfab6d0f3">More...</a><br /></td></tr>
<tr class="separator:adf3adb88c5913b21b51c1f7bfab6d0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a7d289a916922f69796b0042f64de1499"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a7d289a916922f69796b0042f64de1499">dynamic_graph_real_time_loop_helper</a> (void *context)</td></tr>
<tr class="memdesc:a7d289a916922f69796b0042f64de1499"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create.  <a href="#a7d289a916922f69796b0042f64de1499">More...</a><br /></td></tr>
<tr class="separator:a7d289a916922f69796b0042f64de1499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771ad93758759932899273c5f01975fc"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a771ad93758759932899273c5f01975fc">hardware_communication_real_time_loop_helper</a> (void *context)</td></tr>
<tr class="memdesc:a771ad93758759932899273c5f01975fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create.  <a href="#a771ad93758759932899273c5f01975fc">More...</a><br /></td></tr>
<tr class="separator:a771ad93758759932899273c5f01975fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f8990655ae8464acb3bd4c56a74c2"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#af28f8990655ae8464acb3bd4c56a74c2">single_process_real_time_loop_helper</a> (void *context)</td></tr>
<tr class="memdesc:af28f8990655ae8464acb3bd4c56a74c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create.  <a href="#af28f8990655ae8464acb3bd4c56a74c2">More...</a><br /></td></tr>
<tr class="separator:af28f8990655ae8464acb3bd4c56a74c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class has for purpose to manage the different processes during run time. </p>
<p>The main tasks are:</p><ul>
<li>[1] Creates the Dynamic Graph device, the python interpreter, and the Drivers</li>
<li>[2] Ask the python interpreter to advertise its ROS services</li>
<li>[3] Ask the drivers to initialize the communication with the hardware</li>
<li>[4] Loads a yaml/urdf config file.</li>
<li>[5] Advertise the ROS services start/stop dynamic graph</li>
<li>[6] Wait for the ROS service start dynamic graph to be called</li>
<li>[7] Spawn the first real time process that executes the following:<ul>
<li>[7.1] gets the sensor data using Drivers and saves them in the shared std::map sensors</li>
<li>[7.2] reads the control values in the shared std::map commands and send them to the motors via the Drivers</li>
</ul>
</li>
<li>[8] Spawn the second real time process that executes the following:<ul>
<li>[8.1] passes the std::map sensors to the <a class="el" href="classdynamic__graph_1_1Device.html">Device</a>, which copies the data to its output signals</li>
<li>[8.2] gets the control values from the <a class="el" href="classdynamic__graph_1_1Device.html">Device</a> (which triggers the evaluation of the dynamic graph) and copies them into the shared std::map commands. In this class we heavily depend on std::unique pointers in order to initialize the DynamicGraph process and the hardware communication process independently. </li>
</ul>
</li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simple_dgm_8hpp-example.html#_a0">simple_dgm.hpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a72146c4ddd173869a512e9f174ad48df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72146c4ddd173869a512e9f174ad48df">&#9670;&nbsp;</a></span>add_user_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::add_user_command </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method inherited. </p>
<p>This method allow to simply add a user command </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simple_dgm_8hpp-example.html#a11">simple_dgm.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="a90bb14375da3d2aaaeafb356b6ca54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bb14375da3d2aaaeafb356b6ca54f7">&#9670;&nbsp;</a></span>device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__graph_1_1Device.html">Device</a>&amp; dynamic_graph::DynamicGraphManager::device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>device is a getter method on the <a class="el" href="classdynamic__graph_1_1Device.html">Device</a> internal pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the device. </dd></dl>

</div>
</div>
<a id="a7d289a916922f69796b0042f64de1499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d289a916922f69796b0042f64de1499">&#9670;&nbsp;</a></span>dynamic_graph_real_time_loop_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* dynamic_graph::DynamicGraphManager::dynamic_graph_real_time_loop_helper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>is the <a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html" title="This class has for purpose to manage the different processes during run time. ">DynamicGraphManager</a> that spawned the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing interesting for us. </dd></dl>

</div>
</div>
<a id="a7bddce83d5185433041ad27610b85b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bddce83d5185433041ad27610b85b3a">&#9670;&nbsp;</a></span>get_sensors_to_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dynamic_graph::DynamicGraphManager::get_sensors_to_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_sensors_to_map is the fonction that get the motor command from a map and that uses the drivers to send these command to the robot. </p>
<p>Each robot must have a different implementation of this function. WARNING, this function needs to be overloaded using the actual drivers of the robot. </p>

<p>Reimplemented in <a class="el" href="classdynamic__graph__manager_1_1SimpleDGM.html#aa92cd33a31c934835252f834bab7b9f4">dynamic_graph_manager::SimpleDGM</a>.</p>

</div>
</div>
<a id="a771ad93758759932899273c5f01975fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771ad93758759932899273c5f01975fc">&#9670;&nbsp;</a></span>hardware_communication_real_time_loop_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* dynamic_graph::DynamicGraphManager::hardware_communication_real_time_loop_helper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>is the <a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html" title="This class has for purpose to manage the different processes during run time. ">DynamicGraphManager</a> that spawned the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing interesting for us. </dd></dl>

</div>
</div>
<a id="ab980a2384c817ab5f59e712a54b2261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab980a2384c817ab5f59e712a54b2261a">&#9670;&nbsp;</a></span>has_dynamic_graph_process_died()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DynamicGraphManager::has_dynamic_graph_process_died </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>has_dynamic_graph_process_died check if the process of the DynamicGraph has died or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the DynamicGraph process died. </dd></dl>

</div>
</div>
<a id="ae3927887762c52c7bf50ab5a565c3077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3927887762c52c7bf50ab5a565c3077">&#9670;&nbsp;</a></span>initialize_hardware_communication_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dynamic_graph::DynamicGraphManager::initialize_hardware_communication_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize_hardware_communication_process instanciate all variables related to the hardware communication. </p>
<p>In addition it spawns the real time thread. WARNING, this function needs to be overloaded using the actual drivers of the robot. </p>

<p>Reimplemented in <a class="el" href="classdynamic__graph__manager_1_1SimpleDGM.html#a5d771fc5a9ae6dd524a658d50fbee5d3">dynamic_graph_manager::SimpleDGM</a>.</p>

</div>
</div>
<a id="ab929d21277e5d2fba726b8ae422c27a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab929d21277e5d2fba726b8ae422c27a8">&#9670;&nbsp;</a></span>is_dynamic_graph_stopped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_graph::DynamicGraphManager::is_dynamic_graph_stopped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the status of the dynamic graph (is running or not) </p>
<dl class="section return"><dt>Returns</dt><dd>the flag is_dynamic_graph_stopped_ value </dd></dl>

</div>
</div>
<a id="afcc53ebec6e5f2057c23a05894715125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc53ebec6e5f2057c23a05894715125">&#9670;&nbsp;</a></span>is_hardware_communication_stopped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_graph::DynamicGraphManager::is_hardware_communication_stopped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the status of the hardware communication (is running or not). </p>
<dl class="section return"><dt>Returns</dt><dd>the flags is_dynamic_graph_stopped_ value. </dd></dl>

</div>
</div>
<a id="aea29e8dc351e0a50a8d2803d854d238d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea29e8dc351e0a50a8d2803d854d238d">&#9670;&nbsp;</a></span>is_in_safety_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dynamic_graph::DynamicGraphManager::is_in_safety_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_in_safety_mode check if the dynamic graph is still alive and sending commands at a descent frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is a problem </dd></dl>

<p>Reimplemented in <a class="el" href="classdynamic__graph__manager_1_1SimpleDGM.html#a5fe81f9feb5d982761d7a427aa31e7b4">dynamic_graph_manager::SimpleDGM</a>.</p>

</div>
</div>
<a id="a9c11927e0b76e91fabc4b34ea7fb85bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c11927e0b76e91fabc4b34ea7fb85bc">&#9670;&nbsp;</a></span>pid_dynamic_graph_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t dynamic_graph::DynamicGraphManager::pid_dynamic_graph_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pid_dynamic_graph_process is an accessor on the pid of the process </p>
<dl class="section return"><dt>Returns</dt><dd>the pid of the dynamic graph process </dd></dl>

</div>
</div>
<a id="ac1abb11591e037e203329e900c89f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1abb11591e037e203329e900c89f4f5">&#9670;&nbsp;</a></span>pid_hardware_communication_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t dynamic_graph::DynamicGraphManager::pid_hardware_communication_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pid_hardware_communication_process is an accessor on the pid of the process </p>
<dl class="section return"><dt>Returns</dt><dd>the pid of the dynamic graph process </dd></dl>

</div>
</div>
<a id="a93272fcbb3793dfc92422186022ecf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93272fcbb3793dfc92422186022ecf72">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a93272fcbb3793dfc92422186022ecf72" title="run() splits the process in the dynamic_graph process and the hadware_communication process...">run()</a> splits the process in the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> process and the hadware_communication process. </p>
<p>It initialize them and run them. WARNING this a NONE blocking function. One can spin endlessly using the ROS: ros::waitForShutdown(), for example. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="main_8cpp-example.html#a2">main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a8e23eb4ce0acaef397bf84a770b9f015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e23eb4ce0acaef397bf84a770b9f015">&#9670;&nbsp;</a></span>run_dynamic_graph_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::run_dynamic_graph_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run_dynamic_graph_process spawns the real time thread and becomes a ros spinner (thread in charge of the ros::service callbacks). </p>
<p>This function is virtual has it might differ from os to os. </p>

</div>
</div>
<a id="a81e7cb10262383030c10156730d39ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e7cb10262383030c10156730d39ce8">&#9670;&nbsp;</a></span>run_hardware_communication_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::run_hardware_communication_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run_hardware_communication_process spawns the real time thread. </p>
<p>WARNING this function is not blocking. Function to block are available like ros::waitForShutdown() for example. This function is virtual has it might differ from os to os. </p>

</div>
</div>
<a id="a56acce72235fe0786830ec19a3439309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56acce72235fe0786830ec19a3439309">&#9670;&nbsp;</a></span>run_python_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::run_python_command </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>run_python_command </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>is the logging file to log the entry </td></tr>
    <tr><td class="paramname">command</td><td>is the python command itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13f5aef302173293a0c162c28505ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13f5aef302173293a0c162c28505ef8">&#9670;&nbsp;</a></span>run_single_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::run_single_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>run_single_process spawns the real time thread. </p>
<p>WARNING this function is not blocking. Function to block are available like ros::waitForShutdown() for example. This function is virtual has it might differ from os to os. </p>

</div>
</div>
<a id="a506e6f37ac7205efaf0efe4202cde897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506e6f37ac7205efaf0efe4202cde897">&#9670;&nbsp;</a></span>set_motor_controls_from_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dynamic_graph::DynamicGraphManager::set_motor_controls_from_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set_motor_controls_from_map is the fonction that get the motor command from a map and that uses the drivers to send these command to the robot. </p>
<p>Each robot must have a different implementation of this function. WARNING, this function needs to be overloaded using the actual drivers of the robot. </p>

<p>Reimplemented in <a class="el" href="classdynamic__graph__manager_1_1SimpleDGM.html#ad38ccd35cc0c409a0aaefa8565634109">dynamic_graph_manager::SimpleDGM</a>.</p>

</div>
</div>
<a id="adf3adb88c5913b21b51c1f7bfab6d0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3adb88c5913b21b51c1f7bfab6d0f3">&#9670;&nbsp;</a></span>single_process_real_time_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * DynamicGraphManager::single_process_real_time_loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_process_real_time_loop is the method that performs the control but in one single process. </p>
<p>(torque, position, current, ...) </p>

</div>
</div>
<a id="af28f8990655ae8464acb3bd4c56a74c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28f8990655ae8464acb3bd4c56a74c2">&#9670;&nbsp;</a></span>single_process_real_time_loop_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* dynamic_graph::DynamicGraphManager::single_process_real_time_loop_helper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dynamic_graph_real_time_loop_helper is a static member allowing to use the posix pthread_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>is the <a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html" title="This class has for purpose to manage the different processes during run time. ">DynamicGraphManager</a> that spawned the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing interesting for us. </dd></dl>

</div>
</div>
<a id="a1bfd2b965dde19d12d63f5928a4f670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfd2b965dde19d12d63f5928a4f670c">&#9670;&nbsp;</a></span>start_dynamic_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamic_graph::DynamicGraphManager::start_dynamic_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start_dynamic_graph start the DynamicGraph. </p>
<p>;) </p>

</div>
</div>
<a id="a664c7a3810c13a33057ae060281966b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664c7a3810c13a33057ae060281966b1">&#9670;&nbsp;</a></span>start_dynamic_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_graph::DynamicGraphManager::start_dynamic_graph </td>
          <td>(</td>
          <td class="paramtype">std_srvs::Empty::Request &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std_srvs::Empty::Response &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method NOT inherited. </p>
<p>start_dg is the callback method of the ROS service start dynamic graph. </p><dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="a234bef10fea6e3f9beb1580491127660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234bef10fea6e3f9beb1580491127660">&#9670;&nbsp;</a></span>start_hardware_communication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamic_graph::DynamicGraphManager::start_hardware_communication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start_hardware_communication starts the hardware communication. </p>
<p>;) </p>

</div>
</div>
<a id="ad3c7c528ef283fbfb803377c8c631b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c7c528ef283fbfb803377c8c631b4c">&#9670;&nbsp;</a></span>stop_dynamic_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamic_graph::DynamicGraphManager::stop_dynamic_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stop_dynamic_graph stop the DynamicGraph. </p>
<p>;) </p>

</div>
</div>
<a id="a06740416640f3464edbbb57ee759b8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06740416640f3464edbbb57ee759b8fb">&#9670;&nbsp;</a></span>stop_dynamic_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_graph::DynamicGraphManager::stop_dynamic_graph </td>
          <td>(</td>
          <td class="paramtype">std_srvs::Empty::Request &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std_srvs::Empty::Response &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stop_dg is the callback method of the ROS service stop dynamic graph </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aabf11778fb69e5203d38c8093de60bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf11778fb69e5203d38c8093de60bab">&#9670;&nbsp;</a></span>stop_hardware_communication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamic_graph::DynamicGraphManager::stop_hardware_communication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stop_hardware_communication stops the hardware communication. </p>
<p>;) </p>

</div>
</div>
<a id="a83a98e169cd587d101bba69bb799e408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a98e169cd587d101bba69bb799e408">&#9670;&nbsp;</a></span>wait_stop_hardware_communication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicGraphManager::wait_stop_hardware_communication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wait_stop_hardware_communication put the current thread to sleep until the user stop the hardware communication. </p>
<p>&amp;&amp; hw_com_ros_node.ok() </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2c0f1323534e9e1b17f3b1cc23f0c7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0f1323534e9e1b17f3b1cc23f0c7f1">&#9670;&nbsp;</a></span>control_period_sec_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dynamic_graph::DynamicGraphManager::control_period_sec_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>control_period_sec_ this is the control period in Seconds (S.I. </p>
<p>units) for computation. </p>

</div>
</div>
<a id="a415f24927dbe9dfd0ee4a6462428bd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415f24927dbe9dfd0ee4a6462428bd48">&#9670;&nbsp;</a></span>hw_com_ros_node_name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string DynamicGraphManager::hw_com_ros_node_name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;hardware_communication&quot;</span></div></div><!-- fragment -->
<p>hw_com_ros_node_name_ this is the ros node name of the harware communication process </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simple_dgm_8hpp-example.html#a5">simple_dgm.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="af5aa11023c1dd272d7bbabdcccc511b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa11023c1dd272d7bbabdcccc511b6">&#9670;&nbsp;</a></span>hwc_predicted_sleeping_time_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double dynamic_graph::DynamicGraphManager::hwc_predicted_sleeping_time_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This corresponds to the predicted sleeping time for the hardware communication process. </p>
<p>If this time is bigger than a certain threshold then user commands to the hardware can be sent. </p>

</div>
</div>
<a id="a87baafbaadf396a7663da653dc5da106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87baafbaadf396a7663da653dc5da106">&#9670;&nbsp;</a></span>is_dynamic_graph_stopped_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; dynamic_graph::DynamicGraphManager::is_dynamic_graph_stopped_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_dynamic_graph_stopped_ is the flag reflecting the state of the dynamic graph. </p>
<ul>
<li>TRUE the Dynamic Graph is NOT running.</li>
<li>FALSE the Dynamic Graph IS running. The type "atomic" is here to make sure that this variable is thread safe </li>
</ul>

</div>
</div>
<a id="ab1a2bc0a8f04126638056f430297097e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a2bc0a8f04126638056f430297097e">&#9670;&nbsp;</a></span>is_hardware_communication_stopped_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; dynamic_graph::DynamicGraphManager::is_hardware_communication_stopped_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_hardware_communication_stopped_ is the flag reflecting the state of the hardware communication thread. </p>
<ul>
<li>TRUE the hardware communication is NOT running.</li>
<li>FALSE the hardware communication IS running. The type "atomic" is here to make sure that this variable is thread safe </li>
</ul>

</div>
</div>
<a id="a03eabd2f08990a1dcc1caa652b701020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03eabd2f08990a1dcc1caa652b701020">&#9670;&nbsp;</a></span>motor_controls_map_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> dynamic_graph::DynamicGraphManager::motor_controls_map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>motor_controls_map_ is a map of dynamicgraph::Vector. </p>
<p>They represent all the controls to be sent to the robot. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simple_dgm_8hpp-example.html#a15">simple_dgm.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="a056de4d7a49496b2b0812d96d93370d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056de4d7a49496b2b0812d96d93370d9">&#9670;&nbsp;</a></span>motor_controls_map_name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string DynamicGraphManager::motor_controls_map_name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;motor_controls_map&quot;</span></div></div><!-- fragment -->
<p>motor_controls_map_name is the name of the motor controls map inside the shared memory segment </p>

</div>
</div>
<a id="aa8aa645099e7e9cce426381e38b5027d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8aa645099e7e9cce426381e38b5027d">&#9670;&nbsp;</a></span>pid_dynamic_graph_process_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t dynamic_graph::DynamicGraphManager::pid_dynamic_graph_process_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pid_dynamic_graph_process_ is the pid of the DynamicGraph process. </p>
<p>It is initialized to 0 and set during the <a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a93272fcbb3793dfc92422186022ecf72" title="run() splits the process in the dynamic_graph process and the hadware_communication process...">DynamicGraphManager::run</a> method </p>

</div>
</div>
<a id="a02232cdc5cabca34d07dada6ced38532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02232cdc5cabca34d07dada6ced38532">&#9670;&nbsp;</a></span>pid_hardware_communication_process_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t dynamic_graph::DynamicGraphManager::pid_hardware_communication_process_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pid_hardware_communication_process_ is the pid of the hardware communication process. </p>
<p>It is initialized to 0 and set during the <a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html#a93272fcbb3793dfc92422186022ecf72" title="run() splits the process in the dynamic_graph process and the hadware_communication process...">DynamicGraphManager::run</a> method </p>

</div>
</div>
<a id="adb99ba3a7a5e677b30531a69bcc922ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb99ba3a7a5e677b30531a69bcc922ec">&#9670;&nbsp;</a></span>ros_service_start_dg_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ros::ServiceServer dynamic_graph::DynamicGraphManager::ros_service_start_dg_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ros_service_start_dg_ allows to start the dynamic graph on call. </p>
<p>It simply sets a flags that is used to wait the user call. Only used in the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> process. </p>

</div>
</div>
<a id="adf973b6da4e4fe14cae262ba94ebb191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf973b6da4e4fe14cae262ba94ebb191">&#9670;&nbsp;</a></span>ros_service_stop_dg_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ros::ServiceServer dynamic_graph::DynamicGraphManager::ros_service_stop_dg_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ros_service_stop_dg_ allows to stop the dynamic graph on call. </p>
<p>It simply sets a flags that stop the main real time the control loop. Only used in the <a class="el" href="namespacedynamic__graph.html" title="this is this package namespace in order to avoid naming conflict ">dynamic_graph</a> process. </p>

</div>
</div>
<a id="a0fb35bc44f331db3570c09b75b49cd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb35bc44f331db3570c09b75b49cd15">&#9670;&nbsp;</a></span>ros_user_commands_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;ros::ServiceServer&gt; dynamic_graph::DynamicGraphManager::ros_user_commands_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute shared with the daughter class. </p>
<p>This is the list of the ros user commands. The class inheriting from this one can add services for the hardware communication process. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="simple_dgm_8hpp-example.html#a6">simple_dgm.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="a896bf6cb22d2d88a5a6a307a2e44608e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896bf6cb22d2d88a5a6a307a2e44608e">&#9670;&nbsp;</a></span>sensors_map_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedynamic__graph.html#abd184187f3bc15df5e227d866529e4a7">VectorDGMap</a> dynamic_graph::DynamicGraphManager::sensors_map_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sensors_map_ is a map of dynamicgraph::Vector. </p>
<p>They represent all the sensors data measured on the robot. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/dynamic_graph_manager/<a class="el" href="dynamic__graph__manager_8hh_source.html">dynamic_graph_manager.hh</a></li>
<li>src/<a class="el" href="dynamic__graph__manager_8cpp.html">dynamic_graph_manager.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedynamic__graph.html">dynamic_graph</a></li><li class="navelem"><a class="el" href="classdynamic__graph_1_1DynamicGraphManager.html">DynamicGraphManager</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
