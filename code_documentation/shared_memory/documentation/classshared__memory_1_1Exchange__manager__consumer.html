<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>shared_memory: shared_memory::Exchange_manager_consumer&lt; Serializable, QUEUE_SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">shared_memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classshared__memory_1_1Exchange__manager__consumer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classshared__memory_1_1Exchange__manager__consumer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">shared_memory::Exchange_manager_consumer&lt; Serializable, QUEUE_SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15b2b91e57fb8c9c60ec354274edf20d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#a15b2b91e57fb8c9c60ec354274edf20d">Exchange_manager_consumer</a> (std::string segment_id, std::string object_id, bool leading, bool autolock=true)</td></tr>
<tr class="memdesc:a15b2b91e57fb8c9c60ec354274edf20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exchange_manager_consumer reads from the shared memory serialized items produced by an instance of exchange_manager_producer (which should use the same segment_id and object_id), possibly running in a separate process.  <a href="#a15b2b91e57fb8c9c60ec354274edf20d">More...</a><br /></td></tr>
<tr class="separator:a15b2b91e57fb8c9c60ec354274edf20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec59bb41c9de78eb891ea70efe6b8c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#a1ec59bb41c9de78eb891ea70efe6b8c2">lock</a> ()</td></tr>
<tr class="memdesc:a1ec59bb41c9de78eb891ea70efe6b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock the mutex required for writting in the shared memory without any collision with any producer.  <a href="#a1ec59bb41c9de78eb891ea70efe6b8c2">More...</a><br /></td></tr>
<tr class="separator:a1ec59bb41c9de78eb891ea70efe6b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf053702ec1ef8455fc10e70144f6923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#aaf053702ec1ef8455fc10e70144f6923">unlock</a> ()</td></tr>
<tr class="memdesc:aaf053702ec1ef8455fc10e70144f6923"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock the mutex for writting in the shared memory without any collision with any producer.  <a href="#aaf053702ec1ef8455fc10e70144f6923">More...</a><br /></td></tr>
<tr class="separator:aaf053702ec1ef8455fc10e70144f6923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e006de034b55e328784d3eacfb1772"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#ae3e006de034b55e328784d3eacfb1772">consume</a> (<a class="el" href="classSerializable.html">Serializable</a> &amp;serializable)</td></tr>
<tr class="memdesc:ae3e006de034b55e328784d3eacfb1772"><td class="mdescLeft">&#160;</td><td class="mdescRight">read from the underlying shared memory a serialized object (set by a producer).  <a href="#ae3e006de034b55e328784d3eacfb1772">More...</a><br /></td></tr>
<tr class="separator:ae3e006de034b55e328784d3eacfb1772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a894d796387d297f848d18d8d55df5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#af1a894d796387d297f848d18d8d55df5">ready_to_consume</a> ()</td></tr>
<tr class="memdesc:af1a894d796387d297f848d18d8d55df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a producer is also running.  <a href="#af1a894d796387d297f848d18d8d55df5">More...</a><br /></td></tr>
<tr class="separator:af1a894d796387d297f848d18d8d55df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e62220c9b50327130cb95683d22b0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#a5e62220c9b50327130cb95683d22b0dc">purge_feedbacks</a> ()</td></tr>
<tr class="memdesc:a5e62220c9b50327130cb95683d22b0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed).  <a href="#a5e62220c9b50327130cb95683d22b0dc">More...</a><br /></td></tr>
<tr class="separator:a5e62220c9b50327130cb95683d22b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8651cff750b5cb2ceae97a97b2c7f2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html#ab8651cff750b5cb2ceae97a97b2c7f2d">nb_char_read</a> ()</td></tr>
<tr class="memdesc:ab8651cff750b5cb2ceae97a97b2c7f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of char that have been read from the exchange queue.  <a href="#ab8651cff750b5cb2ceae97a97b2c7f2d">More...</a><br /></td></tr>
<tr class="separator:ab8651cff750b5cb2ceae97a97b2c7f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4f6ecbd5c18915923048e1c9067112"><td class="memItemLeft" align="right" valign="top"><a id="a5c4f6ecbd5c18915923048e1c9067112"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_producer_queue_empty</b> () const</td></tr>
<tr class="separator:a5c4f6ecbd5c18915923048e1c9067112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f853781c308a063f28cbfc6ecc90739"><td class="memItemLeft" align="right" valign="top"><a id="a1f853781c308a063f28cbfc6ecc90739"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_consumer_queue_empty</b> () const</td></tr>
<tr class="separator:a1f853781c308a063f28cbfc6ecc90739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5aeebd5f2857f73c91fe3212d274909e"><td class="memItemLeft" align="right" valign="top"><a id="a5aeebd5f2857f73c91fe3212d274909e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>clean_mutex</b> (std::string segment_id)</td></tr>
<tr class="separator:a5aeebd5f2857f73c91fe3212d274909e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828a56d15a0f68edd8e3b395c41b0c0c"><td class="memItemLeft" align="right" valign="top"><a id="a828a56d15a0f68edd8e3b395c41b0c0c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>clean_memory</b> (std::string segment_id)</td></tr>
<tr class="separator:a828a56d15a0f68edd8e3b395c41b0c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a1699ba86d1d5b943d428fc1b391abd42"><td class="memItemLeft" align="right" valign="top"><a id="a1699ba86d1d5b943d428fc1b391abd42"></a>
typedef Exchange_manager_memory&lt; <a class="el" href="classSerializable.html">Serializable</a>, QUEUE_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Memory</b></td></tr>
<tr class="separator:a1699ba86d1d5b943d428fc1b391abd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad5c787b53c26d5b3c75712ca539f3"><td class="memItemLeft" align="right" valign="top"><a id="a92ad5c787b53c26d5b3c75712ca539f3"></a>
typedef std::shared_ptr&lt; Memory &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Memory_ptr</b></td></tr>
<tr class="separator:a92ad5c787b53c26d5b3c75712ca539f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7543d28030c9c3e17b8fd60facc917b2"><td class="memItemLeft" align="right" valign="top"><a id="a7543d28030c9c3e17b8fd60facc917b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="separator:a7543d28030c9c3e17b8fd60facc917b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a65f7ea81649be03ac11b11bc998d5047"><td class="memItemLeft" align="right" valign="top"><a id="a65f7ea81649be03ac11b11bc998d5047"></a>
Memory_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>memory_</b></td></tr>
<tr class="separator:a65f7ea81649be03ac11b11bc998d5047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2838c1a3e709dafe1c941f217d8f54"><td class="memItemLeft" align="right" valign="top"><a id="a3d2838c1a3e709dafe1c941f217d8f54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>leading_</b></td></tr>
<tr class="separator:a3d2838c1a3e709dafe1c941f217d8f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea7ce15b0da981027f80d3d35825593"><td class="memItemLeft" align="right" valign="top"><a id="a6ea7ce15b0da981027f80d3d35825593"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>autolock_</b></td></tr>
<tr class="separator:a6ea7ce15b0da981027f80d3d35825593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830f88a2c6f6d3cf6e0c83353a436742"><td class="memItemLeft" align="right" valign="top"><a id="a830f88a2c6f6d3cf6e0c83353a436742"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>segment_id_</b></td></tr>
<tr class="separator:a830f88a2c6f6d3cf6e0c83353a436742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde973522ab55b0a3c49ef6f26fbba5"><td class="memItemLeft" align="right" valign="top"><a id="afbde973522ab55b0a3c49ef6f26fbba5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>object_id_</b></td></tr>
<tr class="separator:afbde973522ab55b0a3c49ef6f26fbba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a15b2b91e57fb8c9c60ec354274edf20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b2b91e57fb8c9c60ec354274edf20d">&#9670;&nbsp;</a></span>Exchange_manager_consumer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Exchange_manager_consumer::Exchange_manager_consumer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>segment_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autolock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An exchange_manager_consumer reads from the shared memory serialized items produced by an instance of exchange_manager_producer (which should use the same segment_id and object_id), possibly running in a separate process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment_id</td><td>id of the shared memory segment </td></tr>
    <tr><td class="paramname">object_id</td><td>id of the shared memory object prefix </td></tr>
    <tr><td class="paramname">the</td><td>consumer is to be "permanent", while different producers may provide data. Implies the deletion of the underlying share memory upon destruction. </td></tr>
    <tr><td class="paramname">mutex</td><td>locking mechanism internally managed by the producer. If false, lock has to be "manually" called. This allows for example to set several items in one shot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3e006de034b55e328784d3eacfb1772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e006de034b55e328784d3eacfb1772">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Exchange_manager_consumer::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSerializable.html">Serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>serializable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read from the underlying shared memory a serialized object (set by a producer). </p>
<p>Should be called only if ready_to_consume returns true. </p><dl class="section return"><dt>Returns</dt><dd>true if an item has been read </dd></dl>

</div>
</div>
<a id="a1ec59bb41c9de78eb891ea70efe6b8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec59bb41c9de78eb891ea70efe6b8c2">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Exchange_manager_consumer::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lock the mutex required for writting in the shared memory without any collision with any producer. </p>
<p>Should be called before calls to "consume". Not required if the constructor was called with autolock set to true </p>

</div>
</div>
<a id="ab8651cff750b5cb2ceae97a97b2c7f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8651cff750b5cb2ceae97a97b2c7f2d">&#9670;&nbsp;</a></span>nb_char_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Exchange_manager_consumer::nb_char_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of char that have been read from the exchange queue. </p>
<p>For debugging purposes </p>

</div>
</div>
<a id="a5e62220c9b50327130cb95683d22b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e62220c9b50327130cb95683d22b0dc">&#9670;&nbsp;</a></span>purge_feedbacks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Exchange_manager_consumer::purge_feedbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). </p>
<p>This shared queue may get full (e.g the producer does not read it fast enough), in which case the item id is buffered in this instance. If this instance stops to consume, the buffered item ids will never be written in the shared queue, and the producer will not receive the corresponding feedback. This attempts to write the buffered ids into the queue, and returns true if the buffer is not empty after the call (i.e. some feedbacks have not been sent yet), false otherwise. Usage: to call before exit until true is returned </p>

</div>
</div>
<a id="af1a894d796387d297f848d18d8d55df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a894d796387d297f848d18d8d55df5">&#9670;&nbsp;</a></span>ready_to_consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Exchange_manager_consumer::ready_to_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a producer is also running. </p>
<p>'consume' should be called only if ready_to_consume returns true. </p>

</div>
</div>
<a id="aaf053702ec1ef8455fc10e70144f6923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf053702ec1ef8455fc10e70144f6923">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Serializable , int QUEUE_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Exchange_manager_consumer::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unlock the mutex for writting in the shared memory without any collision with any producer. </p>
<p>Not required if the constructor was called with autolock set to true </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/shared_memory/<a class="el" href="exchange__manager__consumer_8hpp_source.html">exchange_manager_consumer.hpp</a></li>
<li>include/shared_memory/<a class="el" href="exchange__manager__consumer_8hxx_source.html">exchange_manager_consumer.hxx</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceshared__memory.html">shared_memory</a></li><li class="navelem"><a class="el" href="classshared__memory_1_1Exchange__manager__consumer.html">Exchange_manager_consumer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
