

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Namespace shared_memory &mdash; shared_memory 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Namespace shared_memory::internal" href="namespaceshared__memory_1_1internal.html" />
    <link rel="prev" title="Namespace list" href="../namespacelist.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> shared_memory
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Readme</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Shared Memory</a></li>
</ul>
<p class="caption"><span class="caption-text">C++ API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../doxygen_index.html">C++ API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../classlist.html">Class list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../filelist.html">File list</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../namespacelist.html">Namespace list</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Namespace shared_memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="namespaceshared__memory_1_1internal.html">Namespace shared_memory::internal</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../structlist.html">Struct list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doxygen_index_one_page.html">C++ API and example</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">shared_memory</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../doxygen_index.html">C++ API</a> &raquo;</li>
        
          <li><a href="../namespacelist.html">Namespace list</a> &raquo;</li>
        
      <li>Namespace shared_memory</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/breathe/namespace/namespaceshared__memory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="namespace-shared-memory">
<h1>Namespace shared_memory<a class="headerlink" href="#namespace-shared-memory" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="_CPPv413shared_memory">
<span id="_CPPv313shared_memory"></span><span id="_CPPv213shared_memory"></span><span id="shared_memory"></span><span class="target" id="namespaceshared__memory"></span><em class="property">namespace </em><code class="sig-name descname">shared_memory</code><br /></dt>
<dd><p>All templated types in this namespaces are elementary types: int, double, float, char*, … </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv4N13shared_memory12SHMConditionE">
<span id="_CPPv3N13shared_memory12SHMConditionE"></span><span id="_CPPv2N13shared_memory12SHMConditionE"></span><span id="shared_memory::SHMCondition"></span><span class="target" id="namespaceshared__memory_1a98598a317e2364e30dec871c52491d3c"></span><em class="property">typedef </em>boost::interprocess::named_condition <code class="sig-name descname">SHMCondition</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory12SERIALIZABLEE">
<span id="_CPPv3N13shared_memory12SERIALIZABLEE"></span><span id="_CPPv2N13shared_memory12SERIALIZABLEE"></span><span id="shared_memory::SERIALIZABLE"></span><span class="target" id="namespaceshared__memory_1af5f7fb7bbbc4c6334d59d0cd09f3ba85"></span><em class="property">typedef </em>std::integral_constant&lt;int, 0&gt; <code class="sig-name descname">SERIALIZABLE</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory11FUNDAMENTALE">
<span id="_CPPv3N13shared_memory11FUNDAMENTALE"></span><span id="_CPPv2N13shared_memory11FUNDAMENTALE"></span><span id="shared_memory::FUNDAMENTAL"></span><span class="target" id="namespaceshared__memory_1a391f1de569d6b76979d6ff4591513bfd"></span><em class="property">typedef </em>std::integral_constant&lt;int, 1&gt; <code class="sig-name descname">FUNDAMENTAL</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory17FUNDAMENTAL_ARRAYE">
<span id="_CPPv3N13shared_memory17FUNDAMENTAL_ARRAYE"></span><span id="_CPPv2N13shared_memory17FUNDAMENTAL_ARRAYE"></span><span id="shared_memory::FUNDAMENTAL_ARRAY"></span><span class="target" id="namespaceshared__memory_1a641fa51f2069f15b1dfb114e630fc1ba"></span><em class="property">typedef </em>std::integral_constant&lt;int, 2&gt; <code class="sig-name descname">FUNDAMENTAL_ARRAY</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory12SHMScopeLockE">
<span id="_CPPv3N13shared_memory12SHMScopeLockE"></span><span id="_CPPv2N13shared_memory12SHMScopeLockE"></span><span id="shared_memory::SHMScopeLock"></span><span class="target" id="namespaceshared__memory_1aa1e27e85804c1f1c0b7c1bf077add7bf"></span><em class="property">typedef </em>boost::interprocess::scoped_lock&lt;<a class="reference internal" href="../file/mutex_8hpp.html#_CPPv4N13shared_memory8SHMMutexE" title="shared_memory::SHMMutex">SHMMutex</a>&gt; <code class="sig-name descname">SHMScopeLock</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory14UnamedSHMMutexE">
<span id="_CPPv3N13shared_memory14UnamedSHMMutexE"></span><span id="_CPPv2N13shared_memory14UnamedSHMMutexE"></span><span id="shared_memory::UnamedSHMMutex"></span><span class="target" id="namespaceshared__memory_1a2a3aa667d92610e695d7948a834172f1"></span><em class="property">typedef </em>boost::interprocess::interprocess_mutex <code class="sig-name descname">UnamedSHMMutex</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory18UnamedSHMConditionE">
<span id="_CPPv3N13shared_memory18UnamedSHMConditionE"></span><span id="_CPPv2N13shared_memory18UnamedSHMConditionE"></span><span id="shared_memory::UnamedSHMCondition"></span><span class="target" id="namespaceshared__memory_1a83b64c7cfca3d52b46e5e9833968a7b9"></span><em class="property">typedef </em>boost::interprocess::interprocess_condition <code class="sig-name descname">UnamedSHMCondition</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory13UnamedSHMLockE">
<span id="_CPPv3N13shared_memory13UnamedSHMLockE"></span><span id="_CPPv2N13shared_memory13UnamedSHMLockE"></span><span id="shared_memory::UnamedSHMLock"></span><span class="target" id="namespaceshared__memory_1a0b94121a6c0d65beda535a70704a1aa5"></span><em class="property">typedef </em>boost::interprocess::scoped_lock&lt;<a class="reference internal" href="../file/locked__condition__variable_8hpp.html#_CPPv4N13shared_memory14UnamedSHMMutexE" title="shared_memory::UnamedSHMMutex">UnamedSHMMutex</a>&gt; <code class="sig-name descname">UnamedSHMLock</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory8SHMMutexE">
<span id="_CPPv3N13shared_memory8SHMMutexE"></span><span id="_CPPv2N13shared_memory8SHMMutexE"></span><span id="shared_memory::SHMMutex"></span><span class="target" id="namespaceshared__memory_1a9e455ab41b63e529ceca7424dbf13ba1"></span><em class="property">typedef </em>boost::interprocess::named_mutex <code class="sig-name descname">SHMMutex</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory21private_serializationE">
<span id="_CPPv3N13shared_memory21private_serializationE"></span><span id="_CPPv2N13shared_memory21private_serializationE"></span><span id="shared_memory::private_serialization"></span><span class="target" id="namespaceshared__memory_1ada3eeebd8f77a3757ad50c9401bcd249"></span><em class="property">typedef </em>cereal::access <code class="sig-name descname">private_serialization</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory10ShmObjectsE">
<span id="_CPPv3N13shared_memory10ShmObjectsE"></span><span id="_CPPv2N13shared_memory10ShmObjectsE"></span><span id="shared_memory::ShmObjects"></span><span class="target" id="namespaceshared__memory_1ae50b2192256821112a69e47d5314b467"></span><em class="property">typedef </em>std::map&lt;std::string, std::pair&lt;void *, std::size_t&gt;&gt; <code class="sig-name descname">ShmObjects</code><br /></dt>
<dd><p>ShmObjects typedef is a simple renaming that ease the for loop writting. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory16ShmCharAllocatorE">
<span id="_CPPv3N13shared_memory16ShmCharAllocatorE"></span><span id="_CPPv2N13shared_memory16ShmCharAllocatorE"></span><span id="shared_memory::ShmCharAllocator"></span><span class="target" id="namespaceshared__memory_1a36a105df63154c883e86f4282f380647"></span><em class="property">typedef </em>ShmTypeHelper&lt;char&gt;::ElemTypeAllocator <code class="sig-name descname">ShmCharAllocator</code><br /></dt>
<dd><p>Create a char allocator to ease the creation of strings. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory9ShmStringE">
<span id="_CPPv3N13shared_memory9ShmStringE"></span><span id="_CPPv2N13shared_memory9ShmStringE"></span><span id="shared_memory::ShmString"></span><span class="target" id="namespaceshared__memory_1a07ee51d077030d33ba8408f5938569cc"></span><em class="property">typedef </em>std::basic_string&lt;char, std::char_traits&lt;char&gt;, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4N13shared_memory16ShmCharAllocatorE" title="shared_memory::ShmCharAllocator">ShmCharAllocator</a>&gt; <code class="sig-name descname">ShmString</code><br /></dt>
<dd><p>Create a basic_string type for the Shared Memory. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory10SegmentMapE">
<span id="_CPPv3N13shared_memory10SegmentMapE"></span><span id="_CPPv2N13shared_memory10SegmentMapE"></span><span id="shared_memory::SegmentMap"></span><span class="target" id="namespaceshared__memory_1a9aeebdfb6185497cac7c093cf3d765c5"></span><em class="property">typedef </em>std::map&lt;std::string, std::unique_ptr&lt;<a class="reference internal" href="../class/classshared__memory_1_1_shared_memory_segment.html#_CPPv4N13shared_memory19SharedMemorySegmentE" title="shared_memory::SharedMemorySegment">SharedMemorySegment</a>&gt;&gt; <code class="sig-name descname">SegmentMap</code><br /></dt>
<dd><p>SegmentMap typedef is a simple short cut to the GLOBAL_SHM_SEGMENTS type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory11clear_arrayENSt6stringE">
<span id="_CPPv3N13shared_memory11clear_arrayENSt6stringE"></span><span id="_CPPv2N13shared_memory11clear_arrayENSt6stringE"></span><span id="shared_memory::clear_array__ss"></span><span class="target" id="namespaceshared__memory_1a0371eb6089f446098adf2f9c106333dc"></span>void <code class="sig-name descname">clear_array</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>wipe the shared memory segment created by an instance of <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1array"><span class="std std-ref">shared_memory::array</span></a>, including mutexes, if any. </p>
<p>If there are no memory segment of this id, there will be no effect. If <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1array"><span class="std std-ref">shared_memory::array</span></a> instances are pointing to the wiped out segment, their get and set functions may hang indefinitely. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory16get_segment_sizeE6size_t6size_t">
<span id="_CPPv3N13shared_memory16get_segment_sizeE6size_t6size_t"></span><span id="_CPPv2N13shared_memory16get_segment_sizeE6size_t6size_t"></span><span id="shared_memory::get_segment_size__s.s"></span><span class="target" id="namespaceshared__memory_1a62e06d817f0f52addc9970db9f83e15d"></span><em class="property">static</em> uint <code class="sig-name descname">get_segment_size</code><span class="sig-paren">(</span>size_t <em>size_array</em>, size_t <em>size_item</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13shared_memory16get_segment_sizeE6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17set_segment_sizesE4uint">
<span id="_CPPv3N13shared_memory17set_segment_sizesE4uint"></span><span id="_CPPv2N13shared_memory17set_segment_sizesE4uint"></span><span id="shared_memory::set_segment_sizes__uint"></span><span class="target" id="namespaceshared__memory_1ac8ef94dc78f444092f488f0143b155f2"></span>void <code class="sig-name descname">set_segment_sizes</code><span class="sig-paren">(</span>uint <em>multiplier_1025</em><span class="sig-paren">)</span><br /></dt>
<dd><p>sets the size of the segments that will be newly created via the set methods. </p>
<p>Until this function is called, segments are created with a size of 65536 bytes. This function is not interprocess : it will set the size of segments created in the current process <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">multiplier_1025</span></code>: the size of create segment will be multiplier_1025 * 1025 bytes (because memory segment sizes have to be a multiple of 1025) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory25set_default_segment_sizesEv">
<span id="_CPPv3N13shared_memory25set_default_segment_sizesEv"></span><span id="_CPPv2N13shared_memory25set_default_segment_sizesEv"></span><span id="shared_memory::set_default_segment_sizes"></span><span class="target" id="namespaceshared__memory_1a841687861fcc9efe381ffbe84843ca33"></span>void <code class="sig-name descname">set_default_segment_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>set the size of segment newly created to the default size value of 65536 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory11get_segmentERKNSt6stringEKb">
<span id="_CPPv3N13shared_memory11get_segmentERKNSt6stringEKb"></span><span id="_CPPv2N13shared_memory11get_segmentERKNSt6stringEKb"></span><span id="shared_memory::get_segment__ssCR.bC"></span><span class="target" id="namespaceshared__memory_1a7c76ec22ab70d3b7487becd3ec9943bc"></span><a class="reference internal" href="../class/classshared__memory_1_1_shared_memory_segment.html#_CPPv4N13shared_memory19SharedMemorySegmentE" title="shared_memory::SharedMemorySegment">SharedMemorySegment</a> &amp;<code class="sig-name descname">get_segment</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> bool <em>clear_upon_destruction</em> = false<span class="sig-paren">)</span><br /></dt>
<dd><p>get_segment creates or give back a pointer to a <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_shared_memory_segment"><span class="std std-ref">SharedMemorySegment</span></a> object. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory16get_segment_infoERKNSt6stringEKb">
<span id="_CPPv3N13shared_memory16get_segment_infoERKNSt6stringEKb"></span><span id="_CPPv2N13shared_memory16get_segment_infoERKNSt6stringEKb"></span><span id="shared_memory::get_segment_info__ssCR.bC"></span><span class="target" id="namespaceshared__memory_1a70f7613a247615e323cab083934c803e"></span><a class="reference internal" href="../class/classshared__memory_1_1_segment_info.html#_CPPv4N13shared_memory11SegmentInfoE" title="shared_memory::SegmentInfo">SegmentInfo</a> <code class="sig-name descname">get_segment_info</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> bool <em>clear_upon_destruction</em> = false<span class="sig-paren">)</span><br /></dt>
<dd><p>performs introspection on the segment and return related information. </p>
<p>If the segment does not exists, creates it first. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory14segment_existsERKNSt6stringE">
<span id="_CPPv3N13shared_memory14segment_existsERKNSt6stringE"></span><span id="_CPPv2N13shared_memory14segment_existsERKNSt6stringE"></span><span id="shared_memory::segment_exists__ssCR"></span><span class="target" id="namespaceshared__memory_1a82297c2b7b85c57c53578749c9bd6429"></span>bool <code class="sig-name descname">segment_exists</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>returns true if a segment exists under this id </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory14delete_segmentERKNSt6stringE">
<span id="_CPPv3N13shared_memory14delete_segmentERKNSt6stringE"></span><span id="_CPPv2N13shared_memory14delete_segmentERKNSt6stringE"></span><span id="shared_memory::delete_segment__ssCR"></span><span class="target" id="namespaceshared__memory_1a60cbce63ae7fb64a2758b773f9006471"></span>void <code class="sig-name descname">delete_segment</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>delete_segment deletes the segment of existing shared memory. </p>
<p>it makes sure that all element created in it is destroyed first. (is this needed? I do not know.) <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory18delete_all_segmentEv">
<span id="_CPPv3N13shared_memory18delete_all_segmentEv"></span><span id="_CPPv2N13shared_memory18delete_all_segmentEv"></span><span id="shared_memory::delete_all_segment"></span><span class="target" id="namespaceshared__memory_1a1f88dd41dca9a23387090866213dbd85"></span>void <code class="sig-name descname">delete_all_segment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>delete_all_segment delete all mapping to the shared memory used during the current process </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory13delete_objectEbRKNSt6stringERKNSt6stringE">
<span id="_CPPv3I0EN13shared_memory13delete_objectERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2I0EN13shared_memory13delete_objectERKNSt6stringERKNSt6stringE"></span><span class="target" id="namespaceshared__memory_1a7b43b29fa0aa6a5cad0ca47afdd03e83"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />bool <code class="sig-name descname">delete_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>delete_object deletes a particular object in the shared memory segment </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if everything went fine. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17get_segment_mutexEKNSt6stringE">
<span id="_CPPv3N13shared_memory17get_segment_mutexEKNSt6stringE"></span><span id="_CPPv2N13shared_memory17get_segment_mutexEKNSt6stringE"></span><span id="shared_memory::get_segment_mutex__ssC"></span><span class="target" id="namespaceshared__memory_1aed33c9701140a1c43e40f182a380199b"></span>boost::interprocess::interprocess_mutex &amp;<code class="sig-name descname">get_segment_mutex</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get_sgement_mutex aquiere a reference to the semgent global mutex. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to a boost mutex </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19clear_shared_memoryERKNSt6stringE">
<span id="_CPPv3N13shared_memory19clear_shared_memoryERKNSt6stringE"></span><span id="_CPPv2N13shared_memory19clear_shared_memoryERKNSt6stringE"></span><span id="shared_memory::clear_shared_memory__ssCR"></span><span class="target" id="namespaceshared__memory_1aa8583540879db53fc80b31410b5eec68"></span>void <code class="sig-name descname">clear_shared_memory</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>clear_shared_memory_segment destroys the shared memory </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK8ElemType">
<span id="_CPPv3I0EN13shared_memory3setERKNSt6stringERKNSt6stringERK8ElemType"></span><span id="_CPPv2I0EN13shared_memory3setERKNSt6stringERKNSt6stringERK8ElemType"></span><span class="target" id="namespaceshared__memory_1ace68bf582cfe50ba83a9cfc9b7aed3b2"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK8ElemType" title="shared_memory::set::ElemType">ElemType</a> &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to any elementary types in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringEPK8ElemTypeKNSt6size_tE">
<span id="_CPPv3I0EN13shared_memory3setERKNSt6stringERKNSt6stringEPK8ElemTypeKNSt6size_tE"></span><span id="_CPPv2I0EN13shared_memory3setERKNSt6stringERKNSt6stringEPK8ElemTypeKNSt6size_tE"></span><span class="target" id="namespaceshared__memory_1a7e37a0a2146d2cfeeccb63390a3d9132"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK8ElemType" title="shared_memory::set::ElemType">ElemType</a> *<em>set_</em>, <em class="property">const</em> std::size_t <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a fixed sized array of the templated type “T” in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the pointer to the array of objects to set in the memory. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">size</span></code>: is the array size. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory3setERKNSt6stringERKNSt6stringERKNSt6stringE">
<span id="_CPPv3N13shared_memory3setERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2N13shared_memory3setERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span id="shared_memory::set__ssCR.ssCR.ssCR"></span><span class="target" id="namespaceshared__memory_1a61a2945c994bcbe84cc8dce96a189edb"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::string &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a string in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt6vectorI8ElemTypeEE">
<span id="_CPPv3I0EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt6vectorI8ElemTypeEE"></span><span id="_CPPv2I0EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt6vectorI8ElemTypeEE"></span><span class="target" id="namespaceshared__memory_1ac6521a6731fa97be21779b1d6c7589ee"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK8ElemType" title="shared_memory::set::ElemType">ElemType</a>&gt; &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a std::vector&lt;ElemType&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEXL1EEEE">
<span id="_CPPv3I0EN13shared_memory3setERKNSt6stringERKNSt6stringERKN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEXL1EEEE"></span><span id="_CPPv2I0EN13shared_memory3setERKNSt6stringERKNSt6stringERKN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEX1EEE"></span><span class="target" id="namespaceshared__memory_1ac8364e5cde6c8a2f1abc2a59035f26a6"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> Eigen::Matrix&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK8ElemType" title="shared_memory::set::ElemType">ElemType</a>, Eigen::Dynamic, 1&gt; &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a Eigen::Matrix&lt;ElemType, Eigen::Dynamic, 1&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt4pairI9FirstType10SecondTypeEE">
<span id="_CPPv3I00EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt4pairI9FirstType10SecondTypeEE"></span><span id="_CPPv2I00EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt4pairI9FirstType10SecondTypeEE"></span><span class="target" id="namespaceshared__memory_1a657bb799483a19a96f61706b50aca1e7"></span>template&lt;typename <code class="sig-name descname">FirstType</code>, typename <code class="sig-name descname">SecondType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::pair&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt4pairI9FirstType10SecondTypeEE" title="shared_memory::set::FirstType">FirstType</a>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt4pairI9FirstType10SecondTypeEE" title="shared_memory::set::SecondType">SecondType</a>&gt; &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a std::pair&lt;FirstType, SecondType&gt; in the shared memory. </p>
<p>This is very usefull to dump maps in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt3mapI7KeyType9ValueTypeEE">
<span id="_CPPv3I00EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt3mapI7KeyType9ValueTypeEE"></span><span id="_CPPv2I00EN13shared_memory3setERKNSt6stringERKNSt6stringERKNSt3mapI7KeyType9ValueTypeEE"></span><span class="target" id="namespaceshared__memory_1a562e79433e54463f39c9c276b8440f4b"></span>template&lt;typename <code class="sig-name descname">KeyType</code>, typename <code class="sig-name descname">ValueType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::map&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt3mapI7KeyType9ValueTypeEE" title="shared_memory::set::KeyType">KeyType</a>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERKNSt3mapI7KeyType9ValueTypeEE" title="shared_memory::set::ValueType">ValueType</a>&gt; &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set instanciates or get pointer to a std::vector&lt;ElemType&gt; or an Eigen::Matrix&lt;ElemType, any, any&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringER8ElemType">
<span id="_CPPv3I0EN13shared_memory3getERKNSt6stringERKNSt6stringER8ElemType"></span><span id="_CPPv2I0EN13shared_memory3getERKNSt6stringERKNSt6stringER8ElemType"></span><span class="target" id="namespaceshared__memory_1ad017562102dbe044db2de6c79c0669d3"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringER8ElemType" title="shared_memory::get::ElemType">ElemType</a> &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to any elementary types in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">get_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringEP8ElemTypeKNSt6size_tE">
<span id="_CPPv3I0EN13shared_memory3getERKNSt6stringERKNSt6stringEP8ElemTypeKNSt6size_tE"></span><span id="_CPPv2I0EN13shared_memory3getERKNSt6stringERKNSt6stringEP8ElemTypeKNSt6size_tE"></span><span class="target" id="namespaceshared__memory_1a6241b9143a2152b0c0beb784869373c7"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringER8ElemType" title="shared_memory::get::ElemType">ElemType</a> *<em>get_</em>, <em class="property">const</em> std::size_t <em>expected_size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to a fixed sized array of the templated type “T” in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">get_</span></code>: is the pointer to the array of objects to set in the memory. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">size</span></code>: is the array size. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory3getERKNSt6stringERKNSt6stringERNSt6stringE">
<span id="_CPPv3N13shared_memory3getERKNSt6stringERKNSt6stringERNSt6stringE"></span><span id="_CPPv2N13shared_memory3getERKNSt6stringERKNSt6stringERNSt6stringE"></span><span id="shared_memory::get__ssCR.ssCR.ssR"></span><span class="target" id="namespaceshared__memory_1a8a952cc446e3dce8fea8cd1ea02613f9"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, std::string &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to a string in the shared memory. </p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">get_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt6vectorI8ElemTypeEE">
<span id="_CPPv3I0EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt6vectorI8ElemTypeEE"></span><span id="_CPPv2I0EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt6vectorI8ElemTypeEE"></span><span class="target" id="namespaceshared__memory_1afd0ab66344562f5d927dea0d319a6a08"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, std::vector&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringER8ElemType" title="shared_memory::get::ElemType">ElemType</a>&gt; &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to a std::vector&lt;ElemType&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringERN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEXL1EEEE">
<span id="_CPPv3I0EN13shared_memory3getERKNSt6stringERKNSt6stringERN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEXL1EEEE"></span><span id="_CPPv2I0EN13shared_memory3getERKNSt6stringERKNSt6stringERN5Eigen6MatrixI8ElemTypeN5Eigen7DynamicEX1EEE"></span><span class="target" id="namespaceshared__memory_1a4e230e55e38089aee71cd6df93110174"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, Eigen::Matrix&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory3getEvRKNSt6stringERKNSt6stringER8ElemType" title="shared_memory::get::ElemType">ElemType</a>, Eigen::Dynamic, 1&gt; &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to a Eigen::Matrix&lt;ElemType, Eigen::Dynamic, 1&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt4pairI9FirstType10SecondTypeEE">
<span id="_CPPv3I00EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt4pairI9FirstType10SecondTypeEE"></span><span id="_CPPv2I00EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt4pairI9FirstType10SecondTypeEE"></span><span class="target" id="namespaceshared__memory_1a2579e9a10a16e0fbd006900c618addc8"></span>template&lt;typename <code class="sig-name descname">FirstType</code>, typename <code class="sig-name descname">SecondType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, std::pair&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt4pairI9FirstType10SecondTypeEE" title="shared_memory::get::FirstType">FirstType</a>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt4pairI9FirstType10SecondTypeEE" title="shared_memory::get::SecondType">SecondType</a>&gt; &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get instanciates or get pointer to a std::pair&lt;FirstType, SecondType&gt; in the shared memory. </p>
<p>This is very usefull to dump maps in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">get_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt3mapI7KeyType9ValueTypeEE">
<span id="_CPPv3I00EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt3mapI7KeyType9ValueTypeEE"></span><span id="_CPPv2I00EN13shared_memory3getERKNSt6stringERKNSt6stringERNSt3mapI7KeyType9ValueTypeEE"></span><span class="target" id="namespaceshared__memory_1add6604c2716e51cdcf17de2439251089"></span>template&lt;typename <code class="sig-name descname">KeyType</code>, typename <code class="sig-name descname">ValueType</code>&gt;<br />void <code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, std::map&lt;<a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt3mapI7KeyType9ValueTypeEE" title="shared_memory::get::KeyType">KeyType</a>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I00EN13shared_memory3getEvRKNSt6stringERKNSt6stringERNSt3mapI7KeyType9ValueTypeEE" title="shared_memory::get::ValueType">ValueType</a>&gt; &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get gets a pointer to a std::vector&lt;ElemType&gt; or an Eigen::Matrix&lt;ElemType, any, any&gt; in the shared memory. </p>
<p>This will translated as a fixed sized array in the shared memory</p>
<p>All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">get_</span></code>: is the string to be created in the shared memory </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory9serializeEvRKNSt6stringERKNSt6stringERK12Serializable">
<span id="_CPPv3I0EN13shared_memory9serializeERKNSt6stringERKNSt6stringERK12Serializable"></span><span id="_CPPv2I0EN13shared_memory9serializeERKNSt6stringERKNSt6stringERK12Serializable"></span><span class="target" id="namespaceshared__memory_1a003005dc269ebf79f08523dc0f8d1ed0"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br />void <code class="sig-name descname">serialize</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment</em>, <em class="property">const</em> std::string &amp;<em>object</em>, <em class="property">const</em> <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory9serializeEvRKNSt6stringERKNSt6stringERK12Serializable" title="shared_memory::serialize::Serializable">Serializable</a> &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Serialize the instance into a string which is written in the shared memory. </p>
<p>This uses cereal for serialization, and <a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a> must implement a serialize function, see: <a class="reference external" href="https://uscilab.github.io/cereal/">https://uscilab.github.io/cereal/</a> <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">serializable</span></code>: is the instance to serialize </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory11deserializeEvRKNSt6stringERKNSt6stringER12Serializable">
<span id="_CPPv3I0EN13shared_memory11deserializeERKNSt6stringERKNSt6stringER12Serializable"></span><span id="_CPPv2I0EN13shared_memory11deserializeERKNSt6stringERKNSt6stringER12Serializable"></span><span class="target" id="namespaceshared__memory_1a33e39adccccefb603e2dafc7ea8733e8"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br />void <code class="sig-name descname">deserialize</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment</em>, <em class="property">const</em> std::string &amp;<em>object</em>, <a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4I0EN13shared_memory11deserializeEvRKNSt6stringERKNSt6stringER12Serializable" title="shared_memory::deserialize::Serializable">Serializable</a> &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read from the memory a string that is deserialized into the passed instance of <a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a>. </p>
<p>This assumes the serialization and writting in the shared memory has been performed using the serialize function. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">segment_id</span></code>: is the name of the shared memory segment. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: is the name of the shared memory object to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">serializable</span></code>: is the instance in which the string will be deserialized </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory11set_verboseEb">
<span id="_CPPv3N13shared_memory11set_verboseEb"></span><span id="_CPPv2N13shared_memory11set_verboseEb"></span><span id="shared_memory::set_verbose__b"></span><span class="target" id="namespaceshared__memory_1afe26d531f043f59bb36ea7816b8a40bf"></span>void <code class="sig-name descname">set_verbose</code><span class="sig-paren">(</span>bool <em>mode</em><span class="sig-paren">)</span><br /></dt>
<dd><p>if verbose mode set to true (starting default is false), informaton about newly created objects will be displayed in the terminal. </p>
<p>Call to this function will change the verbose mode only for the current process. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK10VectorType">
<span id="_CPPv3I00EN13shared_memory3setERKNSt6stringERKNSt6stringERK10VectorType"></span><span id="_CPPv2I00EN13shared_memory3setERKNSt6stringERKNSt6stringERK10VectorType"></span><span class="target" id="namespaceshared__memory_1a653947408c221da4e2c26439ba913f8d"></span>template&lt;typename <code class="sig-name descname">VectorType</code>, typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> <a class="reference internal" href="../file/shared__memory_8hxx.html#_CPPv4I00EN13shared_memory3setEvRKNSt6stringERKNSt6stringERK10VectorType" title="shared_memory::set::VectorType">VectorType</a> &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Variables</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory7VERBOSEE">
<span id="_CPPv3N13shared_memory7VERBOSEE"></span><span id="_CPPv2N13shared_memory7VERBOSEE"></span><span id="shared_memory::VERBOSE__b"></span><span class="target" id="namespaceshared__memory_1adb7d7158652e09188fea583e05949bb5"></span>bool <code class="sig-name descname">VERBOSE</code> = false<br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory19GLOBAL_SHM_SEGMENTSE">
<span id="_CPPv3N13shared_memory19GLOBAL_SHM_SEGMENTSE"></span><span id="_CPPv2N13shared_memory19GLOBAL_SHM_SEGMENTSE"></span><span id="shared_memory::GLOBAL_SHM_SEGMENTS__SegmentMap"></span><span class="target" id="namespaceshared__memory_1ad1f78482aa062e165f37fd49e2e8f539"></span><a class="reference internal" href="../file/shared__memory_8hxx.html#_CPPv4N13shared_memory10SegmentMapE" title="shared_memory::SegmentMap">SegmentMap</a> <code class="sig-name descname">GLOBAL_SHM_SEGMENTS</code><br /></dt>
<dd><p>GLOBAL_SHARED_MEMORY_SEGMENT is global variable that acts as a a shared memory manager. </p>
<p>The use of the std::unique_ptr allows to delete the object and re-create at will. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory12SEGMENT_SIZEE">
<span id="_CPPv3N13shared_memory12SEGMENT_SIZEE"></span><span id="_CPPv2N13shared_memory12SEGMENT_SIZEE"></span><span id="shared_memory::SEGMENT_SIZE__uint"></span><span class="target" id="namespaceshared__memory_1a1aa02b0b88f0045c3711029f882d80fa"></span>uint <code class="sig-name descname">SEGMENT_SIZE</code> = DEFAULT_SHARED_MEMORY_SIZE<br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory18SEGMENT_SIZE_MUTEXE">
<span id="_CPPv3N13shared_memory18SEGMENT_SIZE_MUTEXE"></span><span id="_CPPv2N13shared_memory18SEGMENT_SIZE_MUTEXE"></span><span id="shared_memory::SEGMENT_SIZE_MUTEX__std::mutex"></span><span class="target" id="namespaceshared__memory_1a5c687b65860cde45c62305fbb7a19e71"></span>std::mutex <code class="sig-name descname">SEGMENT_SIZE_MUTEX</code><br /></dt>
<dd></dd></dl>

</div>
<dl class="class">
<dt id="_CPPv4N13shared_memory20Allocation_exceptionE">
<span id="_CPPv3N13shared_memory20Allocation_exceptionE"></span><span id="_CPPv2N13shared_memory20Allocation_exceptionE"></span><span id="shared_memory::Allocation_exception"></span><span class="target" id="classshared__memory_1_1_allocation__exception"></span><em class="property">class </em><code class="sig-name descname">Allocation_exception</code> : <em class="property">public</em> exception<br /></dt>
<dd><em>#include &lt;exceptions.h&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory20Allocation_exception20Allocation_exceptionERKNSt6stringERKNSt6stringE">
<span id="_CPPv3N13shared_memory20Allocation_exception20Allocation_exceptionERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2N13shared_memory20Allocation_exception20Allocation_exceptionERKNSt6stringERKNSt6stringE"></span><span id="shared_memory::Allocation_exception::Allocation_exception__ssCR.ssCR"></span><span class="target" id="classshared__memory_1_1_allocation__exception_1ac81ff8567ac6c6cec754fefc5fe79d12"></span><code class="sig-name descname">Allocation_exception</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory20Allocation_exceptionD0Ev">
<span id="_CPPv3N13shared_memory20Allocation_exceptionD0Ev"></span><span id="_CPPv2N13shared_memory20Allocation_exceptionD0Ev"></span><span id="shared_memory::Allocation_exception::~Allocation_exception"></span><span class="target" id="classshared__memory_1_1_allocation__exception_1a3c753547b3509c87dbef42974ef02cb9"></span><code class="sig-name descname">~Allocation_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory20Allocation_exception4whatEv">
<span id="_CPPv3NK13shared_memory20Allocation_exception4whatEv"></span><span id="_CPPv2NK13shared_memory20Allocation_exception4whatEv"></span><span id="shared_memory::Allocation_exception::whatC"></span><span class="target" id="classshared__memory_1_1_allocation__exception_1ac0764146f0a70b242491a990fa448dc3"></span><em class="property">const</em> char *<code class="sig-name descname">what</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory20Allocation_exception14error_message_E">
<span id="_CPPv3N13shared_memory20Allocation_exception14error_message_E"></span><span id="_CPPv2N13shared_memory20Allocation_exception14error_message_E"></span><span id="shared_memory::Allocation_exception::error_message___ss"></span><span class="target" id="classshared__memory_1_1_allocation__exception_1a57a0e22bd60d77310cd67371a2294028"></span>std::string <code class="sig-name descname">error_message_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0_iEN13shared_memory5arrayE">
<span id="_CPPv3I0_iEN13shared_memory5arrayE"></span><span id="_CPPv2I0_iEN13shared_memory5arrayE"></span><span class="target" id="classshared__memory_1_1array"></span>template&lt;typename <code class="sig-name descname">T</code>, int <code class="sig-name descname">SIZE</code> = 0&gt;<br /><em class="property">class </em><code class="sig-name descname">array</code> : <em class="property">public</em> <a class="reference internal" href="../file/array_8cpp.html#_CPPv413shared_memory" title="shared_memory">shared_memory</a>::<a class="reference internal" href="../file/array__members_8hpp.html#_CPPv4N13shared_memory8internalE" title="shared_memory::internal">internal</a>::<a class="reference internal" href="../class/classshared__memory_1_1internal_1_1array__members.html#_CPPv4I0_i0EN13shared_memory8internal13array_membersE" title="shared_memory::internal::array_members">array_members</a>&lt;<a class="reference internal" href="../class/classshared__memory_1_1array.html#_CPPv4I0_iEN13shared_memory5arrayE" title="shared_memory::array::T">T</a>, <a class="reference internal" href="../class/classshared__memory_1_1array.html#_CPPv4I0_iEN13shared_memory5arrayE" title="shared_memory::array::SIZE">SIZE</a>&gt;<br /></dt>
<dd><em>#include &lt;array.hpp&gt;</em><p>Implement a shared array stored on a shared memory segment. </p>
<p>Items hosted by the array may be of (1) fundamental type (e.g. int, double, char), (2) array of fundamental type (e.g. int[10]); or (3) instances of a class implementing a serializable function (see shared_memory::serializer). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory5array5arrayENSt6stringENSt6size_tEbb">
<span id="_CPPv3N13shared_memory5array5arrayENSt6stringENSt6size_tEbb"></span><span id="_CPPv2N13shared_memory5array5arrayENSt6stringENSt6size_tEbb"></span><span id="shared_memory::array::array__ss.std::s.b.b"></span><span class="target" id="classshared__memory_1_1array_1a95b5abd158cb04ab0644f5aa6df48b2b"></span><code class="sig-name descname">array</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, std::size_t <em>size</em>, bool <em>clear_on_destruction</em> = true, bool <em>multiprocess_safe</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: should be the same for all array pointing to the same shared memory segment </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: : number of elements to be stored by the array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clear_on_destruction</span></code>: if true, the shared memory segment will be wiped on destruction of the array. Note that any other array pointing to this segment may hang indefinitely as a result. If no arrays pointing to the shared memory segment delete the segment, then users are expected to call <a class="reference internal" href="../../doxygen_index_one_page.html#namespaceshared__memory_1a0371eb6089f446098adf2f9c106333dc"><span class="std std-ref">shared_memory::clear_array</span></a>. Failing to do so may result in new array pointing to a new memory segment of the same id to hang indefinitely at construction. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multiprocess_safe</span></code>: if false, it is strongly adviced to protect accesses via a <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_mutex"><span class="std std-ref">shared_memory::Mutex</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrayD0Ev">
<span id="_CPPv3N5arrayD0Ev"></span><span id="_CPPv2N5arrayD0Ev"></span><span id="array::~array"></span><span class="target" id="classshared__memory_1_1array_1a45cad350fdb0170c955c8c367a9e910d"></span><code class="sig-name descname">~array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>wipe the related shared memory segment if clear_on_destruction is true (true by default) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array5arrayERK5arrayI1T4SIZEE">
<span id="_CPPv3N5array5arrayERK5arrayI1T4SIZEE"></span><span id="_CPPv2N5array5arrayERK5arrayI1T4SIZEE"></span><span id="array::array__array:T.SIZE:CR"></span><span class="target" id="classshared__memory_1_1array_1acde1531706ba2ab6c05d7639bc0f6f56"></span><code class="sig-name descname">array</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../class/classshared__memory_1_1array.html#_CPPv4N5array5arrayERK5arrayI1T4SIZEE" title="array::array">array</a>&lt;T, SIZE&gt; &amp;<em>other</em><span class="sig-paren">)</span><br /></dt>
<dd><p>this array and other array will point to the same memory segment, and will have same values for clear_on_destruction and multiprocess_safe </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory5array5arrayERR5arrayI1T4SIZEE">
<span id="_CPPv3N13shared_memory5array5arrayERR5arrayI1T4SIZEE"></span><span id="_CPPv2N13shared_memory5array5arrayERR5arrayI1T4SIZEE"></span><span id="shared_memory::array::array__array:T.SIZE:RR"></span><span class="target" id="classshared__memory_1_1array_1af399f2f20d16dadf8381c61ea5ad42fd"></span><code class="sig-name descname">array</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1array.html#_CPPv4N13shared_memory5array5arrayENSt6stringENSt6size_tEbb" title="shared_memory::array::array">array</a>&lt;T, SIZE&gt; &amp;&amp;<em>other</em><span class="sig-paren">)</span><br /></dt>
<dd><p>This array will point to the share memory segment pointed at by other; and will have same value for multprocess_safe and clear_on_destruction. </p>
<p>Warning: even if other.clear_on_destruction is true, the segment memory will not be wiped on the destruction of other. The duty of deleting the shared memory is passed to the new instance, so to speak </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrayaSERR5arrayI1T4SIZEE">
<span id="_CPPv3N5arrayaSERR5arrayI1T4SIZEE"></span><span id="_CPPv2N5arrayaSERR5arrayI1T4SIZEE"></span><span id="array::assign-operator__array:T.SIZE:RR"></span><span class="target" id="classshared__memory_1_1array_1ad5b4b2841b2785b188a6371cb7f00f1f"></span>array&lt;T, SIZE&gt; &amp;<code class="sig-name descname">operator=</code><span class="sig-paren">(</span>array&lt;T, SIZE&gt; &amp;&amp;<em>other</em><span class="sig-paren">)</span><br /></dt>
<dd><p>This array will point to the share memory segment pointed at by other; and will have same value for multprocess_safe and clear_on_destruction. </p>
<p>Warning: even if other.clear_on_destruction is true, the segment memory will not be wiped on the destruction of other. The duty of deleting the shared memory is passed to the new instance, so to speak </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3setE4uintRK1T">
<span id="_CPPv3N5array3setE4uintRK1T"></span><span id="_CPPv2N5array3setE4uintRK1T"></span><span id="array::set__uint.TCR"></span><span class="target" id="classshared__memory_1_1array_1ac413bc76d199bb52a0f95faff7222f37"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>uint <em>index</em>, <em class="property">const</em> T &amp;<em>t</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set element t at index </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3setE4uintPK1T">
<span id="_CPPv3N5array3setE4uintPK1T"></span><span id="_CPPv2N5array3setE4uintPK1T"></span><span id="array::set__uint.TCP"></span><span class="target" id="classshared__memory_1_1array_1ae581f4ffcf1e543032e0128be5da181d"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>uint <em>index</em>, <em class="property">const</em> T *<em>t</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set element t at index </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3getE4uintR1T">
<span id="_CPPv3N5array3getE4uintR1T"></span><span id="_CPPv2N5array3getE4uintR1T"></span><span id="array::get__uint.TR"></span><span class="target" id="classshared__memory_1_1array_1ae16ed72c9590631e608de8bacf1368ba"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>uint <em>index</em>, T &amp;<em>t</em><span class="sig-paren">)</span><br /></dt>
<dd><p>read element at index into t </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3getE4uintP1T">
<span id="_CPPv3N5array3getE4uintP1T"></span><span id="_CPPv2N5array3getE4uintP1T"></span><span id="array::get__uint.TP"></span><span class="target" id="classshared__memory_1_1array_1ad700d5874d92def07f77f4da7f31f980"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>uint <em>index</em>, T *<em>t</em><span class="sig-paren">)</span><br /></dt>
<dd><p>read element at index into t </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5array4sizeEv">
<span id="_CPPv3NK5array4sizeEv"></span><span id="_CPPv2NK5array4sizeEv"></span><span id="array::sizeC"></span><span class="target" id="classshared__memory_1_1array_1afc0dd0c59873934b082e524adb6bf2d7"></span>std::size_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>max number of elements in the array </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array5printEv">
<span id="_CPPv3N5array5printEv"></span><span id="_CPPv2N5array5printEv"></span><span id="array::print"></span><span class="target" id="classshared__memory_1_1array_1a9e912e143886359921c04fdbba7f6cba"></span>void <code class="sig-name descname">print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>print in terminal info about array’s memory usage </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5array7get_rawEv">
<span id="_CPPv3N5array7get_rawEv"></span><span id="_CPPv2N5array7get_rawEv"></span><span id="array::get_raw"></span><span class="target" id="classshared__memory_1_1array_1a20e27fb6b9a18e252368c4f6118b3d27"></span>void *<code class="sig-name descname">get_raw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5array4initE11FUNDAMENTAL">
<span id="_CPPv3N5array4initE11FUNDAMENTAL"></span><span id="_CPPv2N5array4initE11FUNDAMENTAL"></span><span id="array::init__FUNDAMENTAL"></span><span class="target" id="classshared__memory_1_1array_1a41258d788855ccc8435efb2017bdd068"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span>FUNDAMENTAL<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3setE4uintRK1T11FUNDAMENTAL">
<span id="_CPPv3N5array3setE4uintRK1T11FUNDAMENTAL"></span><span id="_CPPv2N5array3setE4uintRK1T11FUNDAMENTAL"></span><span id="array::set__uint.TCR.FUNDAMENTAL"></span><span class="target" id="classshared__memory_1_1array_1ad7fa6301507f10efe97ce3ad40187d9f"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>uint <em>index</em>, <em class="property">const</em> T &amp;<em>t</em>, FUNDAMENTAL<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3getE4uintR1T11FUNDAMENTAL">
<span id="_CPPv3N5array3getE4uintR1T11FUNDAMENTAL"></span><span id="_CPPv2N5array3getE4uintR1T11FUNDAMENTAL"></span><span id="array::get__uint.TR.FUNDAMENTAL"></span><span class="target" id="classshared__memory_1_1array_1a0a54a689331205da7338f7c5891a6ee5"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>uint <em>index</em>, T &amp;<em>t</em>, FUNDAMENTAL<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array4initE17FUNDAMENTAL_ARRAY">
<span id="_CPPv3N5array4initE17FUNDAMENTAL_ARRAY"></span><span id="_CPPv2N5array4initE17FUNDAMENTAL_ARRAY"></span><span id="array::init__FUNDAMENTAL_ARRAY"></span><span class="target" id="classshared__memory_1_1array_1ac0e57adf8e47afae3f8053c20c3e15f2"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span>FUNDAMENTAL_ARRAY<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3setE4uintRK1T17FUNDAMENTAL_ARRAY">
<span id="_CPPv3N5array3setE4uintRK1T17FUNDAMENTAL_ARRAY"></span><span id="_CPPv2N5array3setE4uintRK1T17FUNDAMENTAL_ARRAY"></span><span id="array::set__uint.TCR.FUNDAMENTAL_ARRAY"></span><span class="target" id="classshared__memory_1_1array_1a71bbc60da4a88fd51b3124cdb6cd1ae3"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>uint <em>index</em>, <em class="property">const</em> T &amp;<em>t</em>, FUNDAMENTAL_ARRAY<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3getE4uintR1T17FUNDAMENTAL_ARRAY">
<span id="_CPPv3N5array3getE4uintR1T17FUNDAMENTAL_ARRAY"></span><span id="_CPPv2N5array3getE4uintR1T17FUNDAMENTAL_ARRAY"></span><span id="array::get__uint.TR.FUNDAMENTAL_ARRAY"></span><span class="target" id="classshared__memory_1_1array_1af12c8f76fc48b3ec1ff2c2c82d104837"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>uint <em>index</em>, T &amp;<em>t</em>, FUNDAMENTAL_ARRAY<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array4initE12SERIALIZABLE">
<span id="_CPPv3N5array4initE12SERIALIZABLE"></span><span id="_CPPv2N5array4initE12SERIALIZABLE"></span><span id="array::init__SERIALIZABLE"></span><span class="target" id="classshared__memory_1_1array_1a487be484bf27d17f8c7547a57ff995f9"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span>SERIALIZABLE<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3setE4uintRK1T12SERIALIZABLE">
<span id="_CPPv3N5array3setE4uintRK1T12SERIALIZABLE"></span><span id="_CPPv2N5array3setE4uintRK1T12SERIALIZABLE"></span><span id="array::set__uint.TCR.SERIALIZABLE"></span><span class="target" id="classshared__memory_1_1array_1a951c9ca373e942f094910bea57953eb0"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>uint <em>index</em>, <em class="property">const</em> T &amp;<em>t</em>, SERIALIZABLE<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N5array3getE4uintR1T12SERIALIZABLE">
<span id="_CPPv3N5array3getE4uintR1T12SERIALIZABLE"></span><span id="_CPPv2N5array3getE4uintR1T12SERIALIZABLE"></span><span id="array::get__uint.TR.SERIALIZABLE"></span><span class="target" id="classshared__memory_1_1array_1afb0025021b69b790c152c27ef441cd66"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>uint <em>index</em>, T &amp;<em>t</em>, SERIALIZABLE<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory5array16segment_manager_E">
<span id="_CPPv3N13shared_memory5array16segment_manager_E"></span><span id="_CPPv2N13shared_memory5array16segment_manager_E"></span><span id="shared_memory::array::segment_manager___boost::interprocess::managed_shared_memory"></span><span class="target" id="classshared__memory_1_1array_1a43c56477481ae684932b6a03b64d7b67"></span>boost::interprocess::managed_shared_memory <code class="sig-name descname">segment_manager_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5array11segment_id_E">
<span id="_CPPv3N13shared_memory5array11segment_id_E"></span><span id="_CPPv2N13shared_memory5array11segment_id_E"></span><span id="shared_memory::array::segment_id___ss"></span><span class="target" id="classshared__memory_1_1array_1a25a07e97c454f8fb122eb092ab29812c"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5array5size_E">
<span id="_CPPv3N13shared_memory5array5size_E"></span><span id="_CPPv2N13shared_memory5array5size_E"></span><span id="shared_memory::array::size___std::s"></span><span class="target" id="classshared__memory_1_1array_1a1b47b48a2779e766a80403f47404876a"></span>std::size_t <code class="sig-name descname">size_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5array21clear_on_destruction_E">
<span id="_CPPv3N13shared_memory5array21clear_on_destruction_E"></span><span id="_CPPv2N13shared_memory5array21clear_on_destruction_E"></span><span id="shared_memory::array::clear_on_destruction___b"></span><span class="target" id="classshared__memory_1_1array_1afb6fcb395ac52cb9eaaef2882b623d23"></span>bool <code class="sig-name descname">clear_on_destruction_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5array18multiprocess_safe_E">
<span id="_CPPv3N13shared_memory5array18multiprocess_safe_E"></span><span id="_CPPv2N13shared_memory5array18multiprocess_safe_E"></span><span id="shared_memory::array::multiprocess_safe___b"></span><span class="target" id="classshared__memory_1_1array_1a7051346ccb28372b2ea5587714113079"></span>bool <code class="sig-name descname">multiprocess_safe_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5array6mutex_E">
<span id="_CPPv3N13shared_memory5array6mutex_E"></span><span id="_CPPv2N13shared_memory5array6mutex_E"></span><span id="shared_memory::array::mutex___shared_memory::Mutex"></span><span class="target" id="classshared__memory_1_1array_1afaf6604cf5e2c380f86679e1515e6674"></span><a class="reference internal" href="../file/array_8cpp.html#_CPPv413shared_memory" title="shared_memory">shared_memory</a>::<a class="reference internal" href="../class/classshared__memory_1_1_mutex.html#_CPPv4N13shared_memory5MutexE" title="shared_memory::Mutex">Mutex</a> <code class="sig-name descname">mutex_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory17ConditionVariableE">
<span id="_CPPv3N13shared_memory17ConditionVariableE"></span><span id="_CPPv2N13shared_memory17ConditionVariableE"></span><span id="shared_memory::ConditionVariable"></span><span class="target" id="classshared__memory_1_1_condition_variable"></span><em class="property">class </em><code class="sig-name descname">ConditionVariable</code><br /></dt>
<dd><em>#include &lt;condition_variable.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable17ConditionVariableEKNSt6stringEb">
<span id="_CPPv3N13shared_memory17ConditionVariable17ConditionVariableEKNSt6stringEb"></span><span id="_CPPv2N13shared_memory17ConditionVariable17ConditionVariableEKNSt6stringEb"></span><span id="shared_memory::ConditionVariable::ConditionVariable__ssC.b"></span><span class="target" id="classshared__memory_1_1_condition_variable_1ae4b6accfbe98b2e23f9e20789cea46f7"></span><code class="sig-name descname">ConditionVariable</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>object_id</em>, bool <em>clean_memory_on_destruction</em><span class="sig-paren">)</span><br /></dt>
<dd><p>A condition variable shared over the memory The condition variable is cleaned from the memory on destruction if clean_memory_on_destruction is set to true. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariableD0Ev">
<span id="_CPPv3N13shared_memory17ConditionVariableD0Ev"></span><span id="_CPPv2N13shared_memory17ConditionVariableD0Ev"></span><span id="shared_memory::ConditionVariable::~ConditionVariable"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a84ccb3bcc9255cd145d30b3a91db4e2b"></span><code class="sig-name descname">~ConditionVariable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable10notify_allEv">
<span id="_CPPv3N13shared_memory17ConditionVariable10notify_allEv"></span><span id="_CPPv2N13shared_memory17ConditionVariable10notify_allEv"></span><span id="shared_memory::ConditionVariable::notify_all"></span><span class="target" id="classshared__memory_1_1_condition_variable_1abc70cd1401f40e23ca4a6afb33f28bb5"></span>void <code class="sig-name descname">notify_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>notify_all is notifying all condition variables with the same mutex </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable10notify_oneEv">
<span id="_CPPv3N13shared_memory17ConditionVariable10notify_oneEv"></span><span id="_CPPv2N13shared_memory17ConditionVariable10notify_oneEv"></span><span id="shared_memory::ConditionVariable::notify_one"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a8953b054a1074ab5ef0a9f9b35f58a42"></span>void <code class="sig-name descname">notify_one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>notify_one notifies one condition variable with the same mutex </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable10timed_waitER4Lockl">
<span id="_CPPv3N13shared_memory17ConditionVariable10timed_waitER4Lockl"></span><span id="_CPPv2N13shared_memory17ConditionVariable10timed_waitER4Lockl"></span><span id="shared_memory::ConditionVariable::timed_wait__LockR.l"></span><span class="target" id="classshared__memory_1_1_condition_variable_1af7b1ce584ff9ef9a0925f57cae8e6263"></span>bool <code class="sig-name descname">timed_wait</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1_lock.html#_CPPv4N13shared_memory4LockE" title="shared_memory::Lock">Lock</a> &amp;<em>lock</em>, long <em>wait_nano_seconds</em><span class="sig-paren">)</span><br /></dt>
<dd><p>timed_wait wait a notify during a certain certain time and then wake up </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true: the condition variable has been notified, false otherwize </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wait_duration</span></code>: in microsecond </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable4waitER4Lock">
<span id="_CPPv3N13shared_memory17ConditionVariable4waitER4Lock"></span><span id="_CPPv2N13shared_memory17ConditionVariable4waitER4Lock"></span><span id="shared_memory::ConditionVariable::wait__LockR"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a8746faccdf81b03dd36c5b405c9ab48d"></span>void <code class="sig-name descname">wait</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1_lock.html#_CPPv4N13shared_memory4LockE" title="shared_memory::Lock">Lock</a> &amp;<em>lock</em><span class="sig-paren">)</span><br /></dt>
<dd><p>wait waits until another thread notifies this object </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory17ConditionVariable5cleanEKNSt6stringE">
<span id="_CPPv3N13shared_memory17ConditionVariable5cleanEKNSt6stringE"></span><span id="_CPPv2N13shared_memory17ConditionVariable5cleanEKNSt6stringE"></span><span id="shared_memory::ConditionVariable::clean__ssC"></span><span class="target" id="classshared__memory_1_1_condition_variable_1adf6a90466c2bf96cbc08f3ba0246274e"></span>void <code class="sig-name descname">clean</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory17ConditionVariable13condition_id_E">
<span id="_CPPv3N13shared_memory17ConditionVariable13condition_id_E"></span><span id="_CPPv2N13shared_memory17ConditionVariable13condition_id_E"></span><span id="shared_memory::ConditionVariable::condition_id___ss"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a496feeef1a7fec080435b68a79bc163d"></span>std::string <code class="sig-name descname">condition_id_</code><br /></dt>
<dd><p>condition_id_ is the condition variable name in the shared memory </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory17ConditionVariable28clean_memory_on_destruction_E">
<span id="_CPPv3N13shared_memory17ConditionVariable28clean_memory_on_destruction_E"></span><span id="_CPPv2N13shared_memory17ConditionVariable28clean_memory_on_destruction_E"></span><span id="shared_memory::ConditionVariable::clean_memory_on_destruction___b"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a872a5c9305c0dff22ec085b8c8306a0d"></span>bool <code class="sig-name descname">clean_memory_on_destruction_</code><br /></dt>
<dd><p>if true (the default), clean the shared memory of the hosted mutex and condition. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory17ConditionVariable19condition_variable_E">
<span id="_CPPv3N13shared_memory17ConditionVariable19condition_variable_E"></span><span id="_CPPv2N13shared_memory17ConditionVariable19condition_variable_E"></span><span id="shared_memory::ConditionVariable::condition_variable___SHMConditionP"></span><span class="target" id="classshared__memory_1_1_condition_variable_1a37c6e1a6ca44d30c2a29990e4460803b"></span><a class="reference internal" href="../file/condition__variable_8hpp.html#_CPPv4N13shared_memory12SHMConditionE" title="shared_memory::SHMCondition">SHMCondition</a> *<code class="sig-name descname">condition_variable_</code><br /></dt>
<dd><p>condition_variable_ is the boost condition variable that is used </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory17ConditionVariable9mutex_id_E">
<span id="_CPPv3N13shared_memory17ConditionVariable9mutex_id_E"></span><span id="_CPPv2N13shared_memory17ConditionVariable9mutex_id_E"></span><span id="shared_memory::ConditionVariable::mutex_id___ss"></span><span class="target" id="classshared__memory_1_1_condition_variable_1ab8221877ff8551e608d5d4691d3679ae"></span>std::string <code class="sig-name descname">mutex_id_</code><br /></dt>
<dd><p>mutex_id_ is the mutex name in the shared memory </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0_iEN13shared_memory25Exchange_manager_consumerE">
<span id="_CPPv3I0_iEN13shared_memory25Exchange_manager_consumerE"></span><span id="_CPPv2I0_iEN13shared_memory25Exchange_manager_consumerE"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer"></span>template&lt;class <code class="sig-name descname">Serializable</code>, int <code class="sig-name descname">QUEUE_SIZE</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Exchange_manager_consumer</code><br /></dt>
<dd><em>#include &lt;exchange_manager_consumer.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer25Exchange_manager_consumerENSt6stringENSt6stringEbb">
<span id="_CPPv3N25Exchange_manager_consumer25Exchange_manager_consumerENSt6stringENSt6stringEbb"></span><span id="_CPPv2N25Exchange_manager_consumer25Exchange_manager_consumerENSt6stringENSt6stringEbb"></span><span id="Exchange_manager_consumer::Exchange_manager_consumer__ss.ss.b.b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a15b2b91e57fb8c9c60ec354274edf20d"></span><code class="sig-name descname">Exchange_manager_consumer</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, std::string <em>object_id</em>, bool <em>leading</em>, bool <em>autolock</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>An exchange_manager_consumer reads from the shared memory serialized items produced by an instance of exchange_manager_producer (which should use the same segment_id and object_id), possibly running in a separate process. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: id of the shared memory segment </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">object_id</span></code>: id of the shared memory object prefix </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">the</span></code>: consumer is to be “permanent”, while different producers may provide data. Implies the deletion of the underlying share memory upon destruction. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mutex</span></code>: locking mechanism internally managed by the producer. If false, lock has to be “manually” called. This allows for example to set several items in one shot </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumerD0Ev">
<span id="_CPPv3N25Exchange_manager_consumerD0Ev"></span><span id="_CPPv2N25Exchange_manager_consumerD0Ev"></span><span id="Exchange_manager_consumer::~Exchange_manager_consumer"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a163df4d7e66a1cae7d0b0cb5f7692c59"></span><code class="sig-name descname">~Exchange_manager_consumer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer4lockEv">
<span id="_CPPv3N25Exchange_manager_consumer4lockEv"></span><span id="_CPPv2N25Exchange_manager_consumer4lockEv"></span><span id="Exchange_manager_consumer::lock"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a1ec59bb41c9de78eb891ea70efe6b8c2"></span>void <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>lock the mutex required for writting in the shared memory without any collision with any producer. </p>
<p>Should be called before calls to “consume”. Not required if the constructor was called with autolock set to true </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer6unlockEv">
<span id="_CPPv3N25Exchange_manager_consumer6unlockEv"></span><span id="_CPPv2N25Exchange_manager_consumer6unlockEv"></span><span id="Exchange_manager_consumer::unlock"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1aaf053702ec1ef8455fc10e70144f6923"></span>void <code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>unlock the mutex for writting in the shared memory without any collision with any producer. </p>
<p>Not required if the constructor was called with autolock set to true </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer7consumeER12Serializable">
<span id="_CPPv3N25Exchange_manager_consumer7consumeER12Serializable"></span><span id="_CPPv2N25Exchange_manager_consumer7consumeER12Serializable"></span><span id="Exchange_manager_consumer::consume__SerializableR"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1ae3e006de034b55e328784d3eacfb1772"></span>bool <code class="sig-name descname">consume</code><span class="sig-paren">(</span>Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>read from the underlying shared memory a serialized object (set by a producer). </p>
<p>Should be called only if ready_to_consume returns true. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if an item has been read </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer16ready_to_consumeEv">
<span id="_CPPv3N25Exchange_manager_consumer16ready_to_consumeEv"></span><span id="_CPPv2N25Exchange_manager_consumer16ready_to_consumeEv"></span><span id="Exchange_manager_consumer::ready_to_consume"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1af1a894d796387d297f848d18d8d55df5"></span>bool <code class="sig-name descname">ready_to_consume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>returns true if a producer is also running. </p>
<p>‘consume’ should be called only if ready_to_consume returns true. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer15purge_feedbacksEv">
<span id="_CPPv3N25Exchange_manager_consumer15purge_feedbacksEv"></span><span id="_CPPv2N25Exchange_manager_consumer15purge_feedbacksEv"></span><span id="Exchange_manager_consumer::purge_feedbacks"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a5e62220c9b50327130cb95683d22b0dc"></span>bool <code class="sig-name descname">purge_feedbacks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). </p>
<p>This shared queue may get full (e.g the producer does not read it fast enough), in which case the item id is buffered in this instance. If this instance stops to consume, the buffered item ids will never be written in the shared queue, and the producer will not receive the corresponding feedback. This attempts to write the buffered ids into the queue, and returns true if the buffer is not empty after the call (i.e. some feedbacks have not been sent yet), false otherwise. Usage: to call before exit until true is returned </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer12nb_char_readEv">
<span id="_CPPv3N25Exchange_manager_consumer12nb_char_readEv"></span><span id="_CPPv2N25Exchange_manager_consumer12nb_char_readEv"></span><span id="Exchange_manager_consumer::nb_char_read"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1ab8651cff750b5cb2ceae97a97b2c7f2d"></span>int <code class="sig-name descname">nb_char_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>returns the number of char that have been read from the exchange queue. </p>
<p>For debugging purposes </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK25Exchange_manager_consumer23is_producer_queue_emptyEv">
<span id="_CPPv3NK25Exchange_manager_consumer23is_producer_queue_emptyEv"></span><span id="_CPPv2NK25Exchange_manager_consumer23is_producer_queue_emptyEv"></span><span id="Exchange_manager_consumer::is_producer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1ad7d4cd68db87b53a0fe45f08c4adb647"></span>bool <code class="sig-name descname">is_producer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK25Exchange_manager_consumer23is_consumer_queue_emptyEv">
<span id="_CPPv3NK25Exchange_manager_consumer23is_consumer_queue_emptyEv"></span><span id="_CPPv2NK25Exchange_manager_consumer23is_consumer_queue_emptyEv"></span><span id="Exchange_manager_consumer::is_consumer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a5d50ce37fd9464f45b973f6e96b81ba3"></span>bool <code class="sig-name descname">is_consumer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer11clean_mutexENSt6stringE">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer11clean_mutexENSt6stringE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer11clean_mutexENSt6stringE"></span><span id="shared_memory::Exchange_manager_consumer::clean_mutex__ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a5aeebd5f2857f73c91fe3212d274909e"></span><em class="property">static</em> void <code class="sig-name descname">clean_mutex</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer12clean_memoryENSt6stringE">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer12clean_memoryENSt6stringE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer12clean_memoryENSt6stringE"></span><span id="shared_memory::Exchange_manager_consumer::clean_memory__ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a828a56d15a0f68edd8e3b395c41b0c0c"></span><em class="property">static</em> void <code class="sig-name descname">clean_memory</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Types</p>
<dl class="type">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer6MemoryE">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer6MemoryE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer6MemoryE"></span><span id="shared_memory::Exchange_manager_consumer::Memory"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a1699ba86d1d5b943d428fc1b391abd42"></span><em class="property">typedef </em>Exchange_manager_memory&lt;Serializable, QUEUE_SIZE&gt; <code class="sig-name descname">Memory</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer10Memory_ptrE">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer10Memory_ptrE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer10Memory_ptrE"></span><span id="shared_memory::Exchange_manager_consumer::Memory_ptr"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a92ad5c787b53c26d5b3c75712ca539f3"></span><em class="property">typedef </em>std::shared_ptr&lt;<a class="reference internal" href="../class/classshared__memory_1_1_exchange__manager__consumer.html#_CPPv4N13shared_memory25Exchange_manager_consumer6MemoryE" title="shared_memory::Exchange_manager_consumer::Memory">Memory</a>&gt; <code class="sig-name descname">Memory_ptr</code><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N25Exchange_manager_consumer5resetEv">
<span id="_CPPv3N25Exchange_manager_consumer5resetEv"></span><span id="_CPPv2N25Exchange_manager_consumer5resetEv"></span><span id="Exchange_manager_consumer::reset"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a7543d28030c9c3e17b8fd60facc917b2"></span>void <code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer7memory_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer7memory_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer7memory_E"></span><span id="shared_memory::Exchange_manager_consumer::memory___Memory_ptr"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a65f7ea81649be03ac11b11bc998d5047"></span><a class="reference internal" href="../class/classshared__memory_1_1_exchange__manager__consumer.html#_CPPv4N13shared_memory25Exchange_manager_consumer10Memory_ptrE" title="shared_memory::Exchange_manager_consumer::Memory_ptr">Memory_ptr</a> <code class="sig-name descname">memory_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer8leading_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer8leading_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer8leading_E"></span><span id="shared_memory::Exchange_manager_consumer::leading___b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a3d2838c1a3e709dafe1c941f217d8f54"></span>bool <code class="sig-name descname">leading_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer9autolock_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer9autolock_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer9autolock_E"></span><span id="shared_memory::Exchange_manager_consumer::autolock___b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a6ea7ce15b0da981027f80d3d35825593"></span>bool <code class="sig-name descname">autolock_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer11segment_id_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer11segment_id_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer11segment_id_E"></span><span id="shared_memory::Exchange_manager_consumer::segment_id___ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1a830f88a2c6f6d3cf6e0c83353a436742"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_consumer10object_id_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_consumer10object_id_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_consumer10object_id_E"></span><span id="shared_memory::Exchange_manager_consumer::object_id___ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__consumer_1afbde973522ab55b0a3c49ef6f26fbba5"></span>std::string <code class="sig-name descname">object_id_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0_iEN13shared_memory25Exchange_manager_producerE">
<span id="_CPPv3I0_iEN13shared_memory25Exchange_manager_producerE"></span><span id="_CPPv2I0_iEN13shared_memory25Exchange_manager_producerE"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer"></span>template&lt;class <code class="sig-name descname">Serializable</code>, int <code class="sig-name descname">QUEUE_SIZE</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Exchange_manager_producer</code><br /></dt>
<dd><em>#include &lt;exchange_manager_producer.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer25Exchange_manager_producerENSt6stringENSt6stringEbb">
<span id="_CPPv3N25Exchange_manager_producer25Exchange_manager_producerENSt6stringENSt6stringEbb"></span><span id="_CPPv2N25Exchange_manager_producer25Exchange_manager_producerENSt6stringENSt6stringEbb"></span><span id="Exchange_manager_producer::Exchange_manager_producer__ss.ss.b.b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a3fb01ae44f85b9d8b4a22137f2da90f1"></span><code class="sig-name descname">Exchange_manager_producer</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, std::string <em>object_id</em>, bool <em>leading</em>, bool <em>autolock</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>An exchange_manager_producer writes in the shared memory serialized items expected to be consumed by an instance of exchange_manager_consumer (which should use the same segment_id and object_id), possibly running in a separate process. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_id</span></code>: id of the shared memory segment </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">object_id</span></code>: id of the shared memory object prefix </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">autolock</span></code>: mutex locking mechanism internally managed by the producer. If false, lock has to be “manually” called. This allows for example to set several items in one shot </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clean_memory_on_exit.</span></code>: If true, the destructor will clean the underlined shared memory items. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producerD0Ev">
<span id="_CPPv3N25Exchange_manager_producerD0Ev"></span><span id="_CPPv2N25Exchange_manager_producerD0Ev"></span><span id="Exchange_manager_producer::~Exchange_manager_producer"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a2facf670e12bfea1d7c4900f3ffae7d7"></span><code class="sig-name descname">~Exchange_manager_producer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer16ready_to_produceEv">
<span id="_CPPv3N25Exchange_manager_producer16ready_to_produceEv"></span><span id="_CPPv2N25Exchange_manager_producer16ready_to_produceEv"></span><span id="Exchange_manager_producer::ready_to_produce"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a3ef5cfdd196a396edfd6ca502119f839"></span>bool <code class="sig-name descname">ready_to_produce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>returns true if a consumer is also running. </p>
<p>‘set’ should be called only if ready_to_produce returns true. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer4lockEv">
<span id="_CPPv3N25Exchange_manager_producer4lockEv"></span><span id="_CPPv2N25Exchange_manager_producer4lockEv"></span><span id="Exchange_manager_producer::lock"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1aa39c8b921eeff081111c756bd6d2ca3d"></span>void <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>lock the mutex required for writting in the shared memory without any collision with any consumer. </p>
<p>Should be called before calls to “set”. Not required if the constructor was called with autolock set to true </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer6unlockEv">
<span id="_CPPv3N25Exchange_manager_producer6unlockEv"></span><span id="_CPPv2N25Exchange_manager_producer6unlockEv"></span><span id="Exchange_manager_producer::unlock"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a9c02040ee5ef8db658f3112ae4b3b969"></span>void <code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>unlock the mutex for writting in the shared memory without any collision with any consumer. </p>
<p>Not required if the constructor was called with autolock set to true </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer3setERK12Serializable">
<span id="_CPPv3N25Exchange_manager_producer3setERK12Serializable"></span><span id="_CPPv2N25Exchange_manager_producer3setERK12Serializable"></span><span id="Exchange_manager_producer::set__SerializableCR"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a0f86798dbbb5bead856c566257bd1b07"></span>bool <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set this serializable to be consumed. </p>
<p>Throws <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_memory__overflow__exception"><span class="std std-ref">shared_memory::Memory_overflow_exception</span></a> if the shared memory is full. Some of the shared memory should get free once items have been consumed by a consumer. This method should be called only if ‘ready_to_produce’ returns true; Returns true if all data could be written in the shared memory, false if some data required to be buffered (any following call to set, if any, will perform a new attempt to write remaining buffer to the shared memory) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer5clearEv">
<span id="_CPPv3N25Exchange_manager_producer5clearEv"></span><span id="_CPPv2N25Exchange_manager_producer5clearEv"></span><span id="Exchange_manager_producer::clear"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a733c4c3f794e10590569f94e3f320201"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>removed all elements from the shared queue </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer3getERNSt5dequeIiEE">
<span id="_CPPv3N25Exchange_manager_producer3getERNSt5dequeIiEE"></span><span id="_CPPv2N25Exchange_manager_producer3getERNSt5dequeIiEE"></span><span id="Exchange_manager_producer::get__std::deque:i:R"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1afd8afb25d70407b785484e68d1182c0b"></span>void <code class="sig-name descname">get</code><span class="sig-paren">(</span>std::deque&lt;int&gt; &amp;<em>get_consumed_ids</em><span class="sig-paren">)</span><br /></dt>
<dd><p>write into get_consumed_ids the ids of serialized items that have been successfully consumed by a consumer </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer15nb_char_writtenEv">
<span id="_CPPv3N25Exchange_manager_producer15nb_char_writtenEv"></span><span id="_CPPv2N25Exchange_manager_producer15nb_char_writtenEv"></span><span id="Exchange_manager_producer::nb_char_written"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1ab31e6b87ad4c856736dec15486ed4489"></span>int <code class="sig-name descname">nb_char_written</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>returns the number of characters that have been serialized and written to the exchange queue. </p>
<p>For debug purposes. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer16reset_char_countEv">
<span id="_CPPv3N25Exchange_manager_producer16reset_char_countEv"></span><span id="_CPPv2N25Exchange_manager_producer16reset_char_countEv"></span><span id="Exchange_manager_producer::reset_char_count"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a742e8859608d49901d3dafbbe08e4674"></span>void <code class="sig-name descname">reset_char_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>reset the count of characters written to the exchange queue to zero </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK25Exchange_manager_producer20producer_queue_emptyEv">
<span id="_CPPv3NK25Exchange_manager_producer20producer_queue_emptyEv"></span><span id="_CPPv2NK25Exchange_manager_producer20producer_queue_emptyEv"></span><span id="Exchange_manager_producer::producer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a32172d2cbf30e1bcb2a45778063e6ff2"></span>bool <code class="sig-name descname">producer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK25Exchange_manager_producer20consumer_queue_emptyEv">
<span id="_CPPv3NK25Exchange_manager_producer20consumer_queue_emptyEv"></span><span id="_CPPv2NK25Exchange_manager_producer20consumer_queue_emptyEv"></span><span id="Exchange_manager_producer::consumer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a208c79c39c9206b22aecb919eb0df87e"></span>bool <code class="sig-name descname">consumer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer11clean_mutexENSt6stringE">
<span id="_CPPv3N25Exchange_manager_producer11clean_mutexENSt6stringE"></span><span id="_CPPv2N25Exchange_manager_producer11clean_mutexENSt6stringE"></span><span id="Exchange_manager_producer::clean_mutex__ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1af98fe4321e1fd280b509f5dfd2cf4a5b"></span>void <code class="sig-name descname">clean_mutex</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>(unlock) and erase the mutex from the shared memory. </p>
<p>To be used if some executable using the exchange manager crashed without calls to destructors. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer12clean_memoryENSt6stringE">
<span id="_CPPv3N25Exchange_manager_producer12clean_memoryENSt6stringE"></span><span id="_CPPv2N25Exchange_manager_producer12clean_memoryENSt6stringE"></span><span id="Exchange_manager_producer::clean_memory__ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a8574f4e075d6f755e567d21d04f24aab"></span>void <code class="sig-name descname">clean_memory</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>wipe out the corresponding shared memory. </p>
<p>To be used if some executable using the exchange manager crashed without calls to destructors. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Types</p>
<dl class="type">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer6MemoryE">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer6MemoryE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer6MemoryE"></span><span id="shared_memory::Exchange_manager_producer::Memory"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a65119cf07c0c10f167c191c9ee913029"></span><em class="property">typedef </em>Exchange_manager_memory&lt;Serializable, QUEUE_SIZE&gt; <code class="sig-name descname">Memory</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer10Memory_ptrE">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer10Memory_ptrE"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer10Memory_ptrE"></span><span id="shared_memory::Exchange_manager_producer::Memory_ptr"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a7f3d7760ca2d1c01fa88e7a6447a38d7"></span><em class="property">typedef </em>std::shared_ptr&lt;<a class="reference internal" href="../class/classshared__memory_1_1_exchange__manager__producer.html#_CPPv4N13shared_memory25Exchange_manager_producer6MemoryE" title="shared_memory::Exchange_manager_producer::Memory">Memory</a>&gt; <code class="sig-name descname">Memory_ptr</code><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N25Exchange_manager_producer5resetEv">
<span id="_CPPv3N25Exchange_manager_producer5resetEv"></span><span id="_CPPv2N25Exchange_manager_producer5resetEv"></span><span id="Exchange_manager_producer::reset"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a2148cfb2e9a1973089d81237ea5735b9"></span>void <code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer7memory_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer7memory_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer7memory_E"></span><span id="shared_memory::Exchange_manager_producer::memory___Memory_ptr"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a67f2a2c049dabace06c85a35335d1614"></span><a class="reference internal" href="../class/classshared__memory_1_1_exchange__manager__producer.html#_CPPv4N13shared_memory25Exchange_manager_producer10Memory_ptrE" title="shared_memory::Exchange_manager_producer::Memory_ptr">Memory_ptr</a> <code class="sig-name descname">memory_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer9autolock_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer9autolock_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer9autolock_E"></span><span id="shared_memory::Exchange_manager_producer::autolock___b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a6d89b939f08bbb9180460a0fab2c877f"></span>bool <code class="sig-name descname">autolock_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer8leading_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer8leading_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer8leading_E"></span><span id="shared_memory::Exchange_manager_producer::leading___b"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a4c71d725b7b95e4dd00ecf68232d4ac9"></span>bool <code class="sig-name descname">leading_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer11segment_id_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer11segment_id_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer11segment_id_E"></span><span id="shared_memory::Exchange_manager_producer::segment_id___ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a96ce58e9619ac28b31b46a81c53c20c2"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory25Exchange_manager_producer10object_id_E">
<span id="_CPPv3N13shared_memory25Exchange_manager_producer10object_id_E"></span><span id="_CPPv2N13shared_memory25Exchange_manager_producer10object_id_E"></span><span id="shared_memory::Exchange_manager_producer::object_id___ss"></span><span class="target" id="classshared__memory_1_1_exchange__manager__producer_1a57ea2e6076963223331f3b6e78cbbc05"></span>std::string <code class="sig-name descname">object_id_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory15Four_int_valuesE">
<span id="_CPPv3N13shared_memory15Four_int_valuesE"></span><span id="_CPPv2N13shared_memory15Four_int_valuesE"></span><span id="shared_memory::Four_int_values"></span><span class="target" id="classshared__memory_1_1_four__int__values"></span><em class="property">class </em><code class="sig-name descname">Four_int_values</code><br /></dt>
<dd><em>#include &lt;four_int_values.hpp&gt;</em><p>Example of an instance that can be serialized. </p>
<p>Notice: There is a default constructor There is a serialize function It is friend to private_serialization </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory15Four_int_values15Four_int_valuesEv">
<span id="_CPPv3N13shared_memory15Four_int_values15Four_int_valuesEv"></span><span id="_CPPv2N13shared_memory15Four_int_values15Four_int_valuesEv"></span><span id="shared_memory::Four_int_values::Four_int_values"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a35c095af4c094328e46fc5ffd274bdf9"></span><code class="sig-name descname">Four_int_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Four_int_values15Four_int_valuesEiiii">
<span id="_CPPv3N13shared_memory15Four_int_values15Four_int_valuesEiiii"></span><span id="_CPPv2N13shared_memory15Four_int_values15Four_int_valuesEiiii"></span><span id="shared_memory::Four_int_values::Four_int_values__i.i.i.i"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a28e7fda257450d7650926ae4cec8ea21"></span><code class="sig-name descname">Four_int_values</code><span class="sig-paren">(</span>int <em>a</em>, int <em>b</em>, int <em>c</em>, int <em>d</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory15Four_int_values6get_idEv">
<span id="_CPPv3NK13shared_memory15Four_int_values6get_idEv"></span><span id="_CPPv2NK13shared_memory15Four_int_values6get_idEv"></span><span id="shared_memory::Four_int_values::get_idC"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a9eb6dd806c312fad3d53a56b69a1e998"></span>int <code class="sig-name descname">get_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Four_int_values6set_idEi">
<span id="_CPPv3N13shared_memory15Four_int_values6set_idEi"></span><span id="_CPPv2N13shared_memory15Four_int_values6set_idEi"></span><span id="shared_memory::Four_int_values::set_id__i"></span><span class="target" id="classshared__memory_1_1_four__int__values_1aa9904f00f9ae680bab360954e5f3f7a9"></span>void <code class="sig-name descname">set_id</code><span class="sig-paren">(</span>int <em>id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory15Four_int_values9serializeEvR7Archive">
<span id="_CPPv3I0EN13shared_memory15Four_int_values9serializeER7Archive"></span><span id="_CPPv2I0EN13shared_memory15Four_int_values9serializeER7Archive"></span><span class="target" id="classshared__memory_1_1_four__int__values_1ae19116850c04d24ce74dc28bd9cbcf39"></span>template&lt;class <code class="sig-name descname">Archive</code>&gt;<br />void <code class="sig-name descname">serialize</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1_four__int__values.html#_CPPv4I0EN13shared_memory15Four_int_values9serializeEvR7Archive" title="shared_memory::Four_int_values::serialize::Archive">Archive</a> &amp;<em>archive</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory15Four_int_values5equalERK15Four_int_values">
<span id="_CPPv3NK13shared_memory15Four_int_values5equalERK15Four_int_values"></span><span id="_CPPv2NK13shared_memory15Four_int_values5equalERK15Four_int_values"></span><span id="shared_memory::Four_int_values::equal__Four_int_valuesCRC"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a5b9e19983f81b1de322b9342eb10630b"></span>bool <code class="sig-name descname">equal</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../class/classshared__memory_1_1_four__int__values.html#_CPPv4N13shared_memory15Four_int_valuesE" title="shared_memory::Four_int_values">Four_int_values</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory15Four_int_values4sameERK15Four_int_values">
<span id="_CPPv3NK13shared_memory15Four_int_values4sameERK15Four_int_values"></span><span id="_CPPv2NK13shared_memory15Four_int_values4sameERK15Four_int_values"></span><span id="shared_memory::Four_int_values::same__Four_int_valuesCRC"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a91a3831a5ac3437a52a1dfb0138054d5"></span>bool <code class="sig-name descname">same</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../class/classshared__memory_1_1_four__int__values.html#_CPPv4N13shared_memory15Four_int_valuesE" title="shared_memory::Four_int_values">Four_int_values</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory15Four_int_values5printEv">
<span id="_CPPv3NK13shared_memory15Four_int_values5printEv"></span><span id="_CPPv2NK13shared_memory15Four_int_values5printEv"></span><span id="shared_memory::Four_int_values::printC"></span><span class="target" id="classshared__memory_1_1_four__int__values_1ae21af043113ba3dae775d0a47cccdbe3"></span>void <code class="sig-name descname">print</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt>
<span class="target" id="classshared__memory_1_1_four__int__values_1a692d60e4a7802cad45c215c65632e888"></span><code class="sig-name descname">friend shared_memory::Four_int_values::private_serialization</code></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory15Four_int_values7values_E">
<span id="_CPPv3N13shared_memory15Four_int_values7values_E"></span><span id="_CPPv2N13shared_memory15Four_int_values7values_E"></span><span id="shared_memory::Four_int_values::values___std::vector:i:"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a253eba8afb24a1679013be704b224ea5"></span>std::vector&lt;int&gt; <code class="sig-name descname">values_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory15Four_int_values3id_E">
<span id="_CPPv3N13shared_memory15Four_int_values3id_E"></span><span id="_CPPv2N13shared_memory15Four_int_values3id_E"></span><span id="shared_memory::Four_int_values::id___i"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a2272823a3c672123c022851611640dd1"></span>int <code class="sig-name descname">id_</code><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory15Four_int_values7next_idEv">
<span id="_CPPv3N13shared_memory15Four_int_values7next_idEv"></span><span id="_CPPv2N13shared_memory15Four_int_values7next_idEv"></span><span id="shared_memory::Four_int_values::next_id"></span><span class="target" id="classshared__memory_1_1_four__int__values_1a2b34bc8100ec157982d0c6d7a1df14de"></span>int <code class="sig-name descname">next_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I_iEN13shared_memory4ItemE">
<span id="_CPPv3I_iEN13shared_memory4ItemE"></span><span id="_CPPv2I_iEN13shared_memory4ItemE"></span><span class="target" id="classshared__memory_1_1_item"></span>template&lt;int <code class="sig-name descname">SIZE</code> = 10&gt;<br /><em class="property">class </em><code class="sig-name descname">Item</code><br /></dt>
<dd><em>#include &lt;item.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory4Item4ItemEv">
<span id="_CPPv3N13shared_memory4Item4ItemEv"></span><span id="_CPPv2N13shared_memory4Item4ItemEv"></span><span id="shared_memory::Item::Item"></span><span class="target" id="classshared__memory_1_1_item_1a715466b27d49df56a2d097d15643f043"></span><code class="sig-name descname">Item</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory4Item4ItemEi">
<span id="_CPPv3N13shared_memory4Item4ItemEi"></span><span id="_CPPv2N13shared_memory4Item4ItemEi"></span><span id="shared_memory::Item::Item__i"></span><span class="target" id="classshared__memory_1_1_item_1a6d7d4864fe09b43ec99356e9c0c62b98"></span><code class="sig-name descname">Item</code><span class="sig-paren">(</span>int <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory4Item4fillEi">
<span id="_CPPv3N13shared_memory4Item4fillEi"></span><span id="_CPPv2N13shared_memory4Item4fillEi"></span><span id="shared_memory::Item::fill__i"></span><span class="target" id="classshared__memory_1_1_item_1a765ce924f63067b2df32f4170175611e"></span>void <code class="sig-name descname">fill</code><span class="sig-paren">(</span>int <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory4Item3setEii">
<span id="_CPPv3N13shared_memory4Item3setEii"></span><span id="_CPPv2N13shared_memory4Item3setEii"></span><span id="shared_memory::Item::set__i.i"></span><span class="target" id="classshared__memory_1_1_item_1a7941efea49faeb757864ae273604fd22"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>int <em>index</em>, int <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory4Item3getEv">
<span id="_CPPv3NK13shared_memory4Item3getEv"></span><span id="_CPPv2NK13shared_memory4Item3getEv"></span><span id="shared_memory::Item::getC"></span><span class="target" id="classshared__memory_1_1_item_1ac4d6b35bef7d7ddeee7102cd9a245e50"></span>int <code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory4Item3getEi">
<span id="_CPPv3NK13shared_memory4Item3getEi"></span><span id="_CPPv2NK13shared_memory4Item3getEi"></span><span id="shared_memory::Item::get__iC"></span><span class="target" id="classshared__memory_1_1_item_1abbad388adf21cfb53b84916d10eda23f"></span>int <code class="sig-name descname">get</code><span class="sig-paren">(</span>int <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory4Item9serializeEvR7Archive">
<span id="_CPPv3I0EN13shared_memory4Item9serializeER7Archive"></span><span id="_CPPv2I0EN13shared_memory4Item9serializeER7Archive"></span><span class="target" id="classshared__memory_1_1_item_1ab48965377a911cf7b625926759b4e0f9"></span>template&lt;class <code class="sig-name descname">Archive</code>&gt;<br />void <code class="sig-name descname">serialize</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1_item.html#_CPPv4I0EN13shared_memory4Item9serializeEvR7Archive" title="shared_memory::Item::serialize::Archive">Archive</a> &amp;<em>archive</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory4Item13compact_printEv">
<span id="_CPPv3NK13shared_memory4Item13compact_printEv"></span><span id="_CPPv2NK13shared_memory4Item13compact_printEv"></span><span id="shared_memory::Item::compact_printC"></span><span class="target" id="classshared__memory_1_1_item_1ad3ca702e477914370c16f19a77d799b5"></span>void <code class="sig-name descname">compact_print</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory4Item5printEv">
<span id="_CPPv3NK13shared_memory4Item5printEv"></span><span id="_CPPv2NK13shared_memory4Item5printEv"></span><span id="shared_memory::Item::printC"></span><span class="target" id="classshared__memory_1_1_item_1a3ff278246a9cb6a7c14f0b0b9370f2a7"></span>void <code class="sig-name descname">print</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory4Item2a_E">
<span id="_CPPv3N13shared_memory4Item2a_E"></span><span id="_CPPv2N13shared_memory4Item2a_E"></span><span id="shared_memory::Item::a___std::array:i.SIZE:"></span><span class="target" id="classshared__memory_1_1_item_1a3cb46d7a9776f0512cc8c3689278440b"></span>std::array&lt;int, SIZE&gt; <code class="sig-name descname">a_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory4Item2v_E">
<span id="_CPPv3N13shared_memory4Item2v_E"></span><span id="_CPPv2N13shared_memory4Item2v_E"></span><span id="shared_memory::Item::v___i"></span><span class="target" id="classshared__memory_1_1_item_1acd5944f0e62324ef0dc71b91ef9d7054"></span>int <code class="sig-name descname">v_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory4LockE">
<span id="_CPPv3N13shared_memory4LockE"></span><span id="_CPPv2N13shared_memory4LockE"></span><span id="shared_memory::Lock"></span><span class="target" id="classshared__memory_1_1_lock"></span><em class="property">class </em><code class="sig-name descname">Lock</code><br /></dt>
<dd><em>#include &lt;lock.hpp&gt;</em><p>A scope lock object for locking a shared memory mutex, to use for example with a shared memory condition variable. </p>
<p>The scope is unlocked on destruction. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory4Lock4LockER5Mutex">
<span id="_CPPv3N13shared_memory4Lock4LockER5Mutex"></span><span id="_CPPv2N13shared_memory4Lock4LockER5Mutex"></span><span id="shared_memory::Lock::Lock__MutexR"></span><span class="target" id="classshared__memory_1_1_lock_1aacd7b7ee828e6a83bf18497ea7e33d70"></span><code class="sig-name descname">Lock</code><span class="sig-paren">(</span><a class="reference internal" href="../class/classshared__memory_1_1_mutex.html#_CPPv4N13shared_memory5MutexE" title="shared_memory::Mutex">Mutex</a> &amp;<em>mutex</em><span class="sig-paren">)</span><br /></dt>
<dd><p>lock the mutex </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt>
<span class="target" id="classshared__memory_1_1_lock_1ab376f06fa4c31a6b2352f307f2bfe007"></span><code class="sig-name descname">friend shared_memory::Lock::ConditionVariable</code></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory4Lock5lock_E">
<span id="_CPPv3N13shared_memory4Lock5lock_E"></span><span id="_CPPv2N13shared_memory4Lock5lock_E"></span><span id="shared_memory::Lock::lock___SHMScopeLock"></span><span class="target" id="classshared__memory_1_1_lock_1aa97f73af624861f63cb827b8f8a082f2"></span><a class="reference internal" href="../file/lock_8hpp.html#_CPPv4N13shared_memory12SHMScopeLockE" title="shared_memory::SHMScopeLock">SHMScopeLock</a> <code class="sig-name descname">lock_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory23LockedConditionVariableE">
<span id="_CPPv3N13shared_memory23LockedConditionVariableE"></span><span id="_CPPv2N13shared_memory23LockedConditionVariableE"></span><span id="shared_memory::LockedConditionVariable"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable"></span><em class="property">class </em><code class="sig-name descname">LockedConditionVariable</code><br /></dt>
<dd><em>#include &lt;locked_condition_variable.hpp&gt;</em><p>The <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_locked_condition_variable"><span class="std std-ref">LockedConditionVariable</span></a> class is here as a anonymous layer on top of the boost intersprocess condition variable labrary. </p>
<p>It creates a condition variable in a shared memory automatically. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable23LockedConditionVariableEKNSt6stringEb">
<span id="_CPPv3N13shared_memory23LockedConditionVariable23LockedConditionVariableEKNSt6stringEb"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable23LockedConditionVariableEKNSt6stringEb"></span><span id="shared_memory::LockedConditionVariable::LockedConditionVariable__ssC.b"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a648057022bbf8a7b5221e1170b1e099c"></span><code class="sig-name descname">LockedConditionVariable</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>object_id</em>, bool <em>clean_memory_on_destruction</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>A condition variable shared over the memory The condition variable is cleaned from the memory on destruction if clean_memory_on_destruction is set to true. </p>
<p>Contrary to <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_condition_variable"><span class="std std-ref">shared_memory::ConditionVariable</span></a>, instances of this class manages their mutex and lock internally, with the consequence the mutex can be locked and unlocked exclusively through other instances of <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_locked_condition_variable"><span class="std std-ref">LockedConditionVariable</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariableD0Ev">
<span id="_CPPv3N13shared_memory23LockedConditionVariableD0Ev"></span><span id="_CPPv2N13shared_memory23LockedConditionVariableD0Ev"></span><span id="shared_memory::LockedConditionVariable::~LockedConditionVariable"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a136d1208323f22f2567d70d01f670f66"></span><code class="sig-name descname">~LockedConditionVariable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable10notify_allEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable10notify_allEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable10notify_allEv"></span><span id="shared_memory::LockedConditionVariable::notify_all"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a31633f2243b988dc0a8bd3d4637dc216"></span>void <code class="sig-name descname">notify_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>notify_all is notifying all condition variables with the same mutex </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable10notify_oneEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable10notify_oneEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable10notify_oneEv"></span><span id="shared_memory::LockedConditionVariable::notify_one"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a532a1332fe184e668a49fa002db5be08"></span>void <code class="sig-name descname">notify_one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>notify_one notifies one condition variable with the same mutex </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable4waitEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable4waitEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable4waitEv"></span><span id="shared_memory::LockedConditionVariable::wait"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a9eb84ab5d570a0c5a81f6eaeb4c4dd50"></span>void <code class="sig-name descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>wait waits until another thread notifies this object </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable10timed_waitEl">
<span id="_CPPv3N13shared_memory23LockedConditionVariable10timed_waitEl"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable10timed_waitEl"></span><span id="shared_memory::LockedConditionVariable::timed_wait__l"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a0d4ab218fc51fcce34146f2adca408d7"></span>bool <code class="sig-name descname">timed_wait</code><span class="sig-paren">(</span>long <em>wait_nano_seconds</em><span class="sig-paren">)</span><br /></dt>
<dd><p>timed_wait wait a notify during a certain certain time and then wake up </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true: the condition variable has been notified, false otherwize </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wait_duration</span></code>: in microsecond </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable8try_lockEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable8try_lockEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable8try_lockEv"></span><span id="shared_memory::LockedConditionVariable::try_lock"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a86b42b23b94593bca5b12b9d792d1275"></span>bool <code class="sig-name descname">try_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>try_lock Tries to acquire the lock without waiting. </p>
<p><dl>
<dt><strong>Return</strong></dt><dd><p>true if manages to acquire the lock, false otherwise. </p>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist">
<li><code class="docutils literal notranslate"></code></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable6unlockEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable6unlockEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable6unlockEv"></span><span id="shared_memory::LockedConditionVariable::unlock"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a5d28bb5942fc5bc4886014d6b9b26885"></span>void <code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>unlock Unlocks the lock. </p>
<p><dl>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist">
<li><code class="docutils literal notranslate"></code></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable4ownsEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable4ownsEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable4ownsEv"></span><span id="shared_memory::LockedConditionVariable::owns"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a30e3825249516387276801f8d2e68a8e"></span>bool <code class="sig-name descname">owns</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable10lock_scopeEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable10lock_scopeEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable10lock_scopeEv"></span><span id="shared_memory::LockedConditionVariable::lock_scope"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a1eef63f7e3e898c3734923c987383ffe"></span>void <code class="sig-name descname">lock_scope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>lock_scope this function is used to lock the part of the code that needs protection. </p>
<p>It locks the mutex until unlock_scope is used </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable12unlock_scopeEv">
<span id="_CPPv3N13shared_memory23LockedConditionVariable12unlock_scopeEv"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable12unlock_scopeEv"></span><span id="shared_memory::LockedConditionVariable::unlock_scope"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1adf3a50665011b3b92b80369bbbc6d4a4"></span>void <code class="sig-name descname">unlock_scope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>unlock_scope this function unlock the mutex so remove the protection of the code </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable6mutex_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable6mutex_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable6mutex_E"></span><span id="shared_memory::LockedConditionVariable::mutex___SHMMutex"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a757abc2190906a0773667b42be6e4e66"></span><a class="reference internal" href="../file/mutex_8hpp.html#_CPPv4N13shared_memory8SHMMutexE" title="shared_memory::SHMMutex">SHMMutex</a> <code class="sig-name descname">mutex_</code><br /></dt>
<dd><p>mutex_ is the mutex associated to the condition variable </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable19condition_variable_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable19condition_variable_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable19condition_variable_E"></span><span id="shared_memory::LockedConditionVariable::condition_variable___SHMConditionP"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a8bc7fb73332304b406335e38ba4cdd1b"></span><a class="reference internal" href="../file/condition__variable_8hpp.html#_CPPv4N13shared_memory12SHMConditionE" title="shared_memory::SHMCondition">SHMCondition</a> *<code class="sig-name descname">condition_variable_</code><br /></dt>
<dd><p>condition_variable_ is the boost condition variable that is used </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable5lock_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable5lock_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable5lock_E"></span><span id="shared_memory::LockedConditionVariable::lock___std::unique_ptr:SHMScopeLock:"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a5509b431f2d459d92bfcc1b2d60651d1"></span>std::unique_ptr&lt;<a class="reference internal" href="../file/lock_8hpp.html#_CPPv4N13shared_memory12SHMScopeLockE" title="shared_memory::SHMScopeLock">SHMScopeLock</a>&gt; <code class="sig-name descname">lock_</code><br /></dt>
<dd><p>lock_ is a object that protects the codes with a mutex, see the boost documentation about “boost::interprocess::scoped_lock” </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable28clean_memory_on_destruction_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable28clean_memory_on_destruction_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable28clean_memory_on_destruction_E"></span><span id="shared_memory::LockedConditionVariable::clean_memory_on_destruction___b"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1abe0963bc5746d19350e816ad42ff47b1"></span>bool <code class="sig-name descname">clean_memory_on_destruction_</code><br /></dt>
<dd><p>if true (the default), clean the shared memory of the hosted mutex and condition. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable5cleanEKNSt6stringE">
<span id="_CPPv3N13shared_memory23LockedConditionVariable5cleanEKNSt6stringE"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable5cleanEKNSt6stringE"></span><span id="shared_memory::LockedConditionVariable::clean__ssC"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1aa3bca5020f84c8e0a90a2dad3e6521e5"></span>void <code class="sig-name descname">clean</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p><a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_locked_condition_variable"><span class="std std-ref">LockedConditionVariable</span></a> clean their shared memory on destruction. </p>
<p>But the destructor may have failed to be called if for some reason the program crashed. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable9mutex_id_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable9mutex_id_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable9mutex_id_E"></span><span id="shared_memory::LockedConditionVariable::mutex_id___ss"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a07d7d718e33cc2e833cf9bb22fe8fada"></span>std::string <code class="sig-name descname">mutex_id_</code><br /></dt>
<dd><p>mutex_id_ is the mutex name in the shared memory </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable13condition_id_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable13condition_id_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable13condition_id_E"></span><span id="shared_memory::LockedConditionVariable::condition_id___ss"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1a7cf01915f9d1a8795f4e69345cd1e1e4"></span>std::string <code class="sig-name descname">condition_id_</code><br /></dt>
<dd><p>condition_id_ is the condition variable name in the shared memory </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory23LockedConditionVariable16segment_manager_E">
<span id="_CPPv3N13shared_memory23LockedConditionVariable16segment_manager_E"></span><span id="_CPPv2N13shared_memory23LockedConditionVariable16segment_manager_E"></span><span id="shared_memory::LockedConditionVariable::segment_manager___boost::interprocess::managed_shared_memory"></span><span class="target" id="classshared__memory_1_1_locked_condition_variable_1ae6a197846be3bd4ccf4899754778f16b"></span>boost::interprocess::managed_shared_memory <code class="sig-name descname">segment_manager_</code><br /></dt>
<dd><p>shm_segment is the boost object that manages the shared memory segment </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory25Memory_overflow_exceptionE">
<span id="_CPPv3N13shared_memory25Memory_overflow_exceptionE"></span><span id="_CPPv2N13shared_memory25Memory_overflow_exceptionE"></span><span id="shared_memory::Memory_overflow_exception"></span><span class="target" id="classshared__memory_1_1_memory__overflow__exception"></span><em class="property">class </em><code class="sig-name descname">Memory_overflow_exception</code> : <em class="property">public</em> exception<br /></dt>
<dd><em>#include &lt;exceptions.h&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory25Memory_overflow_exception25Memory_overflow_exceptionEKNSt6stringE">
<span id="_CPPv3N13shared_memory25Memory_overflow_exception25Memory_overflow_exceptionEKNSt6stringE"></span><span id="_CPPv2N13shared_memory25Memory_overflow_exception25Memory_overflow_exceptionEKNSt6stringE"></span><span id="shared_memory::Memory_overflow_exception::Memory_overflow_exception__ssC"></span><span class="target" id="classshared__memory_1_1_memory__overflow__exception_1aed67eae5c2822873debe5eb8a7427c0b"></span><code class="sig-name descname">Memory_overflow_exception</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>error_message</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory25Memory_overflow_exceptionD0Ev">
<span id="_CPPv3N13shared_memory25Memory_overflow_exceptionD0Ev"></span><span id="_CPPv2N13shared_memory25Memory_overflow_exceptionD0Ev"></span><span id="shared_memory::Memory_overflow_exception::~Memory_overflow_exception"></span><span class="target" id="classshared__memory_1_1_memory__overflow__exception_1a0277cf7bf09198627d7d747b82f83ade"></span><code class="sig-name descname">~Memory_overflow_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory25Memory_overflow_exception4whatEv">
<span id="_CPPv3NK13shared_memory25Memory_overflow_exception4whatEv"></span><span id="_CPPv2NK13shared_memory25Memory_overflow_exception4whatEv"></span><span id="shared_memory::Memory_overflow_exception::whatC"></span><span class="target" id="classshared__memory_1_1_memory__overflow__exception_1a378f3443041b2f5fd52e2fd0231d5aea"></span><em class="property">const</em> char *<code class="sig-name descname">what</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory25Memory_overflow_exception14error_message_E">
<span id="_CPPv3N13shared_memory25Memory_overflow_exception14error_message_E"></span><span id="_CPPv2N13shared_memory25Memory_overflow_exception14error_message_E"></span><span id="shared_memory::Memory_overflow_exception::error_message___ss"></span><span class="target" id="classshared__memory_1_1_memory__overflow__exception_1ad63afdde056259c8fb0bd3212031783d"></span>std::string <code class="sig-name descname">error_message_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory5MutexE">
<span id="_CPPv3N13shared_memory5MutexE"></span><span id="_CPPv2N13shared_memory5MutexE"></span><span id="shared_memory::Mutex"></span><span class="target" id="classshared__memory_1_1_mutex"></span><em class="property">class </em><code class="sig-name descname">Mutex</code><br /></dt>
<dd><em>#include &lt;mutex.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory5Mutex5MutexENSt6stringEb">
<span id="_CPPv3N13shared_memory5Mutex5MutexENSt6stringEb"></span><span id="_CPPv2N13shared_memory5Mutex5MutexENSt6stringEb"></span><span id="shared_memory::Mutex::Mutex__ss.b"></span><span class="target" id="classshared__memory_1_1_mutex_1a8f1b1cffa2f3bdfb8cd74cf61b0df650"></span><code class="sig-name descname">Mutex</code><span class="sig-paren">(</span>std::string <em>mutex_id</em>, bool <em>clean_memory_on_destruction</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>A <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_mutex"><span class="std std-ref">Mutex</span></a> accessible to several processes via the shared memory The mutex is cleaned from the shared memory on destruction if clean_memory_on_destruction is true (the default) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory5MutexD0Ev">
<span id="_CPPv3N13shared_memory5MutexD0Ev"></span><span id="_CPPv2N13shared_memory5MutexD0Ev"></span><span id="shared_memory::Mutex::~Mutex"></span><span class="target" id="classshared__memory_1_1_mutex_1ac71952734c60b9ecba84f74a12f87075"></span><code class="sig-name descname">~Mutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory5Mutex4lockEv">
<span id="_CPPv3N13shared_memory5Mutex4lockEv"></span><span id="_CPPv2N13shared_memory5Mutex4lockEv"></span><span id="shared_memory::Mutex::lock"></span><span class="target" id="classshared__memory_1_1_mutex_1a6b6ca2e15d379a5e3a8d68d15c04469f"></span>void <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>lock the mutex </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory5Mutex6unlockEv">
<span id="_CPPv3N13shared_memory5Mutex6unlockEv"></span><span id="_CPPv2N13shared_memory5Mutex6unlockEv"></span><span id="shared_memory::Mutex::unlock"></span><span class="target" id="classshared__memory_1_1_mutex_1a06b9e214880af7ab9703bd78601ac0c6"></span>void <code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>unlock the mutex </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory5Mutex5cleanENSt6stringE">
<span id="_CPPv3N13shared_memory5Mutex5cleanENSt6stringE"></span><span id="_CPPv2N13shared_memory5Mutex5cleanENSt6stringE"></span><span id="shared_memory::Mutex::clean__ss"></span><span class="target" id="classshared__memory_1_1_mutex_1a964e89132bb180569edcf52de5b43978"></span>void <code class="sig-name descname">clean</code><span class="sig-paren">(</span>std::string <em>mutex_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt>
<span class="target" id="classshared__memory_1_1_mutex_1ac8f2675b262549f321f417323cf0702a"></span><code class="sig-name descname">friend shared_memory::Mutex::Lock</code></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5Mutex9mutex_id_E">
<span id="_CPPv3N13shared_memory5Mutex9mutex_id_E"></span><span id="_CPPv2N13shared_memory5Mutex9mutex_id_E"></span><span id="shared_memory::Mutex::mutex_id___ss"></span><span class="target" id="classshared__memory_1_1_mutex_1a2ab98408f60b14b160fae683b1a88977"></span>std::string <code class="sig-name descname">mutex_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5Mutex6mutex_E">
<span id="_CPPv3N13shared_memory5Mutex6mutex_E"></span><span id="_CPPv2N13shared_memory5Mutex6mutex_E"></span><span id="shared_memory::Mutex::mutex___SHMMutex"></span><span class="target" id="classshared__memory_1_1_mutex_1afc39f23ad6cfe9db45dd2de177a1ede1"></span><a class="reference internal" href="../file/mutex_8hpp.html#_CPPv4N13shared_memory8SHMMutexE" title="shared_memory::SHMMutex">SHMMutex</a> <code class="sig-name descname">mutex_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory5Mutex28clean_memory_on_destruction_E">
<span id="_CPPv3N13shared_memory5Mutex28clean_memory_on_destruction_E"></span><span id="_CPPv2N13shared_memory5Mutex28clean_memory_on_destruction_E"></span><span id="shared_memory::Mutex::clean_memory_on_destruction___b"></span><span class="target" id="classshared__memory_1_1_mutex_1a065ff25889e198e37021504fbe5feac8"></span>bool <code class="sig-name descname">clean_memory_on_destruction_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory22Not_consumed_exceptionE">
<span id="_CPPv3N13shared_memory22Not_consumed_exceptionE"></span><span id="_CPPv2N13shared_memory22Not_consumed_exceptionE"></span><span id="shared_memory::Not_consumed_exception"></span><span class="target" id="classshared__memory_1_1_not__consumed__exception"></span><em class="property">class </em><code class="sig-name descname">Not_consumed_exception</code> : <em class="property">public</em> exception<br /></dt>
<dd><em>#include &lt;exceptions.h&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory22Not_consumed_exception22Not_consumed_exceptionEi">
<span id="_CPPv3N13shared_memory22Not_consumed_exception22Not_consumed_exceptionEi"></span><span id="_CPPv2N13shared_memory22Not_consumed_exception22Not_consumed_exceptionEi"></span><span id="shared_memory::Not_consumed_exception::Not_consumed_exception__i"></span><span class="target" id="classshared__memory_1_1_not__consumed__exception_1a10634d3dd5cb672f549205540fdd26a7"></span><code class="sig-name descname">Not_consumed_exception</code><span class="sig-paren">(</span>int <em>missed_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory22Not_consumed_exceptionD0Ev">
<span id="_CPPv3N13shared_memory22Not_consumed_exceptionD0Ev"></span><span id="_CPPv2N13shared_memory22Not_consumed_exceptionD0Ev"></span><span id="shared_memory::Not_consumed_exception::~Not_consumed_exception"></span><span class="target" id="classshared__memory_1_1_not__consumed__exception_1a94d02584bb06d44dd7c57ce1ffad8858"></span><code class="sig-name descname">~Not_consumed_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory22Not_consumed_exception4whatEv">
<span id="_CPPv3NK13shared_memory22Not_consumed_exception4whatEv"></span><span id="_CPPv2NK13shared_memory22Not_consumed_exception4whatEv"></span><span id="shared_memory::Not_consumed_exception::whatC"></span><span class="target" id="classshared__memory_1_1_not__consumed__exception_1af7f6a6855a793da4e40e4f6b4c451e36"></span><em class="property">const</em> char *<code class="sig-name descname">what</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory22Not_consumed_exception14error_message_E">
<span id="_CPPv3N13shared_memory22Not_consumed_exception14error_message_E"></span><span id="_CPPv2N13shared_memory22Not_consumed_exception14error_message_E"></span><span id="shared_memory::Not_consumed_exception::error_message___ss"></span><span class="target" id="classshared__memory_1_1_not__consumed__exception_1af35506334fcf23eae0ccfe101a2fdb9c"></span>std::string <code class="sig-name descname">error_message_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory11SegmentInfoE">
<span id="_CPPv3N13shared_memory11SegmentInfoE"></span><span id="_CPPv2N13shared_memory11SegmentInfoE"></span><span id="shared_memory::SegmentInfo"></span><span class="target" id="classshared__memory_1_1_segment_info"></span><em class="property">class </em><code class="sig-name descname">SegmentInfo</code><br /></dt>
<dd><em>#include &lt;segment_info.hpp&gt;</em><p>encapsulate information related to a shared memory segment </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory11SegmentInfo11SegmentInfoERN5boost12interprocess21managed_shared_memoryE">
<span id="_CPPv3N13shared_memory11SegmentInfo11SegmentInfoERN5boost12interprocess21managed_shared_memoryE"></span><span id="_CPPv2N13shared_memory11SegmentInfo11SegmentInfoERN5boost12interprocess21managed_shared_memoryE"></span><span id="shared_memory::SegmentInfo::SegmentInfo__boost::interprocess::managed_shared_memoryR"></span><span class="target" id="classshared__memory_1_1_segment_info_1a254ed3b9d7e7e69a6888c9927504fe3b"></span><code class="sig-name descname">SegmentInfo</code><span class="sig-paren">(</span>boost::interprocess::managed_shared_memory &amp;<em>msm</em><span class="sig-paren">)</span><br /></dt>
<dd><p>introspection of the shared memory segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo8get_sizeEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo8get_sizeEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo8get_sizeEv"></span><span id="shared_memory::SegmentInfo::get_sizeC"></span><span class="target" id="classshared__memory_1_1_segment_info_1a0ab35167b7075c39adc5493511104b09"></span>uint <code class="sig-name descname">get_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>total size of the segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo15get_free_memoryEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo15get_free_memoryEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo15get_free_memoryEv"></span><span id="shared_memory::SegmentInfo::get_free_memoryC"></span><span class="target" id="classshared__memory_1_1_segment_info_1aa91bb7d043ff723bc134fd4bcf38f718"></span>uint <code class="sig-name descname">get_free_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>free memory of the segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo15get_used_memoryEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo15get_used_memoryEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo15get_used_memoryEv"></span><span id="shared_memory::SegmentInfo::get_used_memoryC"></span><span class="target" id="classshared__memory_1_1_segment_info_1a4c9c901d3220009dfb73fec4b0592a64"></span>uint <code class="sig-name descname">get_used_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>used memory of the segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo10has_issuesEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo10has_issuesEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo10has_issuesEv"></span><span id="shared_memory::SegmentInfo::has_issuesC"></span><span class="target" id="classshared__memory_1_1_segment_info_1ace1754181cbe2be66e2eaebac7342795"></span>bool <code class="sig-name descname">has_issues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>report on the status of the internal structures of the segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo10nb_objectsEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo10nb_objectsEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo10nb_objectsEv"></span><span id="shared_memory::SegmentInfo::nb_objectsC"></span><span class="target" id="classshared__memory_1_1_segment_info_1aa1ecf75582e0df02205ad80c2797bc94"></span>uint <code class="sig-name descname">nb_objects</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>number of objects allocated in the segment </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory11SegmentInfo5printEv">
<span id="_CPPv3NK13shared_memory11SegmentInfo5printEv"></span><span id="_CPPv2NK13shared_memory11SegmentInfo5printEv"></span><span id="shared_memory::SegmentInfo::printC"></span><span class="target" id="classshared__memory_1_1_segment_info_1a821eb6fc85451b03ea862e4cf5d6890c"></span>void <code class="sig-name descname">print</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>print in the terminal informations about the segment </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory11SegmentInfo5size_E">
<span id="_CPPv3N13shared_memory11SegmentInfo5size_E"></span><span id="_CPPv2N13shared_memory11SegmentInfo5size_E"></span><span id="shared_memory::SegmentInfo::size___uint"></span><span class="target" id="classshared__memory_1_1_segment_info_1a87f1d90b4bfefd07945ba0e7d42959f4"></span>uint <code class="sig-name descname">size_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory11SegmentInfo12free_memory_E">
<span id="_CPPv3N13shared_memory11SegmentInfo12free_memory_E"></span><span id="_CPPv2N13shared_memory11SegmentInfo12free_memory_E"></span><span id="shared_memory::SegmentInfo::free_memory___uint"></span><span class="target" id="classshared__memory_1_1_segment_info_1ab1b9e3b023e45ccb327e7322d9dde554"></span>uint <code class="sig-name descname">free_memory_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory11SegmentInfo11has_issues_E">
<span id="_CPPv3N13shared_memory11SegmentInfo11has_issues_E"></span><span id="_CPPv2N13shared_memory11SegmentInfo11has_issues_E"></span><span id="shared_memory::SegmentInfo::has_issues___b"></span><span class="target" id="classshared__memory_1_1_segment_info_1a727ff0d1a39302da90b26207de2ffc26"></span>bool <code class="sig-name descname">has_issues_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory11SegmentInfo11nb_objects_E">
<span id="_CPPv3N13shared_memory11SegmentInfo11nb_objects_E"></span><span id="_CPPv2N13shared_memory11SegmentInfo11nb_objects_E"></span><span id="shared_memory::SegmentInfo::nb_objects___uint"></span><span class="target" id="classshared__memory_1_1_segment_info_1a56992f58b9b7c0bebbbff56d85a95a4b"></span>uint <code class="sig-name descname">nb_objects_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory21Serializable_exchangeE">
<span id="_CPPv3I0EN13shared_memory21Serializable_exchangeE"></span><span id="_CPPv2I0EN13shared_memory21Serializable_exchangeE"></span><span class="target" id="classshared__memory_1_1_serializable__exchange"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Serializable_exchange</code><br /></dt>
<dd><em>#include &lt;serializable_exchange.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N21Serializable_exchange21Serializable_exchangeENSt6stringENSt6stringE">
<span id="_CPPv3N21Serializable_exchange21Serializable_exchangeENSt6stringENSt6stringE"></span><span id="_CPPv2N21Serializable_exchange21Serializable_exchangeENSt6stringENSt6stringE"></span><span id="Serializable_exchange::Serializable_exchange__ss.ss"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1acb92a032cbc772e4d327d98208b214d3"></span><code class="sig-name descname">Serializable_exchange</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, std::string <em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N21Serializable_exchangeD0Ev">
<span id="_CPPv3N21Serializable_exchangeD0Ev"></span><span id="_CPPv2N21Serializable_exchangeD0Ev"></span><span id="Serializable_exchange::~Serializable_exchange"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a42a477866b9e8b79c6b801efe7bd0d9f"></span><code class="sig-name descname">~Serializable_exchange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N21Serializable_exchange3setERK12Serializable">
<span id="_CPPv3N21Serializable_exchange3setERK12Serializable"></span><span id="_CPPv2N21Serializable_exchange3setERK12Serializable"></span><span id="Serializable_exchange::set__SerializableCR"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a29943c12f26bbd6e876b979d366fd110"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="property">const</em> Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N21Serializable_exchange4readER12Serializable">
<span id="_CPPv3N21Serializable_exchange4readER12Serializable"></span><span id="_CPPv2N21Serializable_exchange4readER12Serializable"></span><span id="Serializable_exchange::read__SerializableR"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a3b69842f01b73a15bfefed264b8e3dd3"></span>void <code class="sig-name descname">read</code><span class="sig-paren">(</span>Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory21Serializable_exchange11segment_id_E">
<span id="_CPPv3N13shared_memory21Serializable_exchange11segment_id_E"></span><span id="_CPPv2N13shared_memory21Serializable_exchange11segment_id_E"></span><span id="shared_memory::Serializable_exchange::segment_id___ss"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a495d9d0320ec199625deed0f1cd0ea20"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory21Serializable_exchange10object_id_E">
<span id="_CPPv3N13shared_memory21Serializable_exchange10object_id_E"></span><span id="_CPPv2N13shared_memory21Serializable_exchange10object_id_E"></span><span id="shared_memory::Serializable_exchange::object_id___ss"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a21968aa2fbfc11fa6ecc298320ebfb9a"></span>std::string <code class="sig-name descname">object_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory21Serializable_exchange5data_E">
<span id="_CPPv3N13shared_memory21Serializable_exchange5data_E"></span><span id="_CPPv2N13shared_memory21Serializable_exchange5data_E"></span><span id="shared_memory::Serializable_exchange::data___doubleP"></span><span class="target" id="classshared__memory_1_1_serializable__exchange_1a1923d2803a05846f61ee4738dac10674"></span>double *<code class="sig-name descname">data_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory10SerializerE">
<span id="_CPPv3I0EN13shared_memory10SerializerE"></span><span id="_CPPv2I0EN13shared_memory10SerializerE"></span><span class="target" id="classshared__memory_1_1_serializer"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Serializer</code><br /></dt>
<dd><em>#include &lt;serializer.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory10Serializer9serializeERK12Serializable">
<span id="_CPPv3N13shared_memory10Serializer9serializeERK12Serializable"></span><span id="_CPPv2N13shared_memory10Serializer9serializeERK12Serializable"></span><span id="shared_memory::Serializer::serialize__SerializableCR"></span><span class="target" id="classshared__memory_1_1_serializer_1a61ea01a0e5e28fc24c9274455050b1c1"></span><em class="property">const</em> std::string &amp;<code class="sig-name descname">serialize</code><span class="sig-paren">(</span><em class="property">const</em> Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>serialize an (almost) arbitrary instance to a string. </p>
<p>The method uses cereal internally and the instance must implement a serialize function. See for details: <a class="reference external" href="https://uscilab.github.io/cereal/">https://uscilab.github.io/cereal/</a> Supplementary requirements:<ul class="simple">
<li><p><a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a> must also have a default constructor.</p></li>
<li><p>All instances of <a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a> must be of the same size. (e.g. vectors must be of fixed size) The generated and returned string is a private member of the <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_serializer"><span class="std std-ref">Serializer</span></a> instance. Successive calls to serialize overwrite this string. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist">
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span></code>: to serialize to a string </p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory10Serializer11deserializeERKNSt6stringER12Serializable">
<span id="_CPPv3N13shared_memory10Serializer11deserializeERKNSt6stringER12Serializable"></span><span id="_CPPv2N13shared_memory10Serializer11deserializeERKNSt6stringER12Serializable"></span><span id="shared_memory::Serializer::deserialize__ssCR.SerializableR"></span><span class="target" id="classshared__memory_1_1_serializer_1a8f674c9b3a7c053403112d2fad4e09a9"></span>void <code class="sig-name descname">deserialize</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>data</em>, Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Restore the instance of serializable based on the string data, which should have been generated via the serialize function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">the</span></code>: serialized instance </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span></code>: of <a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a> to be restored </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory10Serializer17serializable_sizeEv">
<span id="_CPPv3N13shared_memory10Serializer17serializable_sizeEv"></span><span id="_CPPv2N13shared_memory10Serializer17serializable_sizeEv"></span><span id="shared_memory::Serializer::serializable_size"></span><span class="target" id="classshared__memory_1_1_serializer_1af5edd0af254d6061e8e18c0bbec10aa9"></span>int <code class="sig-name descname">serializable_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns the serialized size (i.e. </p>
<p>the size of the string) of an instance of <a class="reference internal" href="../../doxygen_index_one_page.html#class_serializable"><span class="std std-ref">Serializable</span></a> </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory10Serializer5data_E">
<span id="_CPPv3N13shared_memory10Serializer5data_E"></span><span id="_CPPv2N13shared_memory10Serializer5data_E"></span><span id="shared_memory::Serializer::data___ss"></span><span class="target" id="classshared__memory_1_1_serializer_1ad1fb7ce2b9dfde8e609aa770a3f97e72"></span>std::string <code class="sig-name descname">data_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory19SharedMemorySegmentE">
<span id="_CPPv3N13shared_memory19SharedMemorySegmentE"></span><span id="_CPPv2N13shared_memory19SharedMemorySegmentE"></span><span id="shared_memory::SharedMemorySegment"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment"></span><em class="property">class </em><code class="sig-name descname">SharedMemorySegment</code><br /></dt>
<dd><em>#include &lt;shared_memory.hpp&gt;</em><p>The <a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_shared_memory_segment"><span class="std std-ref">SharedMemorySegment</span></a> contains the pointers of the shared objects in on shared memrory segment. </p>
<p>We use unamed mutext (interprocess_mutex) and unamed condition variables (interprocess_condition) to be able to instanciate them with classic pointers </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment19SharedMemorySegmentENSt6stringEb">
<span id="_CPPv3N13shared_memory19SharedMemorySegment19SharedMemorySegmentENSt6stringEb"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment19SharedMemorySegmentENSt6stringEb"></span><span id="shared_memory::SharedMemorySegment::SharedMemorySegment__ss.b"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ae984411227bd175e684f90c9c28c976c"></span><code class="sig-name descname">SharedMemorySegment</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, bool <em>clear_upon_destruction</em><span class="sig-paren">)</span><br /></dt>
<dd><p><a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_shared_memory_segment"><span class="std std-ref">SharedMemorySegment</span></a> constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegmentD0Ev">
<span id="_CPPv3N13shared_memory19SharedMemorySegmentD0Ev"></span><span id="_CPPv2N13shared_memory19SharedMemorySegmentD0Ev"></span><span id="shared_memory::SharedMemorySegment::~SharedMemorySegment"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a9f02fd9f35950df5f6ce7ceaba5fbb53"></span><code class="sig-name descname">~SharedMemorySegment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p><a class="reference internal" href="../../doxygen_index_one_page.html#classshared__memory_1_1_shared_memory_segment"><span class="std std-ref">SharedMemorySegment</span></a> destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment12clear_memoryEv">
<span id="_CPPv3N13shared_memory19SharedMemorySegment12clear_memoryEv"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment12clear_memoryEv"></span><span id="shared_memory::SharedMemorySegment::clear_memory"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a0224739cd729dfb249c3d7882463e5eb"></span>void <code class="sig-name descname">clear_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>clear_memory free the shared memory </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory19SharedMemorySegment10get_objectEvRKNSt6stringERNSt4pairIP8ElemTypeNSt6size_tEEE">
<span id="_CPPv3I0EN13shared_memory19SharedMemorySegment10get_objectERKNSt6stringERNSt4pairIP8ElemTypeNSt6size_tEEE"></span><span id="_CPPv2I0EN13shared_memory19SharedMemorySegment10get_objectERKNSt6stringERNSt4pairIP8ElemTypeNSt6size_tEEE"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ad73b5160f713c9a78e67c4b8590d8729"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">get_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em>, std::pair&lt;<a class="reference internal" href="../class/classshared__memory_1_1_shared_memory_segment.html#_CPPv4I0EN13shared_memory19SharedMemorySegment10get_objectEvRKNSt6stringERNSt4pairIP8ElemTypeNSt6size_tEEE" title="shared_memory::SharedMemorySegment::get_object::ElemType">ElemType</a> *, std::size_t&gt; &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get_object registers the object in the current struc and in the shared memory once only. </p>
<p>And returns the pointer to the object and its size. The size will be 1 for simple type and could greater to one for arrays. <dl>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: the name of the object in the shared memory. </p></li>
<li><code class="docutils literal notranslate"></code></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment10get_objectERKNSt6stringERNSt6stringE">
<span id="_CPPv3N13shared_memory19SharedMemorySegment10get_objectERKNSt6stringERNSt6stringE"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment10get_objectERKNSt6stringERNSt6stringE"></span><span id="shared_memory::SharedMemorySegment::get_object__ssCR.ssR"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a17aa3bfe778e05b543415b1e5137a26b"></span>void <code class="sig-name descname">get_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em>, std::string &amp;<em>get_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>get_object registers the object in the current struc and in the shared memory once only. </p>
<p>And returns the pointer to the object and its size. The size will be 1 for simple type and could greater to one for arrays. <dl>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: the name of the object in the shared memory. </p></li>
<li><code class="docutils literal notranslate"></code></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory19SharedMemorySegment10set_objectEvRKNSt6stringERKNSt4pairIPK8ElemTypeNSt6size_tEEE">
<span id="_CPPv3I0EN13shared_memory19SharedMemorySegment10set_objectERKNSt6stringERKNSt4pairIPK8ElemTypeNSt6size_tEEE"></span><span id="_CPPv2I0EN13shared_memory19SharedMemorySegment10set_objectERKNSt6stringERKNSt4pairIPK8ElemTypeNSt6size_tEEE"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a16e6213d7dd1984799bbd8fbe14225dc"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">set_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::pair&lt;<em class="property">const</em> <a class="reference internal" href="../class/classshared__memory_1_1_shared_memory_segment.html#_CPPv4I0EN13shared_memory19SharedMemorySegment10set_objectEvRKNSt6stringERKNSt4pairIPK8ElemTypeNSt6size_tEEE" title="shared_memory::SharedMemorySegment::set_object::ElemType">ElemType</a> *, std::size_t&gt; &amp;<em>set_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set_object registers the object in the current struc and in the shared memory once only. </p>
<p>And returns the pointer to the object and its size. The size will be 1 for simple type and could greater to one for arrays. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: the name of the object in the shared memory. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">set_</span></code>: the reference to the fetched object. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory19SharedMemorySegment15register_objectEbRKNSt6stringERKNSt4pairIP8ElemTypeNSt6size_tEEE">
<span id="_CPPv3I0EN13shared_memory19SharedMemorySegment15register_objectERKNSt6stringERKNSt4pairIP8ElemTypeNSt6size_tEEE"></span><span id="_CPPv2I0EN13shared_memory19SharedMemorySegment15register_objectERKNSt6stringERKNSt4pairIP8ElemTypeNSt6size_tEEE"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a6987e8225fd20dbab12e5bb3f5305b75"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />bool <code class="sig-name descname">register_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em>, <em class="property">const</em> std::pair&lt;<a class="reference internal" href="../class/classshared__memory_1_1_shared_memory_segment.html#_CPPv4I0EN13shared_memory19SharedMemorySegment15register_objectEbRKNSt6stringERKNSt4pairIP8ElemTypeNSt6size_tEEE" title="shared_memory::SharedMemorySegment::register_object::ElemType">ElemType</a> *, std::size_t&gt; &amp;<em>obj_</em><span class="sig-paren">)</span><br /></dt>
<dd><p>register_object registers the object in the segment uniquely. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true of a new object has been registered </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">object_id</span></code>: is the name of the object to register. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obj_</span></code>: is the object to be registered. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory19SharedMemorySegment25register_object_read_onlyEbRKNSt6stringE">
<span id="_CPPv3I0EN13shared_memory19SharedMemorySegment25register_object_read_onlyERKNSt6stringE"></span><span id="_CPPv2I0EN13shared_memory19SharedMemorySegment25register_object_read_onlyERKNSt6stringE"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a830fee375b183642b999f6a64240f280"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />bool <code class="sig-name descname">register_object_read_only</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>register_object_read_only registers the object in the segment uniquely. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true of a new object has been registered </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">object_id</span></code>: is the name of the object to register </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obj_</span></code>: is the object to be registered </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN13shared_memory19SharedMemorySegment13delete_objectEvRKNSt6stringE">
<span id="_CPPv3I0EN13shared_memory19SharedMemorySegment13delete_objectERKNSt6stringE"></span><span id="_CPPv2I0EN13shared_memory19SharedMemorySegment13delete_objectERKNSt6stringE"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1abc658e54589c81e89b147f0b3fbd67b8"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br />void <code class="sig-name descname">delete_object</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>delete_object delete and object from the shared memory. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: the name of the object in the shared memory. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment12create_mutexEv">
<span id="_CPPv3N13shared_memory19SharedMemorySegment12create_mutexEv"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment12create_mutexEv"></span><span id="shared_memory::SharedMemorySegment::create_mutex"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ac8bbbc98968a8a2b3fe35c50e0768d8f"></span>void <code class="sig-name descname">create_mutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>create_mutex small factory that allow to make sure that the mutex is created. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment13destroy_mutexEv">
<span id="_CPPv3N13shared_memory19SharedMemorySegment13destroy_mutexEv"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment13destroy_mutexEv"></span><span id="shared_memory::SharedMemorySegment::destroy_mutex"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a64d69c4965cd448040bc20e4f9009abc"></span>void <code class="sig-name descname">destroy_mutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>destroy_mutex small destructor of the mutext to make sure that it is unlock at critical time. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment20is_object_registeredERKNSt6stringE">
<span id="_CPPv3N13shared_memory19SharedMemorySegment20is_object_registeredERKNSt6stringE"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment20is_object_registeredERKNSt6stringE"></span><span id="shared_memory::SharedMemorySegment::is_object_registered__ssCR"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ae7a86bba2f8158917b48c0bd3a7bdf9b"></span>bool <code class="sig-name descname">is_object_registered</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>is_object_registered used to check if the object has been registered or not. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if it has been registered </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">object_id</span></code>: the name of the object in the shared memory. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment26set_clear_upon_destructionEKb">
<span id="_CPPv3N13shared_memory19SharedMemorySegment26set_clear_upon_destructionEKb"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment26set_clear_upon_destructionEKb"></span><span id="shared_memory::SharedMemorySegment::set_clear_upon_destruction__bC"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ae2eb51704f44076db6ce79054e9d2572"></span>void <code class="sig-name descname">set_clear_upon_destruction</code><span class="sig-paren">(</span><em class="property">const</em> bool <em>clear_upon_destruction</em><span class="sig-paren">)</span><br /></dt>
<dd><p>set_clear_upon_destruction is a standard setter </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">clear_upon_destruction</span></code>: is the value to set </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment14get_segment_idEv">
<span id="_CPPv3N13shared_memory19SharedMemorySegment14get_segment_idEv"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment14get_segment_idEv"></span><span id="shared_memory::SharedMemorySegment::get_segment_id"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1ab7f1f01a94d4e45ed907be9bcdb71a24"></span><em class="property">const</em> std::string &amp;<code class="sig-name descname">get_segment_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>get_segment_id is a standard getter </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the segment name </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment8get_infoEv">
<span id="_CPPv3N13shared_memory19SharedMemorySegment8get_infoEv"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment8get_infoEv"></span><span id="shared_memory::SharedMemorySegment::get_info"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1aa742cf04463a94a51239b96de2da6947"></span><a class="reference internal" href="../class/classshared__memory_1_1_segment_info.html#_CPPv4N13shared_memory11SegmentInfoE" title="shared_memory::SegmentInfo">SegmentInfo</a> <code class="sig-name descname">get_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>performs introspection on the segment and return related information </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment6mutex_E">
<span id="_CPPv3N13shared_memory19SharedMemorySegment6mutex_E"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment6mutex_E"></span><span id="shared_memory::SharedMemorySegment::mutex___boost::interprocess::interprocess_mutexP"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a9e72fec52b3c76b9c2b0809b40b4e11d"></span>boost::interprocess::interprocess_mutex *<code class="sig-name descname">mutex_</code><br /></dt>
<dd><p>mutex_ this mutex secure ALL the shared memory. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment16segment_manager_E">
<span id="_CPPv3N13shared_memory19SharedMemorySegment16segment_manager_E"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment16segment_manager_E"></span><span id="shared_memory::SharedMemorySegment::segment_manager___boost::interprocess::managed_shared_memory"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1af775c0982687b6e9bc9856b21aa1e009"></span>boost::interprocess::managed_shared_memory <code class="sig-name descname">segment_manager_</code><br /></dt>
<dd><p>shm_segment is the boost object that manages the shared memory segment </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment8objects_E">
<span id="_CPPv3N13shared_memory19SharedMemorySegment8objects_E"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment8objects_E"></span><span id="shared_memory::SharedMemorySegment::objects___ShmObjects"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a8c4d0eb6f2a620bf7e5b22a57c07380b"></span><a class="reference internal" href="../file/shared__memory_8hpp.html#_CPPv4N13shared_memory10ShmObjectsE" title="shared_memory::ShmObjects">ShmObjects</a> <code class="sig-name descname">objects_</code><br /></dt>
<dd><p>objects_ are all the data stored in the segment. </p>
<p>WARNING here we use void* so the use of the set and get functions is the RESPONSABILITY of the user.</p>
<p>The user is to use the SAME type when calling set and get using the shared memory </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment11segment_id_E">
<span id="_CPPv3N13shared_memory19SharedMemorySegment11segment_id_E"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment11segment_id_E"></span><span id="shared_memory::SharedMemorySegment::segment_id___ss"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1a08408dc6b860388eb3b08e493f0188d9"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd><p>segment_id_ is the name of the segment inside the shared memory </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory19SharedMemorySegment23clear_upon_destruction_E">
<span id="_CPPv3N13shared_memory19SharedMemorySegment23clear_upon_destruction_E"></span><span id="_CPPv2N13shared_memory19SharedMemorySegment23clear_upon_destruction_E"></span><span id="shared_memory::SharedMemorySegment::clear_upon_destruction___b"></span><span class="target" id="classshared__memory_1_1_shared_memory_segment_1af50ac70dca284926b15803f86958b220"></span>bool <code class="sig-name descname">clear_upon_destruction_</code><br /></dt>
<dd><p>clear_upon_destruction_ flag decides if the segment should be cleared upon destruction. </p>
<p>Usage: typically only one process should set this flag to true. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory13ShmTypeHelperE">
<span id="_CPPv3I0EN13shared_memory13ShmTypeHelperE"></span><span id="_CPPv2I0EN13shared_memory13ShmTypeHelperE"></span><span class="target" id="structshared__memory_1_1_shm_type_helper"></span>template&lt;typename <code class="sig-name descname">ElemType</code>&gt;<br /><em class="property">struct </em><code class="sig-name descname">ShmTypeHelper</code><br /></dt>
<dd><em>#include &lt;shared_memory.hpp&gt;</em><p><a class="reference internal" href="../../doxygen_index_one_page.html#structshared__memory_1_1_shm_type_helper"><span class="std std-ref">ShmTypeHelper</span></a> is a small struct that allow the definition of templated typedef. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv4N13shared_memory13ShmTypeHelper17ElemTypeAllocatorE">
<span id="_CPPv3N13shared_memory13ShmTypeHelper17ElemTypeAllocatorE"></span><span id="_CPPv2N13shared_memory13ShmTypeHelper17ElemTypeAllocatorE"></span><span id="shared_memory::ShmTypeHelper::ElemTypeAllocator"></span><span class="target" id="structshared__memory_1_1_shm_type_helper_1a8f19a7da45c3208eade1e5943588e5da"></span><em class="property">typedef </em>boost::interprocess::allocator&lt;ElemType, boost::interprocess::managed_shared_memory::segment_manager&gt; <code class="sig-name descname">ElemTypeAllocator</code><br /></dt>
<dd><p>ShmemAllocator typedef allows to create std::allocator with the boost interprocess library. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory13ShmTypeHelper8ShmDequeE">
<span id="_CPPv3N13shared_memory13ShmTypeHelper8ShmDequeE"></span><span id="_CPPv2N13shared_memory13ShmTypeHelper8ShmDequeE"></span><span id="shared_memory::ShmTypeHelper::ShmDeque"></span><span class="target" id="structshared__memory_1_1_shm_type_helper_1a935d582ba7497fea7a44a7e74ac9219e"></span><em class="property">typedef </em>boost::container::deque&lt;ElemType, ShmTypeHelper&lt;ElemType&gt;::ElemTypeAllocator&gt; <code class="sig-name descname">ShmDeque</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory13ShmTypeHelper9ShmVectorE">
<span id="_CPPv3N13shared_memory13ShmTypeHelper9ShmVectorE"></span><span id="_CPPv2N13shared_memory13ShmTypeHelper9ShmVectorE"></span><span id="shared_memory::ShmTypeHelper::ShmVector"></span><span class="target" id="structshared__memory_1_1_shm_type_helper_1a306bff24c9271b479fdfd238bef10580"></span><em class="property">typedef </em>boost::container::vector&lt;ElemType, ShmTypeHelper&lt;ElemType&gt;::ElemTypeAllocator&gt; <code class="sig-name descname">ShmVector</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory18Unexpected_map_keyE">
<span id="_CPPv3I0EN13shared_memory18Unexpected_map_keyE"></span><span id="_CPPv2I0EN13shared_memory18Unexpected_map_keyE"></span><span class="target" id="classshared__memory_1_1_unexpected__map__key"></span>template&lt;typename <code class="sig-name descname">Key</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Unexpected_map_key</code> : <em class="property">public</em> exception<br /></dt>
<dd><em>#include &lt;exceptions.h&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory18Unexpected_map_key18Unexpected_map_keyERKNSt6stringERKNSt6stringER3Key">
<span id="_CPPv3N13shared_memory18Unexpected_map_key18Unexpected_map_keyERKNSt6stringERKNSt6stringER3Key"></span><span id="_CPPv2N13shared_memory18Unexpected_map_key18Unexpected_map_keyERKNSt6stringERKNSt6stringER3Key"></span><span id="shared_memory::Unexpected_map_key::Unexpected_map_key__ssCR.ssCR.KeyR"></span><span class="target" id="classshared__memory_1_1_unexpected__map__key_1a6b186f98c6978fb264529381b3174c9d"></span><code class="sig-name descname">Unexpected_map_key</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, Key &amp;<em>expected_key</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory18Unexpected_map_keyD0Ev">
<span id="_CPPv3N13shared_memory18Unexpected_map_keyD0Ev"></span><span id="_CPPv2N13shared_memory18Unexpected_map_keyD0Ev"></span><span id="shared_memory::Unexpected_map_key::~Unexpected_map_key"></span><span class="target" id="classshared__memory_1_1_unexpected__map__key_1ad89e63ce30f6e7ae1e29a9aa1b6ed358"></span><code class="sig-name descname">~Unexpected_map_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory18Unexpected_map_key4whatEv">
<span id="_CPPv3NK13shared_memory18Unexpected_map_key4whatEv"></span><span id="_CPPv2NK13shared_memory18Unexpected_map_key4whatEv"></span><span id="shared_memory::Unexpected_map_key::whatC"></span><span class="target" id="classshared__memory_1_1_unexpected__map__key_1af5cbaa9ae4b6f51f8e201d2984a7d94c"></span><em class="property">const</em> char *<code class="sig-name descname">what</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory18Unexpected_map_key14error_message_E">
<span id="_CPPv3N13shared_memory18Unexpected_map_key14error_message_E"></span><span id="_CPPv2N13shared_memory18Unexpected_map_key14error_message_E"></span><span id="shared_memory::Unexpected_map_key::error_message___ss"></span><span class="target" id="classshared__memory_1_1_unexpected__map__key_1a67c2b43bc3b41b5584c7fba92acac5cc"></span>std::string <code class="sig-name descname">error_message_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N13shared_memory25Unexpected_size_exceptionE">
<span id="_CPPv3N13shared_memory25Unexpected_size_exceptionE"></span><span id="_CPPv2N13shared_memory25Unexpected_size_exceptionE"></span><span id="shared_memory::Unexpected_size_exception"></span><span class="target" id="classshared__memory_1_1_unexpected__size__exception"></span><em class="property">class </em><code class="sig-name descname">Unexpected_size_exception</code> : <em class="property">public</em> exception<br /></dt>
<dd><em>#include &lt;exceptions.h&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory25Unexpected_size_exception25Unexpected_size_exceptionERKNSt6stringERKNSt6stringEii">
<span id="_CPPv3N13shared_memory25Unexpected_size_exception25Unexpected_size_exceptionERKNSt6stringERKNSt6stringEii"></span><span id="_CPPv2N13shared_memory25Unexpected_size_exception25Unexpected_size_exceptionERKNSt6stringERKNSt6stringEii"></span><span id="shared_memory::Unexpected_size_exception::Unexpected_size_exception__ssCR.ssCR.i.i"></span><span class="target" id="classshared__memory_1_1_unexpected__size__exception_1acc8b3dc1f6879b44e7ccd7f22d13198b"></span><code class="sig-name descname">Unexpected_size_exception</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>segment_id</em>, <em class="property">const</em> std::string &amp;<em>object_id</em>, int <em>expected_size</em>, int <em>size_given</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory25Unexpected_size_exceptionD0Ev">
<span id="_CPPv3N13shared_memory25Unexpected_size_exceptionD0Ev"></span><span id="_CPPv2N13shared_memory25Unexpected_size_exceptionD0Ev"></span><span id="shared_memory::Unexpected_size_exception::~Unexpected_size_exception"></span><span class="target" id="classshared__memory_1_1_unexpected__size__exception_1a968acda32460528d250087d30de6440d"></span><code class="sig-name descname">~Unexpected_size_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK13shared_memory25Unexpected_size_exception4whatEv">
<span id="_CPPv3NK13shared_memory25Unexpected_size_exception4whatEv"></span><span id="_CPPv2NK13shared_memory25Unexpected_size_exception4whatEv"></span><span id="shared_memory::Unexpected_size_exception::whatC"></span><span class="target" id="classshared__memory_1_1_unexpected__size__exception_1afbadf4f5340a8d20077016a57dd9414c"></span><em class="property">const</em> char *<code class="sig-name descname">what</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory25Unexpected_size_exception14error_message_E">
<span id="_CPPv3N13shared_memory25Unexpected_size_exception14error_message_E"></span><span id="_CPPv2N13shared_memory25Unexpected_size_exception14error_message_E"></span><span id="shared_memory::Unexpected_size_exception::error_message___ss"></span><span class="target" id="classshared__memory_1_1_unexpected__size__exception_1a6f22d0e0207e97cafe4f78192c913c55"></span>std::string <code class="sig-name descname">error_message_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory8internalE">
<span id="_CPPv3N13shared_memory8internalE"></span><span id="_CPPv2N13shared_memory8internalE"></span><span id="shared_memory::internal"></span><span class="target" id="namespaceshared__memory_1_1internal"></span><em class="property">namespace </em><code class="sig-name descname">internal</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv4I0_iEN13shared_memory8internal23Exchange_manager_memoryE">
<span id="_CPPv3I0_iEN13shared_memory8internal23Exchange_manager_memoryE"></span><span id="_CPPv2I0_iEN13shared_memory8internal23Exchange_manager_memoryE"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory"></span>template&lt;class <code class="sig-name descname">Serializable</code>, int <code class="sig-name descname">QUEUE_SIZE</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Exchange_manager_memory</code><br /></dt>
<dd><em>#include &lt;exchange_manager_memory.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="enum">
<dt id="_CPPv4N13shared_memory8internal6StatusE">
<span id="_CPPv3N13shared_memory8internal6StatusE"></span><span id="_CPPv2N13shared_memory8internal6StatusE"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a111ddeef03bfb038bcbc170c28878c08"></span><em class="property">enum </em><code class="sig-name descname">Status</code><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv4N13shared_memory8internal5RESETE">
<span id="_CPPv3N13shared_memory8internal5RESETE"></span><span id="_CPPv2N13shared_memory8internal5RESETE"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a111ddeef03bfb038bcbc170c28878c08ac60720cbbc2fc2421b210ed6da63eb4a"></span><code class="sig-name descname">RESET</code><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv4N13shared_memory8internal7WAITINGE">
<span id="_CPPv3N13shared_memory8internal7WAITINGE"></span><span id="_CPPv2N13shared_memory8internal7WAITINGE"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a111ddeef03bfb038bcbc170c28878c08a437ddb419cf9c1a6399e3a98eae3db51"></span><code class="sig-name descname">WAITING</code><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv4N13shared_memory8internal7RUNNINGE">
<span id="_CPPv3N13shared_memory8internal7RUNNINGE"></span><span id="_CPPv2N13shared_memory8internal7RUNNINGE"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a111ddeef03bfb038bcbc170c28878c08ad7cbdf97bec755c256d0777f729fa0b1"></span><code class="sig-name descname">RUNNING</code><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory23Exchange_manager_memoryENSt6stringENSt6stringE">
<span id="_CPPv3N23Exchange_manager_memory23Exchange_manager_memoryENSt6stringENSt6stringE"></span><span id="_CPPv2N23Exchange_manager_memory23Exchange_manager_memoryENSt6stringENSt6stringE"></span><span id="Exchange_manager_memory::Exchange_manager_memory__ss.ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a4bb976aa1b16314bf4181035bb746869"></span><code class="sig-name descname">Exchange_manager_memory</code><span class="sig-paren">(</span>std::string <em>segment_id</em>, std::string <em>object_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memoryD0Ev">
<span id="_CPPv3N23Exchange_manager_memoryD0Ev"></span><span id="_CPPv2N23Exchange_manager_memoryD0Ev"></span><span id="Exchange_manager_memory::~Exchange_manager_memory"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a021d123a58b5e0f47906f7550ebb9016"></span><code class="sig-name descname">~Exchange_manager_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory15read_serializedER12Serializable">
<span id="_CPPv3N23Exchange_manager_memory15read_serializedER12Serializable"></span><span id="_CPPv2N23Exchange_manager_memory15read_serializedER12Serializable"></span><span id="Exchange_manager_memory::read_serialized__SerializableR"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1aa0efbb57f5fafc8faa52f112b4db705e"></span>bool <code class="sig-name descname">read_serialized</code><span class="sig-paren">(</span>Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory16write_serializedERK12Serializable">
<span id="_CPPv3N23Exchange_manager_memory16write_serializedERK12Serializable"></span><span id="_CPPv2N23Exchange_manager_memory16write_serializedERK12Serializable"></span><span id="Exchange_manager_memory::write_serialized__SerializableCR"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a4b5fddf9270c80e4fbcb041947b4142c"></span>bool <code class="sig-name descname">write_serialized</code><span class="sig-paren">(</span><em class="property">const</em> Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory19write_serialized_idEi">
<span id="_CPPv3N23Exchange_manager_memory19write_serialized_idEi"></span><span id="_CPPv2N23Exchange_manager_memory19write_serialized_idEi"></span><span id="Exchange_manager_memory::write_serialized_id__i"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a89d6cea01eca5ba87bff929e6bc7049f"></span>void <code class="sig-name descname">write_serialized_id</code><span class="sig-paren">(</span>int <em>id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory5clearEv">
<span id="_CPPv3N23Exchange_manager_memory5clearEv"></span><span id="_CPPv2N23Exchange_manager_memory5clearEv"></span><span id="Exchange_manager_memory::clear"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ae9babbca9b477db799c6bbfe3aab425b"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory16get_consumed_idsERNSt5dequeIiEE">
<span id="_CPPv3N23Exchange_manager_memory16get_consumed_idsERNSt5dequeIiEE"></span><span id="_CPPv2N23Exchange_manager_memory16get_consumed_idsERNSt5dequeIiEE"></span><span id="Exchange_manager_memory::get_consumed_ids__std::deque:i:R"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a166fd53fb2da0da38801138ff1119e4c"></span>void <code class="sig-name descname">get_consumed_ids</code><span class="sig-paren">(</span>std::deque&lt;int&gt; &amp;<em>get_ids</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory10set_statusE6Status">
<span id="_CPPv3N23Exchange_manager_memory10set_statusE6Status"></span><span id="_CPPv2N23Exchange_manager_memory10set_statusE6Status"></span><span id="Exchange_manager_memory::set_status__Status"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a9294652f5d187c25308fc185107405ce"></span>void <code class="sig-name descname">set_status</code><span class="sig-paren">(</span>Status <em>status</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory10get_statusER6Status">
<span id="_CPPv3N23Exchange_manager_memory10get_statusER6Status"></span><span id="_CPPv2N23Exchange_manager_memory10get_statusER6Status"></span><span id="Exchange_manager_memory::get_status__StatusR"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a5c012017aedf7a85fce4f05e62a33ff5"></span>void <code class="sig-name descname">get_status</code><span class="sig-paren">(</span>Status &amp;<em>status</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory15purge_feedbacksEv">
<span id="_CPPv3N23Exchange_manager_memory15purge_feedbacksEv"></span><span id="_CPPv2N23Exchange_manager_memory15purge_feedbacksEv"></span><span id="Exchange_manager_memory::purge_feedbacks"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a328cc8181f3ad7e4b4f06c736e1c1d5c"></span>bool <code class="sig-name descname">purge_feedbacks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory5cleanEv">
<span id="_CPPv3N23Exchange_manager_memory5cleanEv"></span><span id="_CPPv2N23Exchange_manager_memory5cleanEv"></span><span id="Exchange_manager_memory::clean"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1aa38a21be32f34e170e4f69824cd797a6"></span>void <code class="sig-name descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory4lockEv">
<span id="_CPPv3N23Exchange_manager_memory4lockEv"></span><span id="_CPPv2N23Exchange_manager_memory4lockEv"></span><span id="Exchange_manager_memory::lock"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1adae77aef8f3669914535f35085be8192"></span>void <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory6unlockEv">
<span id="_CPPv3N23Exchange_manager_memory6unlockEv"></span><span id="_CPPv2N23Exchange_manager_memory6unlockEv"></span><span id="Exchange_manager_memory::unlock"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1aa8723a5ac8aa9cd763ea7c5c18a89cf9"></span>void <code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK23Exchange_manager_memory20consumer_queue_emptyEv">
<span id="_CPPv3NK23Exchange_manager_memory20consumer_queue_emptyEv"></span><span id="_CPPv2NK23Exchange_manager_memory20consumer_queue_emptyEv"></span><span id="Exchange_manager_memory::consumer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a38fffdc598bdef77782e49b7653f34b5"></span>bool <code class="sig-name descname">consumer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4NK23Exchange_manager_memory20producer_queue_emptyEv">
<span id="_CPPv3NK23Exchange_manager_memory20producer_queue_emptyEv"></span><span id="_CPPv2NK23Exchange_manager_memory20producer_queue_emptyEv"></span><span id="Exchange_manager_memory::producer_queue_emptyC"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1af9457fa77852bfecf90f26c2b3ce6f76"></span>bool <code class="sig-name descname">producer_queue_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory11weird_purgeEv">
<span id="_CPPv3N23Exchange_manager_memory11weird_purgeEv"></span><span id="_CPPv2N23Exchange_manager_memory11weird_purgeEv"></span><span id="Exchange_manager_memory::weird_purge"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a8d1197e044147a47f162c28e82ebf18a"></span>void <code class="sig-name descname">weird_purge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory16reset_char_countEv">
<span id="_CPPv3N23Exchange_manager_memory16reset_char_countEv"></span><span id="_CPPv2N23Exchange_manager_memory16reset_char_countEv"></span><span id="Exchange_manager_memory::reset_char_count"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a871ca7c6476c78d1887e271b3f2bea62"></span>void <code class="sig-name descname">reset_char_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory15nb_char_writtenEv">
<span id="_CPPv3N23Exchange_manager_memory15nb_char_writtenEv"></span><span id="_CPPv2N23Exchange_manager_memory15nb_char_writtenEv"></span><span id="Exchange_manager_memory::nb_char_written"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ad30f6606b230c0fe4b4d3ec73da96a6c"></span>int <code class="sig-name descname">nb_char_written</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory12nb_char_readEv">
<span id="_CPPv3N23Exchange_manager_memory12nb_char_readEv"></span><span id="_CPPv2N23Exchange_manager_memory12nb_char_readEv"></span><span id="Exchange_manager_memory::nb_char_read"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a76284109b7af9a05bf763154ba36391e"></span>int <code class="sig-name descname">nb_char_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory11segment_id_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory11segment_id_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory11segment_id_E"></span><span id="shared_memory::internal::Exchange_manager_memory::segment_id___ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a8d9578755fec571f772caec5908fdd38"></span>std::string <code class="sig-name descname">segment_id_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory19object_id_producer_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory19object_id_producer_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory19object_id_producer_E"></span><span id="shared_memory::internal::Exchange_manager_memory::object_id_producer___ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ab8c8000af66737cdc65a4a5b6c62cbd8"></span>std::string <code class="sig-name descname">object_id_producer_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory19object_id_consumer_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory19object_id_consumer_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory19object_id_consumer_E"></span><span id="shared_memory::internal::Exchange_manager_memory::object_id_consumer___ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ae438583144066ca87b4e1d12065b6e83"></span>std::string <code class="sig-name descname">object_id_consumer_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory17object_id_status_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory17object_id_status_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory17object_id_status_E"></span><span id="shared_memory::internal::Exchange_manager_memory::object_id_status___ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1aa01b4baeff59e90eb679b1fbf3099a02"></span>std::string <code class="sig-name descname">object_id_status_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory8segment_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory8segment_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory8segment_E"></span><span id="shared_memory::internal::Exchange_manager_memory::segment___bip::managed_shared_memory"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a91205f52e14b9e843f3ba07b9c3d4d14"></span>bip::managed_shared_memory <code class="sig-name descname">segment_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory9produced_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory9produced_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory9produced_E"></span><span id="shared_memory::internal::Exchange_manager_memory::produced___producer_queueP"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ab333730dadc8519f23608e77c0974928"></span><a class="reference internal" href="../class/classshared__memory_1_1internal_1_1_exchange__manager__memory.html#_CPPv4N13shared_memory8internal23Exchange_manager_memory14producer_queueE" title="shared_memory::internal::Exchange_manager_memory::producer_queue">producer_queue</a> *<code class="sig-name descname">produced_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory16consumed_buffer_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory16consumed_buffer_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory16consumed_buffer_E"></span><span id="shared_memory::internal::Exchange_manager_memory::consumed_buffer___std::deque:i:"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a2f3336a1a2a55972e4b1c61a81449fcb"></span>std::deque&lt;int&gt; <code class="sig-name descname">consumed_buffer_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory9consumed_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory9consumed_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory9consumed_E"></span><span id="shared_memory::internal::Exchange_manager_memory::consumed___consumer_queueP"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a859c731d30b829de85eb92ac9866ae36"></span><a class="reference internal" href="../class/classshared__memory_1_1internal_1_1_exchange__manager__memory.html#_CPPv4N13shared_memory8internal23Exchange_manager_memory14consumer_queueE" title="shared_memory::internal::Exchange_manager_memory::consumer_queue">consumer_queue</a> *<code class="sig-name descname">consumed_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory7values_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory7values_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory7values_E"></span><span id="shared_memory::internal::Exchange_manager_memory::values___cP"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a32794be03e7f992a26fcad1f550a5b33"></span>char *<code class="sig-name descname">values_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory7locker_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory7locker_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory7locker_E"></span><span id="shared_memory::internal::Exchange_manager_memory::locker___shared_memory::Mutex"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a44d72a699c2a76b2ef127f02ee37d26b"></span><a class="reference internal" href="../file/array_8cpp.html#_CPPv413shared_memory" title="shared_memory">shared_memory</a>::<a class="reference internal" href="../class/classshared__memory_1_1_mutex.html#_CPPv4N13shared_memory5MutexE" title="shared_memory::Mutex">Mutex</a> <code class="sig-name descname">locker_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory16serialized_read_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory16serialized_read_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory16serialized_read_E"></span><span id="shared_memory::internal::Exchange_manager_memory::serialized_read___Serialized_read:Serializable:"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a3a5127e519eec82ec2a4181eee4ddab5"></span>Serialized_read&lt;Serializable&gt; <code class="sig-name descname">serialized_read_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory17serialized_write_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory17serialized_write_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory17serialized_write_E"></span><span id="shared_memory::internal::Exchange_manager_memory::serialized_write___Serialized_write:Serializable:"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a1999cdf0f4f438e448bec0ef86a153b3"></span>Serialized_write&lt;Serializable&gt; <code class="sig-name descname">serialized_write_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory18serializable_size_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory18serializable_size_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory18serializable_size_E"></span><span id="shared_memory::internal::Exchange_manager_memory::serializable_size___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1af2d9740e5a2c4498a3d234175c515f26"></span>int <code class="sig-name descname">serializable_size_</code><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory11clean_mutexENSt6stringE">
<span id="_CPPv3N23Exchange_manager_memory11clean_mutexENSt6stringE"></span><span id="_CPPv2N23Exchange_manager_memory11clean_mutexENSt6stringE"></span><span id="Exchange_manager_memory::clean_mutex__ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a080eaca6885c4760620fd1df11907b66"></span>void <code class="sig-name descname">clean_mutex</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N23Exchange_manager_memory12clean_memoryENSt6stringE">
<span id="_CPPv3N23Exchange_manager_memory12clean_memoryENSt6stringE"></span><span id="_CPPv2N23Exchange_manager_memory12clean_memoryENSt6stringE"></span><span id="Exchange_manager_memory::clean_memory__ss"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1ab87f3b0b0511bebd1f084ca088044e5f"></span>void <code class="sig-name descname">clean_memory</code><span class="sig-paren">(</span>std::string <em>segment_id</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Types</p>
<dl class="type">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory14producer_queueE">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory14producer_queueE"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory14producer_queueE"></span><span id="shared_memory::internal::Exchange_manager_memory::producer_queue"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1acd7500dc11fa85fdff1c62b3bfec9bb5"></span><em class="property">typedef </em>boost::lockfree::queue&lt;char, boost::lockfree::fixed_sized&lt;true&gt;, boost::lockfree::capacity&lt;QUEUE_SIZE&gt;&gt; <code class="sig-name descname">producer_queue</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory14consumer_queueE">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory14consumer_queueE"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory14consumer_queueE"></span><span id="shared_memory::internal::Exchange_manager_memory::consumer_queue"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1acfdce096249f1dd920c42d65176ba587"></span><em class="property">typedef </em>boost::lockfree::queue&lt;int, boost::lockfree::fixed_sized&lt;true&gt;, boost::lockfree::capacity&lt;QUEUE_SIZE&gt;&gt; <code class="sig-name descname">consumer_queue</code><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory13nb_char_read_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory13nb_char_read_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory13nb_char_read_E"></span><span id="shared_memory::internal::Exchange_manager_memory::nb_char_read___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a954428f2d2e9f7b29cd4201bfb7fa51c"></span>int <code class="sig-name descname">nb_char_read_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal23Exchange_manager_memory16nb_char_written_E">
<span id="_CPPv3N13shared_memory8internal23Exchange_manager_memory16nb_char_written_E"></span><span id="_CPPv2N13shared_memory8internal23Exchange_manager_memory16nb_char_written_E"></span><span id="shared_memory::internal::Exchange_manager_memory::nb_char_written___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_exchange__manager__memory_1a5669c5ec75442d54fd5e004a464233da"></span>int <code class="sig-name descname">nb_char_written_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory8internal15Serialized_readE">
<span id="_CPPv3I0EN13shared_memory8internal15Serialized_readE"></span><span id="_CPPv2I0EN13shared_memory8internal15Serialized_readE"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Serialized_read</code><br /></dt>
<dd><em>#include &lt;exchange_manager_memory.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_read15Serialized_readEv">
<span id="_CPPv3N13shared_memory15Serialized_read15Serialized_readEv"></span><span id="_CPPv2N13shared_memory15Serialized_read15Serialized_readEv"></span><span id="shared_memory::Serialized_read::Serialized_read"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a5f43f35cf34aa27081086c8dafe37f52"></span><code class="sig-name descname">Serialized_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_readD0Ev">
<span id="_CPPv3N13shared_memory15Serialized_readD0Ev"></span><span id="_CPPv2N13shared_memory15Serialized_readD0Ev"></span><span id="shared_memory::Serialized_read::~Serialized_read"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1ac3e7ef2e90b8ba77562226f3dbcf5dc0"></span><code class="sig-name descname">~Serialized_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_read3setEc">
<span id="_CPPv3N13shared_memory15Serialized_read3setEc"></span><span id="_CPPv2N13shared_memory15Serialized_read3setEc"></span><span id="shared_memory::Serialized_read::set__c"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1ab13f4c5e450bc206ca5f30baa43ed5f6"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>char <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_read4readER12Serializable">
<span id="_CPPv3N13shared_memory15Serialized_read4readER12Serializable"></span><span id="_CPPv2N13shared_memory15Serialized_read4readER12Serializable"></span><span id="shared_memory::Serialized_read::read__SerializableR"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1add7a39a632e0f6868e60109ad58fa3a2"></span>bool <code class="sig-name descname">read</code><span class="sig-paren">(</span>Serializable &amp;<em>serializable</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_read12nb_char_readEv">
<span id="_CPPv3N13shared_memory15Serialized_read12nb_char_readEv"></span><span id="_CPPv2N13shared_memory15Serialized_read12nb_char_readEv"></span><span id="shared_memory::Serialized_read::nb_char_read"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a7267b8b68f925787f37fa9c0e369a93b"></span>int <code class="sig-name descname">nb_char_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13shared_memory15Serialized_read18reset_nb_char_readEv">
<span id="_CPPv3N13shared_memory15Serialized_read18reset_nb_char_readEv"></span><span id="_CPPv2N13shared_memory15Serialized_read18reset_nb_char_readEv"></span><span id="shared_memory::Serialized_read::reset_nb_char_read"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a664a3d89efb0f985578b3fb4835f97d4"></span>void <code class="sig-name descname">reset_nb_char_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read7buffer_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read7buffer_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read7buffer_E"></span><span id="shared_memory::internal::Serialized_read::buffer___std::deque:c:"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a2bf4782bcdbbf8a415309b82e9b333c6"></span>std::deque&lt;char&gt; <code class="sig-name descname">buffer_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read5size_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read5size_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read5size_E"></span><span id="shared_memory::internal::Serialized_read::size___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1acb1db67ffcae257bb009c16726abcbb7"></span>int <code class="sig-name descname">size_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read13nb_char_read_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read13nb_char_read_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read13nb_char_read_E"></span><span id="shared_memory::internal::Serialized_read::nb_char_read___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1ae8f179745a0e9c95668c08a092d291ee"></span>int <code class="sig-name descname">nb_char_read_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read18serializable_size_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read18serializable_size_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read18serializable_size_E"></span><span id="shared_memory::internal::Serialized_read::serializable_size___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a540b0e3a8a12d0167b828010fd7fde3e"></span>int <code class="sig-name descname">serializable_size_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read7values_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read7values_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read7values_E"></span><span id="shared_memory::internal::Serialized_read::values___cP"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1ad267ed8416105a705c1afabd16cb941b"></span>char *<code class="sig-name descname">values_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal15Serialized_read11serializer_E">
<span id="_CPPv3N13shared_memory8internal15Serialized_read11serializer_E"></span><span id="_CPPv2N13shared_memory8internal15Serialized_read11serializer_E"></span><span id="shared_memory::internal::Serialized_read::serializer___Serializer:Serializable:"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__read_1a507ecb659494a31ae4d4744967bcf78d"></span>Serializer&lt;Serializable&gt; <code class="sig-name descname">serializer_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN13shared_memory8internal16Serialized_writeE">
<span id="_CPPv3I0EN13shared_memory8internal16Serialized_writeE"></span><span id="_CPPv2I0EN13shared_memory8internal16Serialized_writeE"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write"></span>template&lt;class <code class="sig-name descname">Serializable</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">Serialized_write</code><br /></dt>
<dd><em>#include &lt;exchange_manager_memory.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N16Serialized_write16Serialized_writeEv">
<span id="_CPPv3N16Serialized_write16Serialized_writeEv"></span><span id="_CPPv2N16Serialized_write16Serialized_writeEv"></span><span id="Serialized_write::Serialized_write"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a81ac829258145a86e823532a0b2617d4"></span><code class="sig-name descname">Serialized_write</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_writeD0Ev">
<span id="_CPPv3N16Serialized_writeD0Ev"></span><span id="_CPPv2N16Serialized_writeD0Ev"></span><span id="Serialized_write::~Serialized_write"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a975427a803c55aa69b217f7d6e499705"></span><code class="sig-name descname">~Serialized_write</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write5emptyEv">
<span id="_CPPv3N16Serialized_write5emptyEv"></span><span id="_CPPv2N16Serialized_write5emptyEv"></span><span id="Serialized_write::empty"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a1166684494bff2d969ca16ccbeee486a"></span>bool <code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write5frontEv">
<span id="_CPPv3N16Serialized_write5frontEv"></span><span id="_CPPv2N16Serialized_write5frontEv"></span><span id="Serialized_write::front"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a96412580e8aedd0e1fa90f8b64e4745f"></span>char <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write3popEv">
<span id="_CPPv3N16Serialized_write3popEv"></span><span id="_CPPv2N16Serialized_write3popEv"></span><span id="Serialized_write::pop"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1adf6c52536a53dbc1181eab1409a3641b"></span>void <code class="sig-name descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write5writeERK12SerializableNSt6size_tE">
<span id="_CPPv3N16Serialized_write5writeERK12SerializableNSt6size_tE"></span><span id="_CPPv2N16Serialized_write5writeERK12SerializableNSt6size_tE"></span><span id="Serialized_write::write__SerializableCR.std::s"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a32f8f7e6faabf358283736f51e40b33c"></span>void <code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="property">const</em> Serializable &amp;<em>serializable</em>, std::size_t <em>expected_size</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write15nb_char_writtenEv">
<span id="_CPPv3N16Serialized_write15nb_char_writtenEv"></span><span id="_CPPv2N16Serialized_write15nb_char_writtenEv"></span><span id="Serialized_write::nb_char_written"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a830ed6c58591e8284ecb1b8b2e936e03"></span>int <code class="sig-name descname">nb_char_written</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N16Serialized_write21reset_nb_char_writtenEv">
<span id="_CPPv3N16Serialized_write21reset_nb_char_writtenEv"></span><span id="_CPPv2N16Serialized_write21reset_nb_char_writtenEv"></span><span id="Serialized_write::reset_nb_char_written"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a58b23378ce903e1aadf7c5e497022e5f"></span>void <code class="sig-name descname">reset_nb_char_written</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13shared_memory8internal16Serialized_write7buffer_E">
<span id="_CPPv3N13shared_memory8internal16Serialized_write7buffer_E"></span><span id="_CPPv2N13shared_memory8internal16Serialized_write7buffer_E"></span><span id="shared_memory::internal::Serialized_write::buffer___std::deque:c:"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a09aebade690ec6a326a401ab2d2f4f53"></span>std::deque&lt;char&gt; <code class="sig-name descname">buffer_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal16Serialized_write7values_E">
<span id="_CPPv3N13shared_memory8internal16Serialized_write7values_E"></span><span id="_CPPv2N13shared_memory8internal16Serialized_write7values_E"></span><span id="shared_memory::internal::Serialized_write::values___cP"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1aec4432c789df9a8fd2c037063e3a29b1"></span>char *<code class="sig-name descname">values_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal16Serialized_write16nb_char_written_E">
<span id="_CPPv3N13shared_memory8internal16Serialized_write16nb_char_written_E"></span><span id="_CPPv2N13shared_memory8internal16Serialized_write16nb_char_written_E"></span><span id="shared_memory::internal::Serialized_write::nb_char_written___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a7a207fb34addd19507a6b6e9c614115c"></span>int <code class="sig-name descname">nb_char_written_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal16Serialized_write18serializable_size_E">
<span id="_CPPv3N13shared_memory8internal16Serialized_write18serializable_size_E"></span><span id="_CPPv2N13shared_memory8internal16Serialized_write18serializable_size_E"></span><span id="shared_memory::internal::Serialized_write::serializable_size___i"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a273f48479dce32197d27efa2cbe637ef"></span>int <code class="sig-name descname">serializable_size_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13shared_memory8internal16Serialized_write11serializer_E">
<span id="_CPPv3N13shared_memory8internal16Serialized_write11serializer_E"></span><span id="_CPPv2N13shared_memory8internal16Serialized_write11serializer_E"></span><span id="shared_memory::internal::Serialized_write::serializer___Serializer:Serializable:"></span><span class="target" id="classshared__memory_1_1internal_1_1_serialized__write_1a57ab5f2496bfff9ac5c5a6246aab7e9c"></span>Serializer&lt;Serializable&gt; <code class="sig-name descname">serializer_</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="namespaceshared__memory_1_1internal.html" class="btn btn-neutral float-right" title="Namespace shared_memory::internal" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../namespacelist.html" class="btn btn-neutral float-left" title="Namespace list" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Copyright (c) 2020, New York University and Max Planck Gesellschaft. License under the BSD 3-clause.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>