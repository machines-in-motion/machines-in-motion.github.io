\hypertarget{namespaceshared__memory}{}\section{shared\+\_\+memory Namespace Reference}
\label{namespaceshared__memory}\index{shared\+\_\+memory@{shared\+\_\+memory}}


All templated types in this namespaces are elementary types\+: int, double, float, char$\ast$, ...  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classshared__memory_1_1Allocation__exception}{Allocation\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1array}{array}
\begin{DoxyCompactList}\small\item\em Implement a shared array stored on a shared memory segment. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1ConditionVariable}{Condition\+Variable}
\item 
class \hyperlink{classshared__memory_1_1Exchange__manager__consumer}{Exchange\+\_\+manager\+\_\+consumer}
\item 
class \hyperlink{classshared__memory_1_1Exchange__manager__producer}{Exchange\+\_\+manager\+\_\+producer}
\item 
class \hyperlink{classshared__memory_1_1Four__int__values}{Four\+\_\+int\+\_\+values}
\begin{DoxyCompactList}\small\item\em Example of an instance that can be serialized. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Item}{Item}
\item 
class \hyperlink{classshared__memory_1_1Lock}{Lock}
\begin{DoxyCompactList}\small\item\em A scope lock object for locking a shared memory mutex, to use for example with a shared memory condition variable. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} class is here as a anonymous layer on top of the boost intersprocess condition variable labrary. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Memory__overflow__exception}{Memory\+\_\+overflow\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1Mutex}{Mutex}
\item 
class \hyperlink{classshared__memory_1_1Not__consumed__exception}{Not\+\_\+consumed\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1SegmentInfo}{Segment\+Info}
\begin{DoxyCompactList}\small\item\em encapsulate information related to a shared memory segment \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Serializable__exchange}{Serializable\+\_\+exchange}
\item 
class \hyperlink{classshared__memory_1_1Serializer}{Serializer}
\item 
class \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} contains the pointers of the shared objects in on shared memrory segment. \end{DoxyCompactList}\item 
struct \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper}
\begin{DoxyCompactList}\small\item\em \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper} is a small struct that allow the definition of templated typedef. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Unexpected__map__key}{Unexpected\+\_\+map\+\_\+key}
\item 
class \hyperlink{classshared__memory_1_1Unexpected__size__exception}{Unexpected\+\_\+size\+\_\+exception}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceshared__memory_a98598a317e2364e30dec871c52491d3c}\label{namespaceshared__memory_a98598a317e2364e30dec871c52491d3c}} 
typedef boost\+::interprocess\+::named\+\_\+condition {\bfseries S\+H\+M\+Condition}
\item 
\mbox{\Hypertarget{namespaceshared__memory_aa1e27e85804c1f1c0b7c1bf077add7bf}\label{namespaceshared__memory_aa1e27e85804c1f1c0b7c1bf077add7bf}} 
typedef boost\+::interprocess\+::scoped\+\_\+lock$<$ S\+H\+M\+Mutex $>$ {\bfseries S\+H\+M\+Scope\+Lock}
\item 
\mbox{\Hypertarget{namespaceshared__memory_a2a3aa667d92610e695d7948a834172f1}\label{namespaceshared__memory_a2a3aa667d92610e695d7948a834172f1}} 
typedef boost\+::interprocess\+::interprocess\+\_\+mutex {\bfseries Unamed\+S\+H\+M\+Mutex}
\item 
\mbox{\Hypertarget{namespaceshared__memory_a83b64c7cfca3d52b46e5e9833968a7b9}\label{namespaceshared__memory_a83b64c7cfca3d52b46e5e9833968a7b9}} 
typedef boost\+::interprocess\+::interprocess\+\_\+condition {\bfseries Unamed\+S\+H\+M\+Condition}
\item 
\mbox{\Hypertarget{namespaceshared__memory_a0b94121a6c0d65beda535a70704a1aa5}\label{namespaceshared__memory_a0b94121a6c0d65beda535a70704a1aa5}} 
typedef boost\+::interprocess\+::scoped\+\_\+lock$<$ Unamed\+S\+H\+M\+Mutex $>$ {\bfseries Unamed\+S\+H\+M\+Lock}
\item 
\mbox{\Hypertarget{namespaceshared__memory_a9e455ab41b63e529ceca7424dbf13ba1}\label{namespaceshared__memory_a9e455ab41b63e529ceca7424dbf13ba1}} 
typedef boost\+::interprocess\+::named\+\_\+mutex {\bfseries S\+H\+M\+Mutex}
\item 
\mbox{\Hypertarget{namespaceshared__memory_ada3eeebd8f77a3757ad50c9401bcd249}\label{namespaceshared__memory_ada3eeebd8f77a3757ad50c9401bcd249}} 
typedef cereal\+::access {\bfseries private\+\_\+serialization}
\item 
\mbox{\Hypertarget{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}\label{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}} 
typedef std\+::map$<$ std\+::string, std\+::pair$<$ void $\ast$, std\+::size\+\_\+t $>$ $>$ \hyperlink{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}{Shm\+Objects}
\begin{DoxyCompactList}\small\item\em Shm\+Objects typedef is a simple renaming that ease the for loop writting. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a36a105df63154c883e86f4282f380647}\label{namespaceshared__memory_a36a105df63154c883e86f4282f380647}} 
typedef \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper}$<$ char $>$\+::Elem\+Type\+Allocator \hyperlink{namespaceshared__memory_a36a105df63154c883e86f4282f380647}{Shm\+Char\+Allocator}
\begin{DoxyCompactList}\small\item\em Create a char allocator to ease the creation of strings. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}\label{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}} 
typedef std\+::basic\+\_\+string$<$ char, std\+::char\+\_\+traits$<$ char $>$, \hyperlink{namespaceshared__memory_a36a105df63154c883e86f4282f380647}{Shm\+Char\+Allocator} $>$ \hyperlink{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}{Shm\+String}
\begin{DoxyCompactList}\small\item\em Create a basic\+\_\+string type for the Shared Memory. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}\label{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}} 
typedef std\+::map$<$ std\+::string, std\+::unique\+\_\+ptr$<$ \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} $>$ $>$ \hyperlink{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{Segment\+Map}
\begin{DoxyCompactList}\small\item\em Segment\+Map typedef is a simple short cut to the G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}{clear\+\_\+array} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em wipe the shared memory segment created by an instance of \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}, including mutexes, if any. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a62e06d817f0f52addc9970db9f83e15d}\label{namespaceshared__memory_a62e06d817f0f52addc9970db9f83e15d}} 
static uint {\bfseries get\+\_\+segment\+\_\+size} (size\+\_\+t size\+\_\+array, size\+\_\+t size\+\_\+item)
\item 
void \hyperlink{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}{set\+\_\+segment\+\_\+sizes} (uint multiplier\+\_\+1025)
\begin{DoxyCompactList}\small\item\em sets the size of the segments that will be newly created via the set methods. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}\label{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}} 
void \hyperlink{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}{set\+\_\+default\+\_\+segment\+\_\+sizes} ()
\begin{DoxyCompactList}\small\item\em set the size of segment newly created to the default size value of 65536 \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} \& \hyperlink{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}{get\+\_\+segment} (const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)
\begin{DoxyCompactList}\small\item\em get\+\_\+segment creates or give back a pointer to a \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} object. \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1SegmentInfo}{Segment\+Info} \hyperlink{namespaceshared__memory_a70f7613a247615e323cab083934c803e}{get\+\_\+segment\+\_\+info} (const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)
\begin{DoxyCompactList}\small\item\em performs introspection on the segment and return related information. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}{segment\+\_\+exists} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em returns true if a segment exists under this id \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}{delete\+\_\+segment} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em delete\+\_\+segment deletes the segment of existing shared memory. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}\label{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}} 
void \hyperlink{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}{delete\+\_\+all\+\_\+segment} ()
\begin{DoxyCompactList}\small\item\em delete\+\_\+all\+\_\+segment delete all mapping to the shared memory used during the current process \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\bool \hyperlink{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}{delete\+\_\+object} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id)
\begin{DoxyCompactList}\small\item\em delete\+\_\+object deletes a particular object in the shared memory segment \end{DoxyCompactList}\item 
boost\+::interprocess\+::interprocess\+\_\+mutex \& \hyperlink{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}{get\+\_\+segment\+\_\+mutex} (const std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em get\+\_\+sgement\+\_\+mutex aquiere a reference to the semgent global mutex. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}{clear\+\_\+shared\+\_\+memory} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em clear\+\_\+shared\+\_\+memory\+\_\+segment destroys the shared memory \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to any elementary types in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type $\ast$set\+\_\+, const std\+::size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::string \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a string in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::vector$<$ Elem\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename First\+Type , typename Second\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::pair$<$ First\+Type, Second\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Key\+Type , typename Value\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::map$<$ Key\+Type, Value\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to any elementary types in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type $\ast$get\+\_\+, const std\+::size\+\_\+t expected\+\_\+size)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::string \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a string in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::vector$<$ Elem\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename First\+Type , typename Second\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::pair$<$ First\+Type, Second\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Key\+Type , typename Value\+Type $>$ }\\void \hyperlink{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::map$<$ Key\+Type, Value\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Serializable $>$ }\\void \hyperlink{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}{serialize} (const std\+::string \&segment, const std\+::string \&object, const \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Serialize the instance into a string which is written in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Serializable $>$ }\\void \hyperlink{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}{deserialize} (const std\+::string \&segment, const std\+::string \&object, \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Read from the memory a string that is deserialized into the passed instance of \hyperlink{classSerializable}{Serializable}. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}{set\+\_\+verbose} (bool mode)
\begin{DoxyCompactList}\small\item\em if verbose mode set to true (starting default is false), informaton about newly created objects will be displayed in the terminal. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a653947408c221da4e2c26439ba913f8d}\label{namespaceshared__memory_a653947408c221da4e2c26439ba913f8d}} 
{\footnotesize template$<$typename Vector\+Type , typename Elem\+Type $>$ }\\void {\bfseries set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Vector\+Type \&set\+\_\+)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceshared__memory_adb7d7158652e09188fea583e05949bb5}\label{namespaceshared__memory_adb7d7158652e09188fea583e05949bb5}} 
bool {\bfseries V\+E\+R\+B\+O\+SE} = false
\item 
static \hyperlink{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{Segment\+Map} \hyperlink{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}
\begin{DoxyCompactList}\small\item\em G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+E\+G\+M\+E\+NT is global variable that acts as a a shared memory manager. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceshared__memory_a1aa02b0b88f0045c3711029f882d80fa}\label{namespaceshared__memory_a1aa02b0b88f0045c3711029f882d80fa}} 
static uint {\bfseries S\+E\+G\+M\+E\+N\+T\+\_\+\+S\+I\+ZE} = D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+I\+ZE
\item 
\mbox{\Hypertarget{namespaceshared__memory_a5c687b65860cde45c62305fbb7a19e71}\label{namespaceshared__memory_a5c687b65860cde45c62305fbb7a19e71}} 
static std\+::mutex {\bfseries S\+E\+G\+M\+E\+N\+T\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+U\+T\+EX}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
All templated types in this namespaces are elementary types\+: int, double, float, char$\ast$, ... 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}\label{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!clear\+\_\+array@{clear\+\_\+array}}
\index{clear\+\_\+array@{clear\+\_\+array}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{clear\+\_\+array()}{clear\_array()}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::clear\+\_\+array (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id }\end{DoxyParamCaption})}



wipe the shared memory segment created by an instance of \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}, including mutexes, if any. 

If there are no memory segment of this id, there will be no effect. If \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array} instances are pointing to the wiped out segment, their get and set functions may hang indefinitely. \mbox{\Hypertarget{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}\label{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!clear\+\_\+shared\+\_\+memory@{clear\+\_\+shared\+\_\+memory}}
\index{clear\+\_\+shared\+\_\+memory@{clear\+\_\+shared\+\_\+memory}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{clear\+\_\+shared\+\_\+memory()}{clear\_shared\_memory()}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::clear\+\_\+shared\+\_\+memory (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id }\end{DoxyParamCaption})}



clear\+\_\+shared\+\_\+memory\+\_\+segment destroys the shared memory 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}\label{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!delete\+\_\+object@{delete\+\_\+object}}
\index{delete\+\_\+object@{delete\+\_\+object}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{delete\+\_\+object()}{delete\_object()}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
bool shared\+\_\+memory\+::delete\+\_\+object (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id }\end{DoxyParamCaption})}



delete\+\_\+object deletes a particular object in the shared memory segment 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if everything went fine. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}\label{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!delete\+\_\+segment@{delete\+\_\+segment}}
\index{delete\+\_\+segment@{delete\+\_\+segment}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{delete\+\_\+segment()}{delete\_segment()}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::delete\+\_\+segment (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id }\end{DoxyParamCaption})}



delete\+\_\+segment deletes the segment of existing shared memory. 

it makes sure that all element created in it is destroyed first. (is this needed? I do not know.) 
\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}\label{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{deserialize()}{deserialize()}}
{\footnotesize\ttfamily template$<$class Serializable $>$ \\
void shared\+\_\+memory\+::deserialize (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment,  }\item[{const std\+::string \&}]{object,  }\item[{\hyperlink{classSerializable}{Serializable} \&}]{serializable }\end{DoxyParamCaption})}



Read from the memory a string that is deserialized into the passed instance of \hyperlink{classSerializable}{Serializable}. 

This assumes the serialization and writting in the shared memory has been performed using the serialize function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em serializable} & is the instance in which the string will be deserialized \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}\label{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{Elem\+Type \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get gets a pointer to any elementary types in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}\label{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{Elem\+Type $\ast$}]{get\+\_\+,  }\item[{const std\+::size\+\_\+t}]{expected\+\_\+size }\end{DoxyParamCaption})}



get gets a pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the pointer to the array of objects to set in the memory. \\
\hline
\mbox{\tt in}  & {\em size} & is the array size. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}\label{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{std\+::string \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get gets a pointer to a string in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}\label{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{std\+::vector$<$ Elem\+Type $>$ \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}\label{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get gets a pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}\label{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename First\+Type , typename Second\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{std\+::pair$<$ First\+Type, Second\+Type $>$ \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. 

This is very usefull to dump maps in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}\label{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Key\+Type , typename Value\+Type $>$ \\
void shared\+\_\+memory\+::get (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{std\+::map$<$ Key\+Type, Value\+Type $>$ \&}]{get\+\_\+ }\end{DoxyParamCaption})}



get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}\label{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment@{get\+\_\+segment}}
\index{get\+\_\+segment@{get\+\_\+segment}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get\+\_\+segment()}{get\_segment()}}
{\footnotesize\ttfamily \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} \& shared\+\_\+memory\+::get\+\_\+segment (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const bool}]{clear\+\_\+upon\+\_\+destruction = {\ttfamily false} }\end{DoxyParamCaption})}



get\+\_\+segment creates or give back a pointer to a \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} object. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a70f7613a247615e323cab083934c803e}\label{namespaceshared__memory_a70f7613a247615e323cab083934c803e}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment\+\_\+info@{get\+\_\+segment\+\_\+info}}
\index{get\+\_\+segment\+\_\+info@{get\+\_\+segment\+\_\+info}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get\+\_\+segment\+\_\+info()}{get\_segment\_info()}}
{\footnotesize\ttfamily \hyperlink{classshared__memory_1_1SegmentInfo}{Segment\+Info} shared\+\_\+memory\+::get\+\_\+segment\+\_\+info (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const bool}]{clear\+\_\+upon\+\_\+destruction = {\ttfamily false} }\end{DoxyParamCaption})}



performs introspection on the segment and return related information. 

If the segment does not exists, creates it first. \mbox{\Hypertarget{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}\label{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment\+\_\+mutex@{get\+\_\+segment\+\_\+mutex}}
\index{get\+\_\+segment\+\_\+mutex@{get\+\_\+segment\+\_\+mutex}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{get\+\_\+segment\+\_\+mutex()}{get\_segment\_mutex()}}
{\footnotesize\ttfamily boost\+::interprocess\+::interprocess\+\_\+mutex \& shared\+\_\+memory\+::get\+\_\+segment\+\_\+mutex (\begin{DoxyParamCaption}\item[{const std\+::string}]{segment\+\_\+id }\end{DoxyParamCaption})}



get\+\_\+sgement\+\_\+mutex aquiere a reference to the semgent global mutex. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a reference to a boost mutex 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}\label{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!segment\+\_\+exists@{segment\+\_\+exists}}
\index{segment\+\_\+exists@{segment\+\_\+exists}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{segment\+\_\+exists()}{segment\_exists()}}
{\footnotesize\ttfamily bool shared\+\_\+memory\+::segment\+\_\+exists (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id }\end{DoxyParamCaption})}



returns true if a segment exists under this id 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}\label{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!serialize@{serialize}}
\index{serialize@{serialize}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{serialize()}{serialize()}}
{\footnotesize\ttfamily template$<$class Serializable $>$ \\
void shared\+\_\+memory\+::serialize (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment,  }\item[{const std\+::string \&}]{object,  }\item[{const \hyperlink{classSerializable}{Serializable} \&}]{serializable }\end{DoxyParamCaption})}



Serialize the instance into a string which is written in the shared memory. 

This uses cereal for serialization, and \hyperlink{classSerializable}{Serializable} must implement a serialize function, see\+: \href{https://uscilab.github.io/cereal/}{\tt https\+://uscilab.\+github.\+io/cereal/} 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em serializable} & is the instance to serialize \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}\label{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const Elem\+Type \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to any elementary types in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}\label{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const Elem\+Type $\ast$}]{set\+\_\+,  }\item[{const std\+::size\+\_\+t}]{size }\end{DoxyParamCaption})}



set instanciates or get pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the pointer to the array of objects to set in the memory. \\
\hline
\mbox{\tt in}  & {\em size} & is the array size. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}\label{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const std\+::string \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to a string in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}\label{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const std\+::vector$<$ Elem\+Type $>$ \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}\label{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename Elem\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}\label{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename First\+Type , typename Second\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const std\+::pair$<$ First\+Type, Second\+Type $>$ \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. 

This is very usefull to dump maps in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}\label{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set()}{set()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Key\+Type , typename Value\+Type $>$ \\
void shared\+\_\+memory\+::set (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{segment\+\_\+id,  }\item[{const std\+::string \&}]{object\+\_\+id,  }\item[{const std\+::map$<$ Key\+Type, Value\+Type $>$ \&}]{set\+\_\+ }\end{DoxyParamCaption})}



set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}\label{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set\+\_\+segment\+\_\+sizes@{set\+\_\+segment\+\_\+sizes}}
\index{set\+\_\+segment\+\_\+sizes@{set\+\_\+segment\+\_\+sizes}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set\+\_\+segment\+\_\+sizes()}{set\_segment\_sizes()}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::set\+\_\+segment\+\_\+sizes (\begin{DoxyParamCaption}\item[{uint}]{multiplier\+\_\+1025 }\end{DoxyParamCaption})}



sets the size of the segments that will be newly created via the set methods. 

Until this function is called, segments are created with a size of 65536 bytes. This function is not interprocess \+: it will set the size of segments created in the current process 
\begin{DoxyParams}{Parameters}
{\em multiplier\+\_\+1025} & the size of create segment will be multiplier\+\_\+1025 $\ast$ 1025 bytes (because memory segment sizes have to be a multiple of 1025) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}\label{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!set\+\_\+verbose@{set\+\_\+verbose}}
\index{set\+\_\+verbose@{set\+\_\+verbose}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{set\+\_\+verbose()}{set\_verbose()}}
{\footnotesize\ttfamily void shared\+\_\+memory\+::set\+\_\+verbose (\begin{DoxyParamCaption}\item[{bool}]{mode }\end{DoxyParamCaption})}



if verbose mode set to true (starting default is false), informaton about newly created objects will be displayed in the terminal. 

Call to this function will change the verbose mode only for the current process. 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}\label{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}} 
\index{shared\+\_\+memory@{shared\+\_\+memory}!G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS@{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}}
\index{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS@{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection{\texorpdfstring{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}{GLOBAL\_SHM\_SEGMENTS}}
{\footnotesize\ttfamily \hyperlink{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{Segment\+Map} shared\+\_\+memory\+::\+G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS\hspace{0.3cm}{\ttfamily [static]}}



G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+E\+G\+M\+E\+NT is global variable that acts as a a shared memory manager. 

The use of the std\+::unique\+\_\+ptr allows to delete the object and re-\/create at will. 