\hypertarget{namespaceshared__memory}{}\section{shared\+\_\+memory Namespace Reference}
\label{namespaceshared__memory}\index{shared\+\_\+memory@{shared\+\_\+memory}}


All templated types in this namespaces are elementary types\+: int, double, float, char$\ast$, ...  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classshared__memory_1_1Allocation__exception}{Allocation\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1array}{array}
\begin{DoxyCompactList}\small\item\em Implement a shared array stored on a shared memory segment. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1ConditionVariable}{Condition\+Variable}
\item 
class \hyperlink{classshared__memory_1_1Exchange__manager__consumer}{Exchange\+\_\+manager\+\_\+consumer}
\item 
class \hyperlink{classshared__memory_1_1Exchange__manager__producer}{Exchange\+\_\+manager\+\_\+producer}
\item 
class \hyperlink{classshared__memory_1_1Four__int__values}{Four\+\_\+int\+\_\+values}
\begin{DoxyCompactList}\small\item\em Example of an instance that can be serialized. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Item}{Item}
\item 
class \hyperlink{classshared__memory_1_1Lock}{Lock}
\begin{DoxyCompactList}\small\item\em A scope lock object for locking a shared memory mutex, to use for example with a shared memory condition variable. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} class is here as a anonymous layer on top of the boost intersprocess condition variable labrary. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Memory__overflow__exception}{Memory\+\_\+overflow\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1Mutex}{Mutex}
\item 
class \hyperlink{classshared__memory_1_1Not__consumed__exception}{Not\+\_\+consumed\+\_\+exception}
\item 
class \hyperlink{classshared__memory_1_1SegmentInfo}{Segment\+Info}
\begin{DoxyCompactList}\small\item\em encapsulate information related to a shared memory segment \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Serializable__exchange}{Serializable\+\_\+exchange}
\item 
class \hyperlink{classshared__memory_1_1Serializer}{Serializer}
\item 
class \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} contains the pointers of the shared objects in on shared memrory segment. \end{DoxyCompactList}\item 
struct \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper}
\begin{DoxyCompactList}\small\item\em \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper} is a small struct that allow the definition of templated typedef. \end{DoxyCompactList}\item 
class \hyperlink{classshared__memory_1_1Unexpected__map__key}{Unexpected\+\_\+map\+\_\+key}
\item 
class \hyperlink{classshared__memory_1_1Unexpected__size__exception}{Unexpected\+\_\+size\+\_\+exception}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef boost\+::interprocess\+::named\+\_\+condition {\bfseries S\+H\+M\+Condition}\hypertarget{namespaceshared__memory_a98598a317e2364e30dec871c52491d3c}{}\label{namespaceshared__memory_a98598a317e2364e30dec871c52491d3c}

\item 
typedef std\+::integral\+\_\+constant$<$ int, 0 $>$ {\bfseries S\+E\+R\+I\+A\+L\+I\+Z\+A\+B\+LE}\hypertarget{namespaceshared__memory_af5f7fb7bbbc4c6334d59d0cd09f3ba85}{}\label{namespaceshared__memory_af5f7fb7bbbc4c6334d59d0cd09f3ba85}

\item 
typedef std\+::integral\+\_\+constant$<$ int, 1 $>$ {\bfseries F\+U\+N\+D\+A\+M\+E\+N\+T\+AL}\hypertarget{namespaceshared__memory_a391f1de569d6b76979d6ff4591513bfd}{}\label{namespaceshared__memory_a391f1de569d6b76979d6ff4591513bfd}

\item 
typedef std\+::integral\+\_\+constant$<$ int, 2 $>$ {\bfseries F\+U\+N\+D\+A\+M\+E\+N\+T\+A\+L\+\_\+\+A\+R\+R\+AY}\hypertarget{namespaceshared__memory_a641fa51f2069f15b1dfb114e630fc1ba}{}\label{namespaceshared__memory_a641fa51f2069f15b1dfb114e630fc1ba}

\item 
typedef boost\+::interprocess\+::scoped\+\_\+lock$<$ S\+H\+M\+Mutex $>$ {\bfseries S\+H\+M\+Scope\+Lock}\hypertarget{namespaceshared__memory_aa1e27e85804c1f1c0b7c1bf077add7bf}{}\label{namespaceshared__memory_aa1e27e85804c1f1c0b7c1bf077add7bf}

\item 
typedef boost\+::interprocess\+::interprocess\+\_\+mutex {\bfseries Unamed\+S\+H\+M\+Mutex}\hypertarget{namespaceshared__memory_a2a3aa667d92610e695d7948a834172f1}{}\label{namespaceshared__memory_a2a3aa667d92610e695d7948a834172f1}

\item 
typedef boost\+::interprocess\+::interprocess\+\_\+condition {\bfseries Unamed\+S\+H\+M\+Condition}\hypertarget{namespaceshared__memory_a83b64c7cfca3d52b46e5e9833968a7b9}{}\label{namespaceshared__memory_a83b64c7cfca3d52b46e5e9833968a7b9}

\item 
typedef boost\+::interprocess\+::scoped\+\_\+lock$<$ Unamed\+S\+H\+M\+Mutex $>$ {\bfseries Unamed\+S\+H\+M\+Lock}\hypertarget{namespaceshared__memory_a0b94121a6c0d65beda535a70704a1aa5}{}\label{namespaceshared__memory_a0b94121a6c0d65beda535a70704a1aa5}

\item 
typedef boost\+::interprocess\+::named\+\_\+mutex {\bfseries S\+H\+M\+Mutex}\hypertarget{namespaceshared__memory_a9e455ab41b63e529ceca7424dbf13ba1}{}\label{namespaceshared__memory_a9e455ab41b63e529ceca7424dbf13ba1}

\item 
typedef cereal\+::access {\bfseries private\+\_\+serialization}\hypertarget{namespaceshared__memory_ada3eeebd8f77a3757ad50c9401bcd249}{}\label{namespaceshared__memory_ada3eeebd8f77a3757ad50c9401bcd249}

\item 
typedef std\+::map$<$ std\+::string, std\+::pair$<$ void $\ast$, std\+::size\+\_\+t $>$ $>$ \hyperlink{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}{Shm\+Objects}\hypertarget{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}{}\label{namespaceshared__memory_ae50b2192256821112a69e47d5314b467}

\begin{DoxyCompactList}\small\item\em Shm\+Objects typedef is a simple renaming that ease the for loop writting. \end{DoxyCompactList}\item 
typedef \hyperlink{structshared__memory_1_1ShmTypeHelper}{Shm\+Type\+Helper}$<$ char $>$\+::Elem\+Type\+Allocator \hyperlink{namespaceshared__memory_a36a105df63154c883e86f4282f380647}{Shm\+Char\+Allocator}\hypertarget{namespaceshared__memory_a36a105df63154c883e86f4282f380647}{}\label{namespaceshared__memory_a36a105df63154c883e86f4282f380647}

\begin{DoxyCompactList}\small\item\em Create a char allocator to ease the creation of strings. \end{DoxyCompactList}\item 
typedef std\+::basic\+\_\+string$<$ char, std\+::char\+\_\+traits$<$ char $>$, \hyperlink{namespaceshared__memory_a36a105df63154c883e86f4282f380647}{Shm\+Char\+Allocator} $>$ \hyperlink{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}{Shm\+String}\hypertarget{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}{}\label{namespaceshared__memory_a07ee51d077030d33ba8408f5938569cc}

\begin{DoxyCompactList}\small\item\em Create a basic\+\_\+string type for the Shared Memory. \end{DoxyCompactList}\item 
typedef std\+::map$<$ std\+::string, std\+::unique\+\_\+ptr$<$ \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} $>$ $>$ \hyperlink{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{Segment\+Map}\hypertarget{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{}\label{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}

\begin{DoxyCompactList}\small\item\em Segment\+Map typedef is a simple short cut to the G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}{clear\+\_\+array} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em wipe the shared memory segment created by an instance of \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}, including mutexes, if any. \end{DoxyCompactList}\item 
static uint {\bfseries get\+\_\+segment\+\_\+size} (size\+\_\+t size\+\_\+array, size\+\_\+t size\+\_\+item)\hypertarget{namespaceshared__memory_a62e06d817f0f52addc9970db9f83e15d}{}\label{namespaceshared__memory_a62e06d817f0f52addc9970db9f83e15d}

\item 
void \hyperlink{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}{set\+\_\+segment\+\_\+sizes} (uint multiplier\+\_\+1025)
\begin{DoxyCompactList}\small\item\em sets the size of the segments that will be newly created via the set methods. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}{set\+\_\+default\+\_\+segment\+\_\+sizes} ()\hypertarget{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}{}\label{namespaceshared__memory_a841687861fcc9efe381ffbe84843ca33}

\begin{DoxyCompactList}\small\item\em set the size of segment newly created to the default size value of 65536 \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} \& \hyperlink{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}{get\+\_\+segment} (const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)
\begin{DoxyCompactList}\small\item\em get\+\_\+segment creates or give back a pointer to a \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} object. \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1SegmentInfo}{Segment\+Info} \hyperlink{namespaceshared__memory_a70f7613a247615e323cab083934c803e}{get\+\_\+segment\+\_\+info} (const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)
\begin{DoxyCompactList}\small\item\em performs introspection on the segment and return related information. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}{segment\+\_\+exists} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em returns true if a segment exists under this id \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}{delete\+\_\+segment} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em delete\+\_\+segment deletes the segment of existing shared memory. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}{delete\+\_\+all\+\_\+segment} ()\hypertarget{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}{}\label{namespaceshared__memory_a1f88dd41dca9a23387090866213dbd85}

\begin{DoxyCompactList}\small\item\em delete\+\_\+all\+\_\+segment delete all mapping to the shared memory used during the current process \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\bool \hyperlink{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}{delete\+\_\+object} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id)
\begin{DoxyCompactList}\small\item\em delete\+\_\+object deletes a particular object in the shared memory segment \end{DoxyCompactList}\item 
boost\+::interprocess\+::interprocess\+\_\+mutex \& \hyperlink{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}{get\+\_\+segment\+\_\+mutex} (const std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em get\+\_\+sgement\+\_\+mutex aquiere a reference to the semgent global mutex. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}{clear\+\_\+shared\+\_\+memory} (const std\+::string \&segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em clear\+\_\+shared\+\_\+memory\+\_\+segment destroys the shared memory \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to any elementary types in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type $\ast$set\+\_\+, const std\+::size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::string \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a string in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::vector$<$ Elem\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename First\+Type , typename Second\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::pair$<$ First\+Type, Second\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Key\+Type , typename Value\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}{set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::map$<$ Key\+Type, Value\+Type $>$ \&set\+\_\+)
\begin{DoxyCompactList}\small\item\em set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to any elementary types in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type $\ast$get\+\_\+, const std\+::size\+\_\+t expected\+\_\+size)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::string \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a string in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::vector$<$ Elem\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename First\+Type , typename Second\+Type $>$ }\\void \hyperlink{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::pair$<$ First\+Type, Second\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Key\+Type , typename Value\+Type $>$ }\\void \hyperlink{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}{get} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::map$<$ Key\+Type, Value\+Type $>$ \&get\+\_\+)
\begin{DoxyCompactList}\small\item\em get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Serializable $>$ }\\void \hyperlink{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}{serialize} (const std\+::string \&segment, const std\+::string \&object, const \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Serialize the instance into a string which is written in the shared memory. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Serializable $>$ }\\void \hyperlink{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}{deserialize} (const std\+::string \&segment, const std\+::string \&object, \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Read from the memory a string that is deserialized into the passed instance of \hyperlink{classSerializable}{Serializable}. \end{DoxyCompactList}\item 
void \hyperlink{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}{set\+\_\+verbose} (bool mode)
\begin{DoxyCompactList}\small\item\em if verbose mode set to true (starting default is false), informaton about newly created objects will be displayed in the terminal. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vector\+Type , typename Elem\+Type $>$ }\\void {\bfseries set} (const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Vector\+Type \&set\+\_\+)\hypertarget{namespaceshared__memory_a653947408c221da4e2c26439ba913f8d}{}\label{namespaceshared__memory_a653947408c221da4e2c26439ba913f8d}

\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
bool {\bfseries V\+E\+R\+B\+O\+SE} = false\hypertarget{namespaceshared__memory_adb7d7158652e09188fea583e05949bb5}{}\label{namespaceshared__memory_adb7d7158652e09188fea583e05949bb5}

\item 
static \hyperlink{namespaceshared__memory_a9aeebdfb6185497cac7c093cf3d765c5}{Segment\+Map} \hyperlink{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}
\begin{DoxyCompactList}\small\item\em G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+E\+G\+M\+E\+NT is global variable that acts as a a shared memory manager. \end{DoxyCompactList}\item 
static uint {\bfseries S\+E\+G\+M\+E\+N\+T\+\_\+\+S\+I\+ZE} = D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+I\+ZE\hypertarget{namespaceshared__memory_a1aa02b0b88f0045c3711029f882d80fa}{}\label{namespaceshared__memory_a1aa02b0b88f0045c3711029f882d80fa}

\item 
static std\+::mutex {\bfseries S\+E\+G\+M\+E\+N\+T\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+U\+T\+EX}\hypertarget{namespaceshared__memory_a5c687b65860cde45c62305fbb7a19e71}{}\label{namespaceshared__memory_a5c687b65860cde45c62305fbb7a19e71}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
All templated types in this namespaces are elementary types\+: int, double, float, char$\ast$, ... 

\subsection{Function Documentation}
\index{shared\+\_\+memory@{shared\+\_\+memory}!clear\+\_\+array@{clear\+\_\+array}}
\index{clear\+\_\+array@{clear\+\_\+array}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{clear\+\_\+array(std\+::string segment\+\_\+id)}{clear_array(std::string segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::clear\+\_\+array (
\begin{DoxyParamCaption}
\item[{std\+::string}]{segment\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}{}\label{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}


wipe the shared memory segment created by an instance of \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}, including mutexes, if any. 

If there are no memory segment of this id, there will be no effect. If \hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array} instances are pointing to the wiped out segment, their get and set functions may hang indefinitely. \index{shared\+\_\+memory@{shared\+\_\+memory}!clear\+\_\+shared\+\_\+memory@{clear\+\_\+shared\+\_\+memory}}
\index{clear\+\_\+shared\+\_\+memory@{clear\+\_\+shared\+\_\+memory}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{clear\+\_\+shared\+\_\+memory(const std\+::string \&segment\+\_\+id)}{clear_shared_memory(const std::string &segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::clear\+\_\+shared\+\_\+memory (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}{}\label{namespaceshared__memory_aa8583540879db53fc80b31410b5eec68}


clear\+\_\+shared\+\_\+memory\+\_\+segment destroys the shared memory 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!delete\+\_\+object@{delete\+\_\+object}}
\index{delete\+\_\+object@{delete\+\_\+object}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{delete\+\_\+object(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id)}{delete_object(const std::string &segment_id, const std::string &object_id)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ bool shared\+\_\+memory\+::delete\+\_\+object (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}{}\label{namespaceshared__memory_a7b43b29fa0aa6a5cad0ca47afdd03e83}


delete\+\_\+object deletes a particular object in the shared memory segment 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if everything went fine. 
\end{DoxyReturn}
\index{shared\+\_\+memory@{shared\+\_\+memory}!delete\+\_\+segment@{delete\+\_\+segment}}
\index{delete\+\_\+segment@{delete\+\_\+segment}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{delete\+\_\+segment(const std\+::string \&segment\+\_\+id)}{delete_segment(const std::string &segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::delete\+\_\+segment (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}{}\label{namespaceshared__memory_a60cbce63ae7fb64a2758b773f9006471}


delete\+\_\+segment deletes the segment of existing shared memory. 

it makes sure that all element created in it is destroyed first. (is this needed? I do not know.) 
\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{deserialize(const std\+::string \&segment, const std\+::string \&object, Serializable \&serializable)}{deserialize(const std::string &segment, const std::string &object, Serializable &serializable)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable $>$ void shared\+\_\+memory\+::deserialize (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment, }
\item[{const std\+::string \&}]{object, }
\item[{{\bf Serializable} \&}]{serializable}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}{}\label{namespaceshared__memory_a33e39adccccefb603e2dafc7ea8733e8}


Read from the memory a string that is deserialized into the passed instance of \hyperlink{classSerializable}{Serializable}. 

This assumes the serialization and writting in the shared memory has been performed using the serialize function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em serializable} & is the instance in which the string will be deserialized \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, ElemType &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{Elem\+Type \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}{}\label{namespaceshared__memory_ad017562102dbe044db2de6c79c0669d3}


get gets a pointer to any elementary types in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Elem\+Type $\ast$get\+\_\+, const std\+::size\+\_\+t expected\+\_\+size)}{get(const std::string &segment_id, const std::string &object_id, ElemType *get_, const std::size_t expected_size)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{Elem\+Type $\ast$}]{get\+\_\+, }
\item[{const std\+::size\+\_\+t}]{expected\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}{}\label{namespaceshared__memory_a6241b9143a2152b0c0beb784869373c7}


get gets a pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the pointer to the array of objects to set in the memory. \\
\hline
\mbox{\tt in}  & {\em size} & is the array size. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::string \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, std::string &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{std\+::string \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}{}\label{namespaceshared__memory_a8a952cc446e3dce8fea8cd1ea02613f9}


get gets a pointer to a string in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::vector$<$ Elem\+Type $>$ \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, std::vector< ElemType > &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{std\+::vector$<$ Elem\+Type $>$ \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}{}\label{namespaceshared__memory_afd0ab66344562f5d927dea0d319a6a08}


get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, Eigen::Matrix< ElemType, Eigen::Dynamic, 1 > &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}{}\label{namespaceshared__memory_a4e230e55e38089aee71cd6df93110174}


get gets a pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::pair$<$ First\+Type, Second\+Type $>$ \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, std::pair< FirstType, SecondType > &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename First\+Type , typename Second\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{std\+::pair$<$ First\+Type, Second\+Type $>$ \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}{}\label{namespaceshared__memory_a2579e9a10a16e0fbd006900c618addc8}


get instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. 

This is very usefull to dump maps in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get@{get}}
\index{get@{get}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, std\+::map$<$ Key\+Type, Value\+Type $>$ \&get\+\_\+)}{get(const std::string &segment_id, const std::string &object_id, std::map< KeyType, ValueType > &get_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Key\+Type , typename Value\+Type $>$ void shared\+\_\+memory\+::get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{std\+::map$<$ Key\+Type, Value\+Type $>$ \&}]{get\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}{}\label{namespaceshared__memory_add6604c2716e51cdcf17de2439251089}


get gets a pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em get\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment@{get\+\_\+segment}}
\index{get\+\_\+segment@{get\+\_\+segment}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get\+\_\+segment(const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)}{get_segment(const std::string &segment_id, const bool clear_upon_destruction=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Shared\+Memory\+Segment} \& shared\+\_\+memory\+::get\+\_\+segment (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const bool}]{clear\+\_\+upon\+\_\+destruction = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}{}\label{namespaceshared__memory_a7c76ec22ab70d3b7487becd3ec9943bc}


get\+\_\+segment creates or give back a pointer to a \hyperlink{classshared__memory_1_1SharedMemorySegment}{Shared\+Memory\+Segment} object. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment\+\_\+info@{get\+\_\+segment\+\_\+info}}
\index{get\+\_\+segment\+\_\+info@{get\+\_\+segment\+\_\+info}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get\+\_\+segment\+\_\+info(const std\+::string \&segment\+\_\+id, const bool clear\+\_\+upon\+\_\+destruction=false)}{get_segment_info(const std::string &segment_id, const bool clear_upon_destruction=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Segment\+Info} shared\+\_\+memory\+::get\+\_\+segment\+\_\+info (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const bool}]{clear\+\_\+upon\+\_\+destruction = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a70f7613a247615e323cab083934c803e}{}\label{namespaceshared__memory_a70f7613a247615e323cab083934c803e}


performs introspection on the segment and return related information. 

If the segment does not exists, creates it first. \index{shared\+\_\+memory@{shared\+\_\+memory}!get\+\_\+segment\+\_\+mutex@{get\+\_\+segment\+\_\+mutex}}
\index{get\+\_\+segment\+\_\+mutex@{get\+\_\+segment\+\_\+mutex}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{get\+\_\+segment\+\_\+mutex(const std\+::string segment\+\_\+id)}{get_segment_mutex(const std::string segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}boost\+::interprocess\+::interprocess\+\_\+mutex \& shared\+\_\+memory\+::get\+\_\+segment\+\_\+mutex (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{segment\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}{}\label{namespaceshared__memory_aed33c9701140a1c43e40f182a380199b}


get\+\_\+sgement\+\_\+mutex aquiere a reference to the semgent global mutex. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a reference to a boost mutex 
\end{DoxyReturn}
\index{shared\+\_\+memory@{shared\+\_\+memory}!segment\+\_\+exists@{segment\+\_\+exists}}
\index{segment\+\_\+exists@{segment\+\_\+exists}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{segment\+\_\+exists(const std\+::string \&segment\+\_\+id)}{segment_exists(const std::string &segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}bool shared\+\_\+memory\+::segment\+\_\+exists (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}{}\label{namespaceshared__memory_a82297c2b7b85c57c53578749c9bd6429}


returns true if a segment exists under this id 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!serialize@{serialize}}
\index{serialize@{serialize}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{serialize(const std\+::string \&segment, const std\+::string \&object, const Serializable \&serializable)}{serialize(const std::string &segment, const std::string &object, const Serializable &serializable)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable $>$ void shared\+\_\+memory\+::serialize (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment, }
\item[{const std\+::string \&}]{object, }
\item[{const {\bf Serializable} \&}]{serializable}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}{}\label{namespaceshared__memory_a003005dc269ebf79f08523dc0f8d1ed0}


Serialize the instance into a string which is written in the shared memory. 

This uses cereal for serialization, and \hyperlink{classSerializable}{Serializable} must implement a serialize function, see\+: \href{https://uscilab.github.io/cereal/}{\tt https\+://uscilab.\+github.\+io/cereal/} 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em serializable} & is the instance to serialize \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const ElemType &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const Elem\+Type \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}{}\label{namespaceshared__memory_ace68bf582cfe50ba83a9cfc9b7aed3b2}


set instanciates or get pointer to any elementary types in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Elem\+Type $\ast$set\+\_\+, const std\+::size\+\_\+t size)}{set(const std::string &segment_id, const std::string &object_id, const ElemType *set_, const std::size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const Elem\+Type $\ast$}]{set\+\_\+, }
\item[{const std\+::size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}{}\label{namespaceshared__memory_a7e37a0a2146d2cfeeccb63390a3d9132}


set instanciates or get pointer to a fixed sized array of the templated type \char`\"{}\+T\char`\"{} in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the pointer to the array of objects to set in the memory. \\
\hline
\mbox{\tt in}  & {\em size} & is the array size. \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::string \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const std::string &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const std\+::string \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}{}\label{namespaceshared__memory_a61a2945c994bcbe84cc8dce96a189edb}


set instanciates or get pointer to a string in the shared memory. 

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::vector$<$ Elem\+Type $>$ \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const std::vector< ElemType > &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const std\+::vector$<$ Elem\+Type $>$ \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}{}\label{namespaceshared__memory_ac6521a6731fa97be21779b1d6c7589ee}


set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const Eigen::Matrix< ElemType, Eigen::Dynamic, 1 > &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const Eigen\+::\+Matrix$<$ Elem\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}{}\label{namespaceshared__memory_ac8364e5cde6c8a2f1abc2a59035f26a6}


set instanciates or get pointer to a Eigen\+::\+Matrix$<$\+Elem\+Type, Eigen\+::\+Dynamic, 1$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::pair$<$ First\+Type, Second\+Type $>$ \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const std::pair< FirstType, SecondType > &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename First\+Type , typename Second\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const std\+::pair$<$ First\+Type, Second\+Type $>$ \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}{}\label{namespaceshared__memory_a657bb799483a19a96f61706b50aca1e7}


set instanciates or get pointer to a std\+::pair$<$\+First\+Type, Second\+Type$>$ in the shared memory. 

This is very usefull to dump maps in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set@{set}}
\index{set@{set}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set(const std\+::string \&segment\+\_\+id, const std\+::string \&object\+\_\+id, const std\+::map$<$ Key\+Type, Value\+Type $>$ \&set\+\_\+)}{set(const std::string &segment_id, const std::string &object_id, const std::map< KeyType, ValueType > &set_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Key\+Type , typename Value\+Type $>$ void shared\+\_\+memory\+::set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{segment\+\_\+id, }
\item[{const std\+::string \&}]{object\+\_\+id, }
\item[{const std\+::map$<$ Key\+Type, Value\+Type $>$ \&}]{set\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}{}\label{namespaceshared__memory_a562e79433e54463f39c9c276b8440f4b}


set instanciates or get pointer to a std\+::vector$<$\+Elem\+Type$>$ or an Eigen\+::\+Matrix$<$\+Elem\+Type, any, any$>$ in the shared memory. 

This will translated as a fixed sized array in the shared memory

All set functions make sure that the pointer is uniquely created to avoid useless computation time consumption.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em segment\+\_\+id} & is the name of the shared memory segment. \\
\hline
\mbox{\tt in}  & {\em object\+\_\+id} & is the name of the shared memory object to set. \\
\hline
\mbox{\tt in}  & {\em set\+\_\+} & is the string to be created in the shared memory \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set\+\_\+segment\+\_\+sizes@{set\+\_\+segment\+\_\+sizes}}
\index{set\+\_\+segment\+\_\+sizes@{set\+\_\+segment\+\_\+sizes}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set\+\_\+segment\+\_\+sizes(uint multiplier\+\_\+1025)}{set_segment_sizes(uint multiplier_1025)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::set\+\_\+segment\+\_\+sizes (
\begin{DoxyParamCaption}
\item[{uint}]{multiplier\+\_\+1025}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}{}\label{namespaceshared__memory_ac8ef94dc78f444092f488f0143b155f2}


sets the size of the segments that will be newly created via the set methods. 

Until this function is called, segments are created with a size of 65536 bytes. This function is not interprocess \+: it will set the size of segments created in the current process 
\begin{DoxyParams}{Parameters}
{\em multiplier\+\_\+1025} & the size of create segment will be multiplier\+\_\+1025 $\ast$ 1025 bytes (because memory segment sizes have to be a multiple of 1025) \\
\hline
\end{DoxyParams}
\index{shared\+\_\+memory@{shared\+\_\+memory}!set\+\_\+verbose@{set\+\_\+verbose}}
\index{set\+\_\+verbose@{set\+\_\+verbose}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{set\+\_\+verbose(bool mode)}{set_verbose(bool mode)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::set\+\_\+verbose (
\begin{DoxyParamCaption}
\item[{bool}]{mode}
\end{DoxyParamCaption}
)}\hypertarget{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}{}\label{namespaceshared__memory_afe26d531f043f59bb36ea7816b8a40bf}


if verbose mode set to true (starting default is false), informaton about newly created objects will be displayed in the terminal. 

Call to this function will change the verbose mode only for the current process. 

\subsection{Variable Documentation}
\index{shared\+\_\+memory@{shared\+\_\+memory}!G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS@{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}}
\index{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS@{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}!shared\+\_\+memory@{shared\+\_\+memory}}
\subsubsection[{\texorpdfstring{G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS}{GLOBAL_SHM_SEGMENTS}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Segment\+Map} shared\+\_\+memory\+::\+G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+M\+\_\+\+S\+E\+G\+M\+E\+N\+TS\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}{}\label{namespaceshared__memory_ad1f78482aa062e165f37fd49e2e8f539}


G\+L\+O\+B\+A\+L\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+S\+E\+G\+M\+E\+NT is global variable that acts as a a shared memory manager. 

The use of the std\+::unique\+\_\+ptr allows to delete the object and re-\/create at will. 