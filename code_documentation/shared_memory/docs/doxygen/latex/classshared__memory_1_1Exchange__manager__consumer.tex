\hypertarget{classshared__memory_1_1Exchange__manager__consumer}{}\section{shared\+\_\+memory\+:\+:Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ Class Template Reference}
\label{classshared__memory_1_1Exchange__manager__consumer}\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}{Exchange\+\_\+manager\+\_\+consumer} (std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)
\begin{DoxyCompactList}\small\item\em An exchange\+\_\+manager\+\_\+consumer reads from the shared memory serialized items produced by an instance of exchange\+\_\+manager\+\_\+producer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}{lock} ()
\begin{DoxyCompactList}\small\item\em lock the mutex required for writting in the shared memory without any collision with any producer. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}{unlock} ()
\begin{DoxyCompactList}\small\item\em unlock the mutex for writting in the shared memory without any collision with any producer. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}{consume} (\hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em read from the underlying shared memory a serialized object (set by a producer). \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}{ready\+\_\+to\+\_\+consume} ()
\begin{DoxyCompactList}\small\item\em returns true if a producer is also running. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}{purge\+\_\+feedbacks} ()
\begin{DoxyCompactList}\small\item\em When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). \end{DoxyCompactList}\item 
int \hyperlink{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}{nb\+\_\+char\+\_\+read} ()
\begin{DoxyCompactList}\small\item\em returns the number of char that have been read from the exchange queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5c4f6ecbd5c18915923048e1c9067112}\label{classshared__memory_1_1Exchange__manager__consumer_a5c4f6ecbd5c18915923048e1c9067112}} 
bool {\bfseries is\+\_\+producer\+\_\+queue\+\_\+empty} () const
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a1f853781c308a063f28cbfc6ecc90739}\label{classshared__memory_1_1Exchange__manager__consumer_a1f853781c308a063f28cbfc6ecc90739}} 
bool {\bfseries is\+\_\+consumer\+\_\+queue\+\_\+empty} () const
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5aeebd5f2857f73c91fe3212d274909e}\label{classshared__memory_1_1Exchange__manager__consumer_a5aeebd5f2857f73c91fe3212d274909e}} 
static void {\bfseries clean\+\_\+mutex} (std\+::string segment\+\_\+id)
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a828a56d15a0f68edd8e3b395c41b0c0c}\label{classshared__memory_1_1Exchange__manager__consumer_a828a56d15a0f68edd8e3b395c41b0c0c}} 
static void {\bfseries clean\+\_\+memory} (std\+::string segment\+\_\+id)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a1699ba86d1d5b943d428fc1b391abd42}\label{classshared__memory_1_1Exchange__manager__consumer_a1699ba86d1d5b943d428fc1b391abd42}} 
typedef Exchange\+\_\+manager\+\_\+memory$<$ \hyperlink{classSerializable}{Serializable}, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ {\bfseries Memory}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a92ad5c787b53c26d5b3c75712ca539f3}\label{classshared__memory_1_1Exchange__manager__consumer_a92ad5c787b53c26d5b3c75712ca539f3}} 
typedef std\+::shared\+\_\+ptr$<$ Memory $>$ {\bfseries Memory\+\_\+ptr}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a7543d28030c9c3e17b8fd60facc917b2}\label{classshared__memory_1_1Exchange__manager__consumer_a7543d28030c9c3e17b8fd60facc917b2}} 
void {\bfseries reset} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a65f7ea81649be03ac11b11bc998d5047}\label{classshared__memory_1_1Exchange__manager__consumer_a65f7ea81649be03ac11b11bc998d5047}} 
Memory\+\_\+ptr {\bfseries memory\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a3d2838c1a3e709dafe1c941f217d8f54}\label{classshared__memory_1_1Exchange__manager__consumer_a3d2838c1a3e709dafe1c941f217d8f54}} 
bool {\bfseries leading\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a6ea7ce15b0da981027f80d3d35825593}\label{classshared__memory_1_1Exchange__manager__consumer_a6ea7ce15b0da981027f80d3d35825593}} 
bool {\bfseries autolock\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a830f88a2c6f6d3cf6e0c83353a436742}\label{classshared__memory_1_1Exchange__manager__consumer_a830f88a2c6f6d3cf6e0c83353a436742}} 
std\+::string {\bfseries segment\+\_\+id\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_afbde973522ab55b0a3c49ef6f26fbba5}\label{classshared__memory_1_1Exchange__manager__consumer_afbde973522ab55b0a3c49ef6f26fbba5}} 
std\+::string {\bfseries object\+\_\+id\+\_\+}
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}\label{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!Exchange\+\_\+manager\+\_\+consumer@{Exchange\+\_\+manager\+\_\+consumer}}
\index{Exchange\+\_\+manager\+\_\+consumer@{Exchange\+\_\+manager\+\_\+consumer}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{Exchange\+\_\+manager\+\_\+consumer()}{Exchange\_manager\_consumer()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
Exchange\+\_\+manager\+\_\+consumer\+::\+Exchange\+\_\+manager\+\_\+consumer (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id,  }\item[{std\+::string}]{object\+\_\+id,  }\item[{bool}]{leading,  }\item[{bool}]{autolock = {\ttfamily true} }\end{DoxyParamCaption})}



An exchange\+\_\+manager\+\_\+consumer reads from the shared memory serialized items produced by an instance of exchange\+\_\+manager\+\_\+producer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & id of the shared memory segment \\
\hline
{\em object\+\_\+id} & id of the shared memory object prefix \\
\hline
{\em the} & consumer is to be \char`\"{}permanent\char`\"{}, while different producers may provide data. Implies the deletion of the underlying share memory upon destruction. \\
\hline
{\em mutex} & locking mechanism internally managed by the producer. If false, lock has to be \char`\"{}manually\char`\"{} called. This allows for example to set several items in one shot \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}\label{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!consume@{consume}}
\index{consume@{consume}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{consume()}{consume()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
bool Exchange\+\_\+manager\+\_\+consumer\+::consume (\begin{DoxyParamCaption}\item[{\hyperlink{classSerializable}{Serializable} \&}]{serializable }\end{DoxyParamCaption})}



read from the underlying shared memory a serialized object (set by a producer). 

Should be called only if ready\+\_\+to\+\_\+consume returns true. \begin{DoxyReturn}{Returns}
true if an item has been read 
\end{DoxyReturn}
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}\label{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!lock@{lock}}
\index{lock@{lock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{lock()}{lock()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+consumer\+::lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



lock the mutex required for writting in the shared memory without any collision with any producer. 

Should be called before calls to \char`\"{}consume\char`\"{}. Not required if the constructor was called with autolock set to true \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}\label{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!nb\+\_\+char\+\_\+read@{nb\+\_\+char\+\_\+read}}
\index{nb\+\_\+char\+\_\+read@{nb\+\_\+char\+\_\+read}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{nb\+\_\+char\+\_\+read()}{nb\_char\_read()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
int Exchange\+\_\+manager\+\_\+consumer\+::nb\+\_\+char\+\_\+read (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



returns the number of char that have been read from the exchange queue. 

For debugging purposes \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}\label{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!purge\+\_\+feedbacks@{purge\+\_\+feedbacks}}
\index{purge\+\_\+feedbacks@{purge\+\_\+feedbacks}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{purge\+\_\+feedbacks()}{purge\_feedbacks()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
bool Exchange\+\_\+manager\+\_\+consumer\+::purge\+\_\+feedbacks (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). 

This shared queue may get full (e.\+g the producer does not read it fast enough), in which case the item id is buffered in this instance. If this instance stops to consume, the buffered item ids will never be written in the shared queue, and the producer will not receive the corresponding feedback. This attempts to write the buffered ids into the queue, and returns true if the buffer is not empty after the call (i.\+e. some feedbacks have not been sent yet), false otherwise. Usage\+: to call before exit until true is returned \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}\label{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!ready\+\_\+to\+\_\+consume@{ready\+\_\+to\+\_\+consume}}
\index{ready\+\_\+to\+\_\+consume@{ready\+\_\+to\+\_\+consume}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{ready\+\_\+to\+\_\+consume()}{ready\_to\_consume()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
bool Exchange\+\_\+manager\+\_\+consumer\+::ready\+\_\+to\+\_\+consume (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



returns true if a producer is also running. 

\textquotesingle{}consume\textquotesingle{} should be called only if ready\+\_\+to\+\_\+consume returns true. \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}\label{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!unlock@{unlock}}
\index{unlock@{unlock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection{\texorpdfstring{unlock()}{unlock()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+consumer\+::unlock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



unlock the mutex for writting in the shared memory without any collision with any producer. 

Not required if the constructor was called with autolock set to true 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/\hyperlink{exchange__manager__consumer_8hpp}{exchange\+\_\+manager\+\_\+consumer.\+hpp}\item 
include/shared\+\_\+memory/exchange\+\_\+manager\+\_\+consumer.\+hxx\end{DoxyCompactItemize}
