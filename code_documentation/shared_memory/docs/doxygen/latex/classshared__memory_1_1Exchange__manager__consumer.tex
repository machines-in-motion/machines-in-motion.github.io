\hypertarget{classshared__memory_1_1Exchange__manager__consumer}{}\section{shared\+\_\+memory\+:\+:Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ Class Template Reference}
\label{classshared__memory_1_1Exchange__manager__consumer}\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}{Exchange\+\_\+manager\+\_\+consumer} (std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)
\begin{DoxyCompactList}\small\item\em An exchange\+\_\+manager\+\_\+consumer reads from the shared memory serialized items produced by an instance of exchange\+\_\+manager\+\_\+producer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}{lock} ()
\begin{DoxyCompactList}\small\item\em lock the mutex required for writting in the shared memory without any collision with any producer. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}{unlock} ()
\begin{DoxyCompactList}\small\item\em unlock the mutex for writting in the shared memory without any collision with any producer. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}{consume} (\hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em read from the underlying shared memory a serialized object (set by a producer). \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}{ready\+\_\+to\+\_\+consume} ()
\begin{DoxyCompactList}\small\item\em returns true if a producer is also running. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}{purge\+\_\+feedbacks} ()
\begin{DoxyCompactList}\small\item\em When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). \end{DoxyCompactList}\item 
int \hyperlink{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}{nb\+\_\+char\+\_\+read} ()
\begin{DoxyCompactList}\small\item\em returns the number of char that have been read from the exchange queue. \end{DoxyCompactList}\item 
bool {\bfseries is\+\_\+producer\+\_\+queue\+\_\+empty} () const \hypertarget{classshared__memory_1_1Exchange__manager__consumer_ad7d4cd68db87b53a0fe45f08c4adb647}{}\label{classshared__memory_1_1Exchange__manager__consumer_ad7d4cd68db87b53a0fe45f08c4adb647}

\item 
bool {\bfseries is\+\_\+consumer\+\_\+queue\+\_\+empty} () const \hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5d50ce37fd9464f45b973f6e96b81ba3}{}\label{classshared__memory_1_1Exchange__manager__consumer_a5d50ce37fd9464f45b973f6e96b81ba3}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void {\bfseries clean\+\_\+mutex} (std\+::string segment\+\_\+id)\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5aeebd5f2857f73c91fe3212d274909e}{}\label{classshared__memory_1_1Exchange__manager__consumer_a5aeebd5f2857f73c91fe3212d274909e}

\item 
static void {\bfseries clean\+\_\+memory} (std\+::string segment\+\_\+id)\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a828a56d15a0f68edd8e3b395c41b0c0c}{}\label{classshared__memory_1_1Exchange__manager__consumer_a828a56d15a0f68edd8e3b395c41b0c0c}

\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classshared__memory_1_1internal_1_1Exchange__manager__memory}{Exchange\+\_\+manager\+\_\+memory}$<$ \hyperlink{classSerializable}{Serializable}, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ {\bfseries Memory}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a1699ba86d1d5b943d428fc1b391abd42}{}\label{classshared__memory_1_1Exchange__manager__consumer_a1699ba86d1d5b943d428fc1b391abd42}

\item 
typedef std\+::shared\+\_\+ptr$<$ \hyperlink{classshared__memory_1_1internal_1_1Exchange__manager__memory}{Memory} $>$ {\bfseries Memory\+\_\+ptr}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a92ad5c787b53c26d5b3c75712ca539f3}{}\label{classshared__memory_1_1Exchange__manager__consumer_a92ad5c787b53c26d5b3c75712ca539f3}

\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bfseries reset} ()\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a7543d28030c9c3e17b8fd60facc917b2}{}\label{classshared__memory_1_1Exchange__manager__consumer_a7543d28030c9c3e17b8fd60facc917b2}

\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Memory\+\_\+ptr {\bfseries memory\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a65f7ea81649be03ac11b11bc998d5047}{}\label{classshared__memory_1_1Exchange__manager__consumer_a65f7ea81649be03ac11b11bc998d5047}

\item 
bool {\bfseries leading\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a3d2838c1a3e709dafe1c941f217d8f54}{}\label{classshared__memory_1_1Exchange__manager__consumer_a3d2838c1a3e709dafe1c941f217d8f54}

\item 
bool {\bfseries autolock\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a6ea7ce15b0da981027f80d3d35825593}{}\label{classshared__memory_1_1Exchange__manager__consumer_a6ea7ce15b0da981027f80d3d35825593}

\item 
std\+::string {\bfseries segment\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a830f88a2c6f6d3cf6e0c83353a436742}{}\label{classshared__memory_1_1Exchange__manager__consumer_a830f88a2c6f6d3cf6e0c83353a436742}

\item 
std\+::string {\bfseries object\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_afbde973522ab55b0a3c49ef6f26fbba5}{}\label{classshared__memory_1_1Exchange__manager__consumer_afbde973522ab55b0a3c49ef6f26fbba5}

\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!Exchange\+\_\+manager\+\_\+consumer@{Exchange\+\_\+manager\+\_\+consumer}}
\index{Exchange\+\_\+manager\+\_\+consumer@{Exchange\+\_\+manager\+\_\+consumer}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{Exchange\+\_\+manager\+\_\+consumer(std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)}{Exchange_manager_consumer(std::string segment_id, std::string object_id, bool leading, bool autolock=true)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ Exchange\+\_\+manager\+\_\+consumer\+::\+Exchange\+\_\+manager\+\_\+consumer (
\begin{DoxyParamCaption}
\item[{std\+::string}]{segment\+\_\+id, }
\item[{std\+::string}]{object\+\_\+id, }
\item[{bool}]{leading, }
\item[{bool}]{autolock = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}{}\label{classshared__memory_1_1Exchange__manager__consumer_a15b2b91e57fb8c9c60ec354274edf20d}


An exchange\+\_\+manager\+\_\+consumer reads from the shared memory serialized items produced by an instance of exchange\+\_\+manager\+\_\+producer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & id of the shared memory segment \\
\hline
{\em object\+\_\+id} & id of the shared memory object prefix \\
\hline
{\em the} & consumer is to be \char`\"{}permanent\char`\"{}, while different producers may provide data. Implies the deletion of the underlying share memory upon destruction. \\
\hline
{\em mutex} & locking mechanism internally managed by the producer. If false, lock has to be \char`\"{}manually\char`\"{} called. This allows for example to set several items in one shot \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!consume@{consume}}
\index{consume@{consume}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{consume(\+Serializable \&serializable)}{consume(Serializable &serializable)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ bool Exchange\+\_\+manager\+\_\+consumer\+::consume (
\begin{DoxyParamCaption}
\item[{{\bf Serializable} \&}]{serializable}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}{}\label{classshared__memory_1_1Exchange__manager__consumer_ae3e006de034b55e328784d3eacfb1772}


read from the underlying shared memory a serialized object (set by a producer). 

Should be called only if ready\+\_\+to\+\_\+consume returns true. \begin{DoxyReturn}{Returns}
true if an item has been read 
\end{DoxyReturn}
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!lock@{lock}}
\index{lock@{lock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{lock()}{lock()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+consumer\+::lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}{}\label{classshared__memory_1_1Exchange__manager__consumer_a1ec59bb41c9de78eb891ea70efe6b8c2}


lock the mutex required for writting in the shared memory without any collision with any producer. 

Should be called before calls to \char`\"{}consume\char`\"{}. Not required if the constructor was called with autolock set to true \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!nb\+\_\+char\+\_\+read@{nb\+\_\+char\+\_\+read}}
\index{nb\+\_\+char\+\_\+read@{nb\+\_\+char\+\_\+read}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{nb\+\_\+char\+\_\+read()}{nb_char_read()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ int Exchange\+\_\+manager\+\_\+consumer\+::nb\+\_\+char\+\_\+read (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}{}\label{classshared__memory_1_1Exchange__manager__consumer_ab8651cff750b5cb2ceae97a97b2c7f2d}


returns the number of char that have been read from the exchange queue. 

For debugging purposes \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!purge\+\_\+feedbacks@{purge\+\_\+feedbacks}}
\index{purge\+\_\+feedbacks@{purge\+\_\+feedbacks}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{purge\+\_\+feedbacks()}{purge_feedbacks()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ bool Exchange\+\_\+manager\+\_\+consumer\+::purge\+\_\+feedbacks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}{}\label{classshared__memory_1_1Exchange__manager__consumer_a5e62220c9b50327130cb95683d22b0dc}


When this instance consumes an item, the item id is written in a shared queue for the producer to read (and acquire the feedback the item has been consumed). 

This shared queue may get full (e.\+g the producer does not read it fast enough), in which case the item id is buffered in this instance. If this instance stops to consume, the buffered item ids will never be written in the shared queue, and the producer will not receive the corresponding feedback. This attempts to write the buffered ids into the queue, and returns true if the buffer is not empty after the call (i.\+e. some feedbacks have not been sent yet), false otherwise. Usage\+: to call before exit until true is returned \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!ready\+\_\+to\+\_\+consume@{ready\+\_\+to\+\_\+consume}}
\index{ready\+\_\+to\+\_\+consume@{ready\+\_\+to\+\_\+consume}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{ready\+\_\+to\+\_\+consume()}{ready_to_consume()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ bool Exchange\+\_\+manager\+\_\+consumer\+::ready\+\_\+to\+\_\+consume (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}{}\label{classshared__memory_1_1Exchange__manager__consumer_af1a894d796387d297f848d18d8d55df5}


returns true if a producer is also running. 

\textquotesingle{}consume\textquotesingle{} should be called only if ready\+\_\+to\+\_\+consume returns true. \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}!unlock@{unlock}}
\index{unlock@{unlock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+consumer}}
\subsubsection[{\texorpdfstring{unlock()}{unlock()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+consumer\+::unlock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}{}\label{classshared__memory_1_1Exchange__manager__consumer_aaf053702ec1ef8455fc10e70144f6923}


unlock the mutex for writting in the shared memory without any collision with any producer. 

Not required if the constructor was called with autolock set to true 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/\hyperlink{exchange__manager__consumer_8hpp}{exchange\+\_\+manager\+\_\+consumer.\+hpp}\item 
include/shared\+\_\+memory/exchange\+\_\+manager\+\_\+consumer.\+hxx\end{DoxyCompactItemize}
