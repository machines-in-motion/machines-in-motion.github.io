\hypertarget{classshared__memory_1_1LockedConditionVariable}{}\section{shared\+\_\+memory\+:\+:Locked\+Condition\+Variable Class Reference}
\label{classshared__memory_1_1LockedConditionVariable}\index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}


The \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} class is here as a anonymous layer on top of the boost intersprocess condition variable labrary.  




{\ttfamily \#include $<$locked\+\_\+condition\+\_\+variable.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1LockedConditionVariable_a648057022bbf8a7b5221e1170b1e099c}{Locked\+Condition\+Variable} (const std\+::string object\+\_\+id, bool clean\+\_\+memory\+\_\+on\+\_\+destruction=true)
\begin{DoxyCompactList}\small\item\em A condition variable shared over the memory The condition variable is cleaned from the memory on destruction if clean\+\_\+memory\+\_\+on\+\_\+destruction is set to true. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_a31633f2243b988dc0a8bd3d4637dc216}{notify\+\_\+all} ()\hypertarget{classshared__memory_1_1LockedConditionVariable_a31633f2243b988dc0a8bd3d4637dc216}{}\label{classshared__memory_1_1LockedConditionVariable_a31633f2243b988dc0a8bd3d4637dc216}

\begin{DoxyCompactList}\small\item\em notify\+\_\+all is notifying all condition variables with the same mutex \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_a532a1332fe184e668a49fa002db5be08}{notify\+\_\+one} ()\hypertarget{classshared__memory_1_1LockedConditionVariable_a532a1332fe184e668a49fa002db5be08}{}\label{classshared__memory_1_1LockedConditionVariable_a532a1332fe184e668a49fa002db5be08}

\begin{DoxyCompactList}\small\item\em notify\+\_\+one notifies one condition variable with the same mutex \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_a9eb84ab5d570a0c5a81f6eaeb4c4dd50}{wait} ()\hypertarget{classshared__memory_1_1LockedConditionVariable_a9eb84ab5d570a0c5a81f6eaeb4c4dd50}{}\label{classshared__memory_1_1LockedConditionVariable_a9eb84ab5d570a0c5a81f6eaeb4c4dd50}

\begin{DoxyCompactList}\small\item\em wait waits until another thread notifies this object \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1LockedConditionVariable_a0d4ab218fc51fcce34146f2adca408d7}{timed\+\_\+wait} (long wait\+\_\+nano\+\_\+seconds)
\begin{DoxyCompactList}\small\item\em timed\+\_\+wait wait a notify during a certain certain time and then wake up \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1LockedConditionVariable_a86b42b23b94593bca5b12b9d792d1275}{try\+\_\+lock} ()
\begin{DoxyCompactList}\small\item\em try\+\_\+lock Tries to acquire the lock without waiting. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_a5d28bb5942fc5bc4886014d6b9b26885}{unlock} ()
\begin{DoxyCompactList}\small\item\em unlock Unlocks the lock. \end{DoxyCompactList}\item 
bool {\bfseries owns} ()\hypertarget{classshared__memory_1_1LockedConditionVariable_a30e3825249516387276801f8d2e68a8e}{}\label{classshared__memory_1_1LockedConditionVariable_a30e3825249516387276801f8d2e68a8e}

\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_a1eef63f7e3e898c3734923c987383ffe}{lock\+\_\+scope} ()
\begin{DoxyCompactList}\small\item\em lock\+\_\+scope this function is used to lock the part of the code that needs protection. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1LockedConditionVariable_adf3a50665011b3b92b80369bbbc6d4a4}{unlock\+\_\+scope} ()\hypertarget{classshared__memory_1_1LockedConditionVariable_adf3a50665011b3b92b80369bbbc6d4a4}{}\label{classshared__memory_1_1LockedConditionVariable_adf3a50665011b3b92b80369bbbc6d4a4}

\begin{DoxyCompactList}\small\item\em unlock\+\_\+scope this function unlock the mutex so remove the protection of the code \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classshared__memory_1_1LockedConditionVariable_aa3bca5020f84c8e0a90a2dad3e6521e5}{clean} (const std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} clean their shared memory on destruction. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
S\+H\+M\+Mutex \hyperlink{classshared__memory_1_1LockedConditionVariable_a757abc2190906a0773667b42be6e4e66}{mutex\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_a757abc2190906a0773667b42be6e4e66}{}\label{classshared__memory_1_1LockedConditionVariable_a757abc2190906a0773667b42be6e4e66}

\begin{DoxyCompactList}\small\item\em mutex\+\_\+ is the mutex associated to the condition variable \end{DoxyCompactList}\item 
S\+H\+M\+Condition $\ast$ \hyperlink{classshared__memory_1_1LockedConditionVariable_a8bc7fb73332304b406335e38ba4cdd1b}{condition\+\_\+variable\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_a8bc7fb73332304b406335e38ba4cdd1b}{}\label{classshared__memory_1_1LockedConditionVariable_a8bc7fb73332304b406335e38ba4cdd1b}

\begin{DoxyCompactList}\small\item\em condition\+\_\+variable\+\_\+ is the boost condition variable that is used \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ S\+H\+M\+Scope\+Lock $>$ \hyperlink{classshared__memory_1_1LockedConditionVariable_a5509b431f2d459d92bfcc1b2d60651d1}{lock\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_a5509b431f2d459d92bfcc1b2d60651d1}{}\label{classshared__memory_1_1LockedConditionVariable_a5509b431f2d459d92bfcc1b2d60651d1}

\begin{DoxyCompactList}\small\item\em lock\+\_\+ is a object that protects the codes with a mutex, see the boost documentation about \char`\"{}boost\+::interprocess\+::scoped\+\_\+lock\char`\"{} \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1LockedConditionVariable_abe0963bc5746d19350e816ad42ff47b1}{clean\+\_\+memory\+\_\+on\+\_\+destruction\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_abe0963bc5746d19350e816ad42ff47b1}{}\label{classshared__memory_1_1LockedConditionVariable_abe0963bc5746d19350e816ad42ff47b1}

\begin{DoxyCompactList}\small\item\em if true (the default), clean the shared memory of the hosted mutex and condition. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{classshared__memory_1_1LockedConditionVariable_a07d7d718e33cc2e833cf9bb22fe8fada}{mutex\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_a07d7d718e33cc2e833cf9bb22fe8fada}{}\label{classshared__memory_1_1LockedConditionVariable_a07d7d718e33cc2e833cf9bb22fe8fada}

\begin{DoxyCompactList}\small\item\em mutex\+\_\+id\+\_\+ is the mutex name in the shared memory \end{DoxyCompactList}\item 
std\+::string \hyperlink{classshared__memory_1_1LockedConditionVariable_a7cf01915f9d1a8795f4e69345cd1e1e4}{condition\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_a7cf01915f9d1a8795f4e69345cd1e1e4}{}\label{classshared__memory_1_1LockedConditionVariable_a7cf01915f9d1a8795f4e69345cd1e1e4}

\begin{DoxyCompactList}\small\item\em condition\+\_\+id\+\_\+ is the condition variable name in the shared memory \end{DoxyCompactList}\item 
boost\+::interprocess\+::managed\+\_\+shared\+\_\+memory \hyperlink{classshared__memory_1_1LockedConditionVariable_ae6a197846be3bd4ccf4899754778f16b}{segment\+\_\+manager\+\_\+}\hypertarget{classshared__memory_1_1LockedConditionVariable_ae6a197846be3bd4ccf4899754778f16b}{}\label{classshared__memory_1_1LockedConditionVariable_ae6a197846be3bd4ccf4899754778f16b}

\begin{DoxyCompactList}\small\item\em shm\+\_\+segment is the boost object that manages the shared memory segment \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} class is here as a anonymous layer on top of the boost intersprocess condition variable labrary. 

It creates a condition variable in a shared memory automatically. 

\subsection{Constructor \& Destructor Documentation}
\index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!Locked\+Condition\+Variable@{Locked\+Condition\+Variable}}
\index{Locked\+Condition\+Variable@{Locked\+Condition\+Variable}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{Locked\+Condition\+Variable(const std\+::string object\+\_\+id, bool clean\+\_\+memory\+\_\+on\+\_\+destruction=true)}{LockedConditionVariable(const std::string object_id, bool clean_memory_on_destruction=true)}}]{\setlength{\rightskip}{0pt plus 5cm}shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::\+Locked\+Condition\+Variable (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{object\+\_\+id, }
\item[{bool}]{clean\+\_\+memory\+\_\+on\+\_\+destruction = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1LockedConditionVariable_a648057022bbf8a7b5221e1170b1e099c}{}\label{classshared__memory_1_1LockedConditionVariable_a648057022bbf8a7b5221e1170b1e099c}


A condition variable shared over the memory The condition variable is cleaned from the memory on destruction if clean\+\_\+memory\+\_\+on\+\_\+destruction is set to true. 

Contrary to \hyperlink{classshared__memory_1_1ConditionVariable}{shared\+\_\+memory\+::\+Condition\+Variable}, instances of this class manages their mutex and lock internally, with the consequence the mutex can be locked and unlocked exclusively through other instances of \hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable}. 

\subsection{Member Function Documentation}
\index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!clean@{clean}}
\index{clean@{clean}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{clean(const std\+::string segment\+\_\+id)}{clean(const std::string segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::clean (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{segment\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classshared__memory_1_1LockedConditionVariable_aa3bca5020f84c8e0a90a2dad3e6521e5}{}\label{classshared__memory_1_1LockedConditionVariable_aa3bca5020f84c8e0a90a2dad3e6521e5}


\hyperlink{classshared__memory_1_1LockedConditionVariable}{Locked\+Condition\+Variable} clean their shared memory on destruction. 

But the destructor may have failed to be called if for some reason the program crashed. \index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!lock\+\_\+scope@{lock\+\_\+scope}}
\index{lock\+\_\+scope@{lock\+\_\+scope}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{lock\+\_\+scope()}{lock_scope()}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::lock\+\_\+scope (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1LockedConditionVariable_a1eef63f7e3e898c3734923c987383ffe}{}\label{classshared__memory_1_1LockedConditionVariable_a1eef63f7e3e898c3734923c987383ffe}


lock\+\_\+scope this function is used to lock the part of the code that needs protection. 

It locks the mutex until unlock\+\_\+scope is used \index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!timed\+\_\+wait@{timed\+\_\+wait}}
\index{timed\+\_\+wait@{timed\+\_\+wait}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{timed\+\_\+wait(long wait\+\_\+nano\+\_\+seconds)}{timed_wait(long wait_nano_seconds)}}]{\setlength{\rightskip}{0pt plus 5cm}bool shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::timed\+\_\+wait (
\begin{DoxyParamCaption}
\item[{long}]{wait\+\_\+nano\+\_\+seconds}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1LockedConditionVariable_a0d4ab218fc51fcce34146f2adca408d7}{}\label{classshared__memory_1_1LockedConditionVariable_a0d4ab218fc51fcce34146f2adca408d7}


timed\+\_\+wait wait a notify during a certain certain time and then wake up 


\begin{DoxyParams}{Parameters}
{\em wait\+\_\+duration} & in microsecond \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true\+: the condition variable has been notified, false otherwize 
\end{DoxyReturn}
\index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!try\+\_\+lock@{try\+\_\+lock}}
\index{try\+\_\+lock@{try\+\_\+lock}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{try\+\_\+lock()}{try_lock()}}]{\setlength{\rightskip}{0pt plus 5cm}bool shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::try\+\_\+lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1LockedConditionVariable_a86b42b23b94593bca5b12b9d792d1275}{}\label{classshared__memory_1_1LockedConditionVariable_a86b42b23b94593bca5b12b9d792d1275}


try\+\_\+lock Tries to acquire the lock without waiting. 

\begin{DoxyReturn}{Returns}
true if manages to acquire the lock, false otherwise. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\index{shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}!unlock@{unlock}}
\index{unlock@{unlock}!shared\+\_\+memory\+::\+Locked\+Condition\+Variable@{shared\+\_\+memory\+::\+Locked\+Condition\+Variable}}
\subsubsection[{\texorpdfstring{unlock()}{unlock()}}]{\setlength{\rightskip}{0pt plus 5cm}void shared\+\_\+memory\+::\+Locked\+Condition\+Variable\+::unlock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1LockedConditionVariable_a5d28bb5942fc5bc4886014d6b9b26885}{}\label{classshared__memory_1_1LockedConditionVariable_a5d28bb5942fc5bc4886014d6b9b26885}


unlock Unlocks the lock. 


\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/locked\+\_\+condition\+\_\+variable.\+hpp\item 
src/locked\+\_\+condition\+\_\+variable.\+cpp\end{DoxyCompactItemize}
