\hypertarget{classshared__memory_1_1Exchange__manager__producer}{}\section{shared\+\_\+memory\+:\+:Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ Class Template Reference}
\label{classshared__memory_1_1Exchange__manager__producer}\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}{Exchange\+\_\+manager\+\_\+producer} (std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)
\begin{DoxyCompactList}\small\item\em An exchange\+\_\+manager\+\_\+producer writes in the shared memory serialized items expected to be consumed by an instance of exchange\+\_\+manager\+\_\+consumer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}{ready\+\_\+to\+\_\+produce} ()
\begin{DoxyCompactList}\small\item\em returns true if a consumer is also running. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}{lock} ()
\begin{DoxyCompactList}\small\item\em lock the mutex required for writting in the shared memory without any collision with any consumer. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}{unlock} ()
\begin{DoxyCompactList}\small\item\em unlock the mutex for writting in the shared memory without any collision with any consumer. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}{set} (const \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Set this serializable to be consumed. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}{clear} ()
\begin{DoxyCompactList}\small\item\em removed all elements from the shared queue \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}{get} (std\+::deque$<$ int $>$ \&get\+\_\+consumed\+\_\+ids)\hypertarget{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}{}\label{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}

\begin{DoxyCompactList}\small\item\em write into get\+\_\+consumed\+\_\+ids the ids of serialized items that have been successfully consumed by a consumer \end{DoxyCompactList}\item 
int \hyperlink{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}{nb\+\_\+char\+\_\+written} ()
\begin{DoxyCompactList}\small\item\em returns the number of characters that have been serialized and written to the exchange queue. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}{reset\+\_\+char\+\_\+count} ()\hypertarget{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}{}\label{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}

\begin{DoxyCompactList}\small\item\em reset the count of characters written to the exchange queue to zero \end{DoxyCompactList}\item 
bool {\bfseries producer\+\_\+queue\+\_\+empty} () const \hypertarget{classshared__memory_1_1Exchange__manager__producer_a32172d2cbf30e1bcb2a45778063e6ff2}{}\label{classshared__memory_1_1Exchange__manager__producer_a32172d2cbf30e1bcb2a45778063e6ff2}

\item 
bool {\bfseries consumer\+\_\+queue\+\_\+empty} () const \hypertarget{classshared__memory_1_1Exchange__manager__producer_a208c79c39c9206b22aecb919eb0df87e}{}\label{classshared__memory_1_1Exchange__manager__producer_a208c79c39c9206b22aecb919eb0df87e}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}{clean\+\_\+mutex} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em (unlock) and erase the mutex from the shared memory. \end{DoxyCompactList}\item 
static void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}{clean\+\_\+memory} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em wipe out the corresponding shared memory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classshared__memory_1_1internal_1_1Exchange__manager__memory}{Exchange\+\_\+manager\+\_\+memory}$<$ \hyperlink{classSerializable}{Serializable}, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ {\bfseries Memory}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a65119cf07c0c10f167c191c9ee913029}{}\label{classshared__memory_1_1Exchange__manager__producer_a65119cf07c0c10f167c191c9ee913029}

\item 
typedef std\+::shared\+\_\+ptr$<$ \hyperlink{classshared__memory_1_1internal_1_1Exchange__manager__memory}{Memory} $>$ {\bfseries Memory\+\_\+ptr}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a7f3d7760ca2d1c01fa88e7a6447a38d7}{}\label{classshared__memory_1_1Exchange__manager__producer_a7f3d7760ca2d1c01fa88e7a6447a38d7}

\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bfseries reset} ()\hypertarget{classshared__memory_1_1Exchange__manager__producer_a2148cfb2e9a1973089d81237ea5735b9}{}\label{classshared__memory_1_1Exchange__manager__producer_a2148cfb2e9a1973089d81237ea5735b9}

\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Memory\+\_\+ptr {\bfseries memory\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a67f2a2c049dabace06c85a35335d1614}{}\label{classshared__memory_1_1Exchange__manager__producer_a67f2a2c049dabace06c85a35335d1614}

\item 
bool {\bfseries autolock\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a6d89b939f08bbb9180460a0fab2c877f}{}\label{classshared__memory_1_1Exchange__manager__producer_a6d89b939f08bbb9180460a0fab2c877f}

\item 
bool {\bfseries leading\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a4c71d725b7b95e4dd00ecf68232d4ac9}{}\label{classshared__memory_1_1Exchange__manager__producer_a4c71d725b7b95e4dd00ecf68232d4ac9}

\item 
std\+::string {\bfseries segment\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a96ce58e9619ac28b31b46a81c53c20c2}{}\label{classshared__memory_1_1Exchange__manager__producer_a96ce58e9619ac28b31b46a81c53c20c2}

\item 
std\+::string {\bfseries object\+\_\+id\+\_\+}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a57ea2e6076963223331f3b6e78cbbc05}{}\label{classshared__memory_1_1Exchange__manager__producer_a57ea2e6076963223331f3b6e78cbbc05}

\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!Exchange\+\_\+manager\+\_\+producer@{Exchange\+\_\+manager\+\_\+producer}}
\index{Exchange\+\_\+manager\+\_\+producer@{Exchange\+\_\+manager\+\_\+producer}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{Exchange\+\_\+manager\+\_\+producer(std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)}{Exchange_manager_producer(std::string segment_id, std::string object_id, bool leading, bool autolock=true)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ Exchange\+\_\+manager\+\_\+producer\+::\+Exchange\+\_\+manager\+\_\+producer (
\begin{DoxyParamCaption}
\item[{std\+::string}]{segment\+\_\+id, }
\item[{std\+::string}]{object\+\_\+id, }
\item[{bool}]{leading, }
\item[{bool}]{autolock = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}{}\label{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}


An exchange\+\_\+manager\+\_\+producer writes in the shared memory serialized items expected to be consumed by an instance of exchange\+\_\+manager\+\_\+consumer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & id of the shared memory segment \\
\hline
{\em object\+\_\+id} & id of the shared memory object prefix \\
\hline
{\em autolock} & mutex locking mechanism internally managed by the producer. If false, lock has to be \char`\"{}manually\char`\"{} called. This allows for example to set several items in one shot \\
\hline
{\em clean\+\_\+memory\+\_\+on\+\_\+exit.} & If true, the destructor will clean the underlined shared memory items. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clean\+\_\+memory@{clean\+\_\+memory}}
\index{clean\+\_\+memory@{clean\+\_\+memory}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{clean\+\_\+memory(std\+::string segment\+\_\+id)}{clean_memory(std::string segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+producer\+::clean\+\_\+memory (
\begin{DoxyParamCaption}
\item[{std\+::string}]{segment\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}{}\label{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}


wipe out the corresponding shared memory. 

To be used if some executable using the exchange manager crashed without calls to destructors. \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clean\+\_\+mutex@{clean\+\_\+mutex}}
\index{clean\+\_\+mutex@{clean\+\_\+mutex}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{clean\+\_\+mutex(std\+::string segment\+\_\+id)}{clean_mutex(std::string segment_id)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+producer\+::clean\+\_\+mutex (
\begin{DoxyParamCaption}
\item[{std\+::string}]{segment\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}{}\label{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}


(unlock) and erase the mutex from the shared memory. 

To be used if some executable using the exchange manager crashed without calls to destructors. \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clear@{clear}}
\index{clear@{clear}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+producer\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}{}\label{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}


removed all elements from the shared queue 

\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!lock@{lock}}
\index{lock@{lock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{lock()}{lock()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+producer\+::lock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}{}\label{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}


lock the mutex required for writting in the shared memory without any collision with any consumer. 

Should be called before calls to \char`\"{}set\char`\"{}. Not required if the constructor was called with autolock set to true \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!nb\+\_\+char\+\_\+written@{nb\+\_\+char\+\_\+written}}
\index{nb\+\_\+char\+\_\+written@{nb\+\_\+char\+\_\+written}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{nb\+\_\+char\+\_\+written()}{nb_char_written()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ int Exchange\+\_\+manager\+\_\+producer\+::nb\+\_\+char\+\_\+written (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}{}\label{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}


returns the number of characters that have been serialized and written to the exchange queue. 

For debug purposes. \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!ready\+\_\+to\+\_\+produce@{ready\+\_\+to\+\_\+produce}}
\index{ready\+\_\+to\+\_\+produce@{ready\+\_\+to\+\_\+produce}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{ready\+\_\+to\+\_\+produce()}{ready_to_produce()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ bool Exchange\+\_\+manager\+\_\+producer\+::ready\+\_\+to\+\_\+produce (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}{}\label{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}


returns true if a consumer is also running. 

\textquotesingle{}set\textquotesingle{} should be called only if ready\+\_\+to\+\_\+produce returns true. \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!set@{set}}
\index{set@{set}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{set(const Serializable \&serializable)}{set(const Serializable &serializable)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ bool Exchange\+\_\+manager\+\_\+producer\+::set (
\begin{DoxyParamCaption}
\item[{const {\bf Serializable} \&}]{serializable}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}{}\label{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}


Set this serializable to be consumed. 

Throws \hyperlink{classshared__memory_1_1Memory__overflow__exception}{shared\+\_\+memory\+::\+Memory\+\_\+overflow\+\_\+exception} if the shared memory is full. Some of the shared memory should get free once items have been consumed by a consumer. This method should be called only if \textquotesingle{}ready\+\_\+to\+\_\+produce\textquotesingle{} returns true; Returns true if all data could be written in the shared memory, false if some data required to be buffered (any following call to set, if any, will perform a new attempt to write remaining buffer to the shared memory) \index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!unlock@{unlock}}
\index{unlock@{unlock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection[{\texorpdfstring{unlock()}{unlock()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ void Exchange\+\_\+manager\+\_\+producer\+::unlock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}{}\label{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}


unlock the mutex for writting in the shared memory without any collision with any consumer. 

Not required if the constructor was called with autolock set to true 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/\hyperlink{exchange__manager__producer_8hpp}{exchange\+\_\+manager\+\_\+producer.\+hpp}\item 
include/shared\+\_\+memory/exchange\+\_\+manager\+\_\+producer.\+hxx\end{DoxyCompactItemize}
